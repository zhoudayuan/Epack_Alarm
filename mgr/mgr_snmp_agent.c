/**
 * Copyright (C), 1993-2014, Hytera Comm. Co., Ltd.
 * @file    mgr_snmp_agent.c
 * @brief   snmp代理模块
 * @author  王存刚
 * @version v1.0
 * @date    2016-8-1
 */
/*
 *   函数列表
 *   1. handle_id1Freq       设置1号链路机频点
 *   2. handle_id2Freq       设置2号链路机频点
 *   3. handle_id3Freq       设置3号链路机频点
 *   4. handle_id4Freq       设置4号链路机频点
 *   5. handle_id5Freq       设置5号链路机频点
 *   6. handle_id6Freq       设置6号链路机频点
 *   7. handle_id7Freq       设置7号链路机频点
 *   8. handle_id8Freq       设置8号链路机频点
 *   9. handle_id9Freq       设置9号链路机频点
 *   10. handle_id10Freq       设置10号链路机频点
 *   11. handle_id11Freq       设置11号链路机频点
 *   12. handle_id12Freq       设置12号链路机频点
 *   13. handle_id13Freq       设置13号链路机频点
 *   14. handle_id14Freq       设置14号链路机频点
 *   15. handle_id15Freq       设置15号链路机频点
 *   16. handle_id16Freq       设置16号链路机频点
 *   17. handle_emissiveVCOFreq       设置发射VCO  频点
 *   18. handle_receivingVCOFreq       设置接收VCO  频点
 *   19. handle_secondLocalOscillatorFreq       设置二本振频点
 *   20. handle_powerAmplifierSwitch       设置功放开关
 *   21. handle_fpgaParam       读取eeprom中初始参数
 *   22. handle_power       设置功率
 *   23. handle_afc       设置AFC值
 *   24. handle_saveAFC       保存AFC值
 *   25. handle_iqs       设置IQS
 *   26. handle_saveIQS       保存IQS
 *   27. handle_startDCCalibration       开始直流偏置校准
 *   28. handle_saveOffset       保存offset
 *   29. handle_startPhaseCalibration      开始相位校准
 *   30. handle_savePhase       保存相位值
 *
 *   修改历史
 *   2016-8-1                王存刚                     建立文件
****************************************************************************/

/******************************************************************************
 *   头文件
 *   *************************************************************************/
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h> 
#include <fcntl.h>        //open
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <sys/sem.h> 
#include <sys/ipc.h>	  //shmget
#include <sys/shm.h>	  //shmget
#include <arpa/inet.h>	  //inet_addr(); inet_ntoa()
#include <sys/socket.h>
#include <pthread.h>
#include <sys/time.h>
#include <time.h>
#include "mgr_snmp_agent.h"

#undef TASK_NAME
#define TASK_NAME	"MGR_SNMP_AGENT"
#define BUFFERSIZE 4096
#define FILE_INFO_LEN 128
#define MD5_LEN 32
char buffer[30]= {0};

#define F(x, y, z) (((x) & (y)) | ((~x) & (z)))
#define G(x, y, z) (((x) & (z)) | ((y) & (~z)))
#define H(x, y, z) ((x) ^ (y) ^ (z))
#define I(x, y, z) ((y) ^ ((x) | (~z)))
#define RL(x, y) (((x) << (y)) | ((x) >> (32 - (y))))
#define PP(x) (x<<24)|((x<<8)&0xff0000)|((x>>8)&0xff00)|(x>>24)
#define FF(a, b, c, d, x, s, ac) a = b + (RL((a + F(b,c,d) + x + ac),s))
#define GG(a, b, c, d, x, s, ac) a = b + (RL((a + G(b,c,d) + x + ac),s))
#define HH(a, b, c, d, x, s, ac) a = b + (RL((a + H(b,c,d) + x + ac),s))
#define II(a, b, c, d, x, s, ac) a = b + (RL((a + I(b,c,d) + x + ac),s))

unsigned int A,B,C,D,a,b,c,d,flen[2],x[16];
int i, len;
char filename[200];
FILE *fp;

/**
 * @var md5_sum_in_bin
 * @brief 从bin文件中提取的md5校验码
 */
char md5_sum_in_bin[MD5_LEN + 1] = {0};

/**
 * @var md5_sum
 * @brief 计算的md5校验码
 */
char md5_sum[MD5_LEN + 1] = {0};

/**
 * @var s_i4LogMsgId
 * @brief 命令行套接字
 */
static INT32 s_i4LogMsgId;
 /**
 * @var pLogTxtFd
 * @brief 文件句柄
 */
static FILE *pLogTxtFd = NULL;

#include "log.h"

SHM_IPC_STRU *ptIPCShm = NULL;
int power_range[]={1,5,10,16,20};



/******************************************************************************
 *   全局变量
 *   *************************************************************************/
/**
 * @var shmid_cfg
 * @brief 配置区共享内存IPC键值
 */
int shmid_cfg;	 
/**
 * @var semid_cfg
 * @brief 配置区共享内存信号量IPC键值
 */
int semid_cfg;	 
/**
 * @var shm_cfg_addr
 * @brief 配置区共享内存地址
 */
SHM_CFG_STRU * shm_cfg_addr = NULL;
/**
 * @var shmid_ipc
 * @brief 进程间通信共享内存IPC键值
 */
int shmid_ipc;	 
/**
 * @var semid_ipc
 * @brief 进程间通信共享内存信号量IPC键值
 */
int semid_ipc;	 
/**
 * @var shm_ipc_addr
 * @brief 进程间通信共享内存地址
 */
SHM_IPC_STRU * shm_ipc_addr = NULL;
/**
 * @var shmid_nm
 * @brief 网管区共享内存IPC键值
 */
int shmid_nm;	 
/**
 * @var semid_nm
 * @brief 网管区共享内存信号量IPC键值
 */
int semid_nm;	 
/**
 * @var shm_nm_addr
 * @brief 网管区共享内存地址
 */
SHM_NM_STRU * shm_nm_addr = NULL;
/**
 * @var sock_ipc
 * @brief 进程间通信套接字
 */
int sock_ipc;
/**
 * @var sockaddr_mgra_adp
 * @brief 网管代理向空口适配模块发送数据的套接字地址
 */
struct sockaddr_in sockaddr_mgra_adp;
/**
 * @var sockaddr_mgra_adp
 * @brief 网管代理向网管处理模块发送数据的套接字地址
 */
struct sockaddr_in sockaddr_mgra_mgrh;
/*手咪*/

/**
 * @var sockaddr_mgra_cc
 * @brief 网管代理向控制中心处理模块发送数据的套接字地址
 */
struct sockaddr_in sockaddr_mgra_cc;

/**
 * @var local_cc
 * @brief 本地色码值
 */
unsigned int local_cc = 0;
/**
 * @var local_dev_id
 * @brief 本地设备ID
 */
unsigned int local_dev_id = 0;

/**
 * @var timeout_cnt
 * @brief 网管命令的超时计数
 */
unsigned int timeout_cnt = 0;
unsigned int debug_timeout_cnt = 0;


/** Initializes the hyteraWirelessLink module */
void
init_mgr_snmp_agent(void)
{
	//log写文件
	key_t msqKey;
	pLogTxtFd = fopen("./LOG.txt","r+");
	if(NULL == pLogTxtFd)
	{
		printf("[ROUTE]fopen Log.txt fail!!!\n");
		return;
	}
	fseek(pLogTxtFd,0,SEEK_END);
	//log日志输出
	if((msqKey = ftok("/", LOG_MSG_ID)) == -1)
	{
		LOG_WFile(pLogTxtFd,"[Route_Init]Creat msqKey Error\n");
		return;
	}
	s_i4LogMsgId = msgget(msqKey, IPC_EXCL);  /*检查消息队列是否存在*/
	if(s_i4LogMsgId < 0)
	{
		LOG_WFile(pLogTxtFd,"[Route_Init]failed to get msq\n");
	    return;
	}
	
    timeout_cnt = NM_TIMEOUT_TIME / POLLING_INTERVA;
	debug_timeout_cnt = NM_DEBUG_TIMEOUT_TIME / POLLING_INTERVA;
		
	if (shm_cfg_attch())
	{
		LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| shm_cfg_attch err\n", __FILE__, __FUNCTION__, __LINE__);
		return;
	}

	if (shm_ipc_attch())
	{
		LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| shm_ipc_attch err\n", __FILE__, __FUNCTION__, __LINE__);
		return;
	}
	
	if (shm_nm_attch())
	{
		LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| shm_nm_attch err\n", __FILE__, __FUNCTION__, __LINE__);
		return;
	}

	init_local_val();

	if (init_ipc_socket())
	{
		LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| init_ipc_socket err\n", __FILE__, __FUNCTION__, __LINE__);
		return;
	}

	
	/* 配置*/
    const oid id1Freq_oid[] = { 1,3,6,1,4,1,40400,1,1,1 };
    const oid id2Freq_oid[] = { 1,3,6,1,4,1,40400,1,1,2 };
    const oid id3Freq_oid[] = { 1,3,6,1,4,1,40400,1,1,3 };
    const oid id4Freq_oid[] = { 1,3,6,1,4,1,40400,1,1,4 };
    const oid id5Freq_oid[] = { 1,3,6,1,4,1,40400,1,1,5 };
    const oid id6Freq_oid[] = { 1,3,6,1,4,1,40400,1,1,6 };
    const oid id7Freq_oid[] = { 1,3,6,1,4,1,40400,1,1,7 };
    const oid id8Freq_oid[] = { 1,3,6,1,4,1,40400,1,1,8 };
    const oid id9Freq_oid[] = { 1,3,6,1,4,1,40400,1,1,9 };
    const oid id10Freq_oid[] = { 1,3,6,1,4,1,40400,1,1,10 };
    const oid id11Freq_oid[] = { 1,3,6,1,4,1,40400,1,1,11 };
    const oid id12Freq_oid[] = { 1,3,6,1,4,1,40400,1,1,12 };
    const oid id13Freq_oid[] = { 1,3,6,1,4,1,40400,1,1,13 };
    const oid id14Freq_oid[] = { 1,3,6,1,4,1,40400,1,1,14 };
    const oid id15Freq_oid[] = { 1,3,6,1,4,1,40400,1,1,15 };
    const oid id16Freq_oid[] = { 1,3,6,1,4,1,40400,1,1,16 };
	const oid id17Freq_oid[] = { 1,3,6,1,4,1,40400,1,1,17 };
    const oid id18Freq_oid[] = { 1,3,6,1,4,1,40400,1,1,18 };
    const oid id19Freq_oid[] = { 1,3,6,1,4,1,40400,1,1,19 };
    const oid id20Freq_oid[] = { 1,3,6,1,4,1,40400,1,1,20 };
    const oid id21Freq_oid[] = { 1,3,6,1,4,1,40400,1,1,21 };
    const oid id22Freq_oid[] = { 1,3,6,1,4,1,40400,1,1,22 };
    const oid id23Freq_oid[] = { 1,3,6,1,4,1,40400,1,1,23 };
    const oid id24Freq_oid[] = { 1,3,6,1,4,1,40400,1,1,24 };
    const oid id25Freq_oid[] = { 1,3,6,1,4,1,40400,1,1,25 };
    const oid id26Freq_oid[] = { 1,3,6,1,4,1,40400,1,1,26 };
    const oid id27Freq_oid[] = { 1,3,6,1,4,1,40400,1,1,27 };
    const oid id28Freq_oid[] = { 1,3,6,1,4,1,40400,1,1,28 };
    const oid id29Freq_oid[] = { 1,3,6,1,4,1,40400,1,1,29 };
    const oid id30Freq_oid[] = { 1,3,6,1,4,1,40400,1,1,30 };
    const oid id31Freq_oid[] = { 1,3,6,1,4,1,40400,1,1,31 };
    const oid id32Freq_oid[] = { 1,3,6,1,4,1,40400,1,1,32 };

    const oid id1Power_oid[] = { 1,3,6,1,4,1,40400,1,2,1 };
    const oid id2Power_oid[] = { 1,3,6,1,4,1,40400,1,2,2 };
    const oid id3Power_oid[] = { 1,3,6,1,4,1,40400,1,2,3 };
    const oid id4Power_oid[] = { 1,3,6,1,4,1,40400,1,2,4 };
    const oid id5Power_oid[] = { 1,3,6,1,4,1,40400,1,2,5 };
    const oid id6Power_oid[] = { 1,3,6,1,4,1,40400,1,2,6 };
    const oid id7Power_oid[] = { 1,3,6,1,4,1,40400,1,2,7 };
    const oid id8Power_oid[] = { 1,3,6,1,4,1,40400,1,2,8 };
    const oid id9Power_oid[] = { 1,3,6,1,4,1,40400,1,2,9 };
    const oid id10Power_oid[] = { 1,3,6,1,4,1,40400,1,2,10 };
    const oid id11Power_oid[] = { 1,3,6,1,4,1,40400,1,2,11 };
    const oid id12Power_oid[] = { 1,3,6,1,4,1,40400,1,2,12 };
    const oid id13Power_oid[] = { 1,3,6,1,4,1,40400,1,2,13 };
    const oid id14Power_oid[] = { 1,3,6,1,4,1,40400,1,2,14 };
    const oid id15Power_oid[] = { 1,3,6,1,4,1,40400,1,2,15 };
    const oid id16Power_oid[] = { 1,3,6,1,4,1,40400,1,2,16 };
    const oid id17Power_oid[] = { 1,3,6,1,4,1,40400,1,2,17 };
    const oid id18Power_oid[] = { 1,3,6,1,4,1,40400,1,2,18 };
    const oid id19Power_oid[] = { 1,3,6,1,4,1,40400,1,2,19 };
    const oid id20Power_oid[] = { 1,3,6,1,4,1,40400,1,2,20 };
    const oid id21Power_oid[] = { 1,3,6,1,4,1,40400,1,2,21 };
    const oid id22Power_oid[] = { 1,3,6,1,4,1,40400,1,2,22 };
    const oid id23Power_oid[] = { 1,3,6,1,4,1,40400,1,2,23 };
    const oid id24Power_oid[] = { 1,3,6,1,4,1,40400,1,2,24 };
    const oid id25Power_oid[] = { 1,3,6,1,4,1,40400,1,2,25};
    const oid id26Power_oid[] = { 1,3,6,1,4,1,40400,1,2,26 };
    const oid id27Power_oid[] = { 1,3,6,1,4,1,40400,1,2,27};
    const oid id28Power_oid[] = { 1,3,6,1,4,1,40400,1,2,28 };
    const oid id29Power_oid[] = { 1,3,6,1,4,1,40400,1,2,29 };
    const oid id30Power_oid[] = { 1,3,6,1,4,1,40400,1,2,30 };
    const oid id31Power_oid[] = { 1,3,6,1,4,1,40400,1,2,31 };
    const oid id32Power_oid[] = { 1,3,6,1,4,1,40400,1,2,32 };

    const oid id1StartNeighbor_oid[] = { 1,3,6,1,4,1,40400,1,3,1 };
    const oid id2StartNeighbor_oid[] = { 1,3,6,1,4,1,40400,1,3,2 };
    const oid id3StartNeighbor_oid[] = { 1,3,6,1,4,1,40400,1,3,3 };
    const oid id4StartNeighbor_oid[] = { 1,3,6,1,4,1,40400,1,3,4 };
    const oid id5StartNeighbor_oid[] = { 1,3,6,1,4,1,40400,1,3,5 };
    const oid id6StartNeighbor_oid[] = { 1,3,6,1,4,1,40400,1,3,6 };
    const oid id7StartNeighbor_oid[] = { 1,3,6,1,4,1,40400,1,3,7 };
    const oid id8StartNeighbor_oid[] = { 1,3,6,1,4,1,40400,1,3,8 };
    const oid id9StartNeighbor_oid[] = { 1,3,6,1,4,1,40400,1,3,9 };
    const oid id10StartNeighbor_oid[] = { 1,3,6,1,4,1,40400,1,3,10 };
    const oid id11StartNeighbor_oid[] = { 1,3,6,1,4,1,40400,1,3,11 };
    const oid id12StartNeighbor_oid[] = { 1,3,6,1,4,1,40400,1,3,12 };
    const oid id13StartNeighbor_oid[] = { 1,3,6,1,4,1,40400,1,3,13 };
    const oid id14StartNeighbor_oid[] = { 1,3,6,1,4,1,40400,1,3,14 };
    const oid id15StartNeighbor_oid[] = { 1,3,6,1,4,1,40400,1,3,15 };
    const oid id16StartNeighbor_oid[] = { 1,3,6,1,4,1,40400,1,3,16 };
    const oid id17StartNeighbor_oid[] = { 1,3,6,1,4,1,40400,1,3,17 };
    const oid id18StartNeighbor_oid[] = { 1,3,6,1,4,1,40400,1,3,18 };
    const oid id19StartNeighbor_oid[] = { 1,3,6,1,4,1,40400,1,3,19 };
    const oid id20StartNeighbor_oid[] = { 1,3,6,1,4,1,40400,1,3,20 };
    const oid id21StartNeighbor_oid[] = { 1,3,6,1,4,1,40400,1,3,21 };
    const oid id22StartNeighbor_oid[] = { 1,3,6,1,4,1,40400,1,3,22 };
    const oid id23StartNeighbor_oid[] = { 1,3,6,1,4,1,40400,1,3,23 };
    const oid id24StartNeighbor_oid[] = { 1,3,6,1,4,1,40400,1,3,24 };
    const oid id25StartNeighbor_oid[] = { 1,3,6,1,4,1,40400,1,3,25};
    const oid id26StartNeighbor_oid[] = { 1,3,6,1,4,1,40400,1,3,26 };
    const oid id27StartNeighbor_oid[] = { 1,3,6,1,4,1,40400,1,3,27};
    const oid id28StartNeighbor_oid[] = { 1,3,6,1,4,1,40400,1,3,28 };
    const oid id29StartNeighbor_oid[] = { 1,3,6,1,4,1,40400,1,3,29 };
    const oid id30StartNeighbor_oid[] = { 1,3,6,1,4,1,40400,1,3,30 };
    const oid id31StartNeighbor_oid[] = { 1,3,6,1,4,1,40400,1,3,31 };
    const oid id32StartNeighbor_oid[] = { 1,3,6,1,4,1,40400,1,3,32 };

    const oid id1NeighborPeriod_oid[] = { 1,3,6,1,4,1,40400,1,4,1 };
    const oid id2NeighborPeriod_oid[] = { 1,3,6,1,4,1,40400,1,4,2 };
    const oid id3NeighborPeriod_oid[] = { 1,3,6,1,4,1,40400,1,4,3 };
    const oid id4NeighborPeriod_oid[] = { 1,3,6,1,4,1,40400,1,4,4 };
    const oid id5NeighborPeriod_oid[] = { 1,3,6,1,4,1,40400,1,4,5 };
    const oid id6NeighborPeriod_oid[] = { 1,3,6,1,4,1,40400,1,4,6 };
    const oid id7NeighborPeriod_oid[] = { 1,3,6,1,4,1,40400,1,4,7 };
    const oid id8NeighborPeriod_oid[] = { 1,3,6,1,4,1,40400,1,4,8 };
    const oid id9NeighborPeriod_oid[] = { 1,3,6,1,4,1,40400,1,4,9 };
    const oid id10NeighborPeriod_oid[] = { 1,3,6,1,4,1,40400,1,4,10 };
    const oid id11NeighborPeriod_oid[] = { 1,3,6,1,4,1,40400,1,4,11 };
    const oid id12NeighborPeriod_oid[] = { 1,3,6,1,4,1,40400,1,4,12 };
    const oid id13NeighborPeriod_oid[] = { 1,3,6,1,4,1,40400,1,4,13 };
    const oid id14NeighborPeriod_oid[] = { 1,3,6,1,4,1,40400,1,4,14 };
    const oid id15NeighborPeriod_oid[] = { 1,3,6,1,4,1,40400,1,4,15 };
    const oid id16NeighborPeriod_oid[] = { 1,3,6,1,4,1,40400,1,4,16 };
    const oid id17NeighborPeriod_oid[] = { 1,3,6,1,4,1,40400,1,4,17 };
    const oid id18NeighborPeriod_oid[] = { 1,3,6,1,4,1,40400,1,4,18 };
    const oid id19NeighborPeriod_oid[] = { 1,3,6,1,4,1,40400,1,4,19 };
    const oid id20NeighborPeriod_oid[] = { 1,3,6,1,4,1,40400,1,4,20 };
    const oid id21NeighborPeriod_oid[] = { 1,3,6,1,4,1,40400,1,4,21 };
    const oid id22NeighborPeriod_oid[] = { 1,3,6,1,4,1,40400,1,4,22 };
    const oid id23NeighborPeriod_oid[] = { 1,3,6,1,4,1,40400,1,4,23 };
    const oid id24NeighborPeriod_oid[] = { 1,3,6,1,4,1,40400,1,4,24 };
    const oid id25NeighborPeriod_oid[] = { 1,3,6,1,4,1,40400,1,4,25};
    const oid id26NeighborPeriod_oid[] = { 1,3,6,1,4,1,40400,1,4,26 };
    const oid id27NeighborPeriod_oid[] = { 1,3,6,1,4,1,40400,1,4,27};
    const oid id28NeighborPeriod_oid[] = { 1,3,6,1,4,1,40400,1,4,28 };
    const oid id29NeighborPeriod_oid[] = { 1,3,6,1,4,1,40400,1,4,29 };
    const oid id30NeighborPeriod_oid[] = { 1,3,6,1,4,1,40400,1,4,30 };
    const oid id31NeighborPeriod_oid[] = { 1,3,6,1,4,1,40400,1,4,31 };
    const oid id32NeighborPeriod_oid[] = { 1,3,6,1,4,1,40400,1,4,32 };	

	const oid id1CombinedDataPacket_oid[] = { 1,3,6,1,4,1,40400,1,5,1 };
    const oid id2CombinedDataPacket_oid[] = { 1,3,6,1,4,1,40400,1,5,2 };
    const oid id3CombinedDataPacket_oid[] = { 1,3,6,1,4,1,40400,1,5,3 };
    const oid id4CombinedDataPacket_oid[] = { 1,3,6,1,4,1,40400,1,5,4 };
    const oid id5CombinedDataPacket_oid[] = { 1,3,6,1,4,1,40400,1,5,5 };
    const oid id6CombinedDataPacket_oid[] = { 1,3,6,1,4,1,40400,1,5,6 };
    const oid id7CombinedDataPacket_oid[] = { 1,3,6,1,4,1,40400,1,5,7 };
    const oid id8CombinedDataPacket_oid[] = { 1,3,6,1,4,1,40400,1,5,8 };
    const oid id9CombinedDataPacket_oid[] = { 1,3,6,1,4,1,40400,1,5,9 };
    const oid id10CombinedDataPacket_oid[] = { 1,3,6,1,4,1,40400,1,5,10 };
    const oid id11CombinedDataPacket_oid[] = { 1,3,6,1,4,1,40400,1,5,11 };
    const oid id12CombinedDataPacket_oid[] = { 1,3,6,1,4,1,40400,1,5,12 };
    const oid id13CombinedDataPacket_oid[] = { 1,3,6,1,4,1,40400,1,5,13 };
    const oid id14CombinedDataPacket_oid[] = { 1,3,6,1,4,1,40400,1,5,14 };
    const oid id15CombinedDataPacket_oid[] = { 1,3,6,1,4,1,40400,1,5,15 };
    const oid id16CombinedDataPacket_oid[] = { 1,3,6,1,4,1,40400,1,5,16 };
    const oid id17CombinedDataPacket_oid[] = { 1,3,6,1,4,1,40400,1,5,17 };
    const oid id18CombinedDataPacket_oid[] = { 1,3,6,1,4,1,40400,1,5,18 };
    const oid id19CombinedDataPacket_oid[] = { 1,3,6,1,4,1,40400,1,5,19 };
    const oid id20CombinedDataPacket_oid[] = { 1,3,6,1,4,1,40400,1,5,20 };
    const oid id21CombinedDataPacket_oid[] = { 1,3,6,1,4,1,40400,1,5,21 };
    const oid id22CombinedDataPacket_oid[] = { 1,3,6,1,4,1,40400,1,5,22 };
    const oid id23CombinedDataPacket_oid[] = { 1,3,6,1,4,1,40400,1,5,23 };
    const oid id24CombinedDataPacket_oid[] = { 1,3,6,1,4,1,40400,1,5,24 };
    const oid id25CombinedDataPacket_oid[] = { 1,3,6,1,4,1,40400,1,5,25};
    const oid id26CombinedDataPacket_oid[] = { 1,3,6,1,4,1,40400,1,5,26 };
    const oid id27CombinedDataPacket_oid[] = { 1,3,6,1,4,1,40400,1,5,27};
    const oid id28CombinedDataPacket_oid[] = { 1,3,6,1,4,1,40400,1,5,28 };
    const oid id29CombinedDataPacket_oid[] = { 1,3,6,1,4,1,40400,1,5,29 };
    const oid id30CombinedDataPacket_oid[] = { 1,3,6,1,4,1,40400,1,5,30 };
    const oid id31CombinedDataPacket_oid[] = { 1,3,6,1,4,1,40400,1,5,31 };
    const oid id32CombinedDataPacket_oid[] = { 1,3,6,1,4,1,40400,1,5,32 };

    const oid id1QueryAlarm_oid[] = { 1,3,6,1,4,1,40400,1,6,1 };
    const oid id2QueryAlarm_oid[] = { 1,3,6,1,4,1,40400,1,6,2 };
    const oid id3QueryAlarm_oid[] = { 1,3,6,1,4,1,40400,1,6,3 };
    const oid id4QueryAlarm_oid[] = { 1,3,6,1,4,1,40400,1,6,4 };
    const oid id5QueryAlarm_oid[] = { 1,3,6,1,4,1,40400,1,6,5 };
    const oid id6QueryAlarm_oid[] = { 1,3,6,1,4,1,40400,1,6,6 };
    const oid id7QueryAlarm_oid[] = { 1,3,6,1,4,1,40400,1,6,7 };
    const oid id8QueryAlarm_oid[] = { 1,3,6,1,4,1,40400,1,6,8 };
    const oid id9QueryAlarm_oid[] = { 1,3,6,1,4,1,40400,1,6,9 };
    const oid id10QueryAlarm_oid[] = { 1,3,6,1,4,1,40400,1,6,10 };
    const oid id11QueryAlarm_oid[] = { 1,3,6,1,4,1,40400,1,6,11 };
    const oid id12QueryAlarm_oid[] = { 1,3,6,1,4,1,40400,1,6,12 };
    const oid id13QueryAlarm_oid[] = { 1,3,6,1,4,1,40400,1,6,13 };
    const oid id14QueryAlarm_oid[] = { 1,3,6,1,4,1,40400,1,6,14 };
    const oid id15QueryAlarm_oid[] = { 1,3,6,1,4,1,40400,1,6,15 };
    const oid id16QueryAlarm_oid[] = { 1,3,6,1,4,1,40400,1,6,16 };
    const oid id17QueryAlarm_oid[] = { 1,3,6,1,4,1,40400,1,6,17 };
    const oid id18QueryAlarm_oid[] = { 1,3,6,1,4,1,40400,1,6,18 };
    const oid id19QueryAlarm_oid[] = { 1,3,6,1,4,1,40400,1,6,19 };
    const oid id20QueryAlarm_oid[] = { 1,3,6,1,4,1,40400,1,6,20 };
    const oid id21QueryAlarm_oid[] = { 1,3,6,1,4,1,40400,1,6,21 };
    const oid id22QueryAlarm_oid[] = { 1,3,6,1,4,1,40400,1,6,22 };
    const oid id23QueryAlarm_oid[] = { 1,3,6,1,4,1,40400,1,6,23 };
    const oid id24QueryAlarm_oid[] = { 1,3,6,1,4,1,40400,1,6,24 };
    const oid id25QueryAlarm_oid[] = { 1,3,6,1,4,1,40400,1,6,25};
    const oid id26QueryAlarm_oid[] = { 1,3,6,1,4,1,40400,1,6,26 };
    const oid id27QueryAlarm_oid[] = { 1,3,6,1,4,1,40400,1,6,27};
    const oid id28QueryAlarm_oid[] = { 1,3,6,1,4,1,40400,1,6,28 };
    const oid id29QueryAlarm_oid[] = { 1,3,6,1,4,1,40400,1,6,29 };
    const oid id30QueryAlarm_oid[] = { 1,3,6,1,4,1,40400,1,6,30 };
    const oid id31QueryAlarm_oid[] = { 1,3,6,1,4,1,40400,1,6,31 };
    const oid id32QueryAlarm_oid[] = { 1,3,6,1,4,1,40400,1,6,32 };

	//
	/*手咪相关*/
	const oid centerModule_oid[] = { 1,3,6,1,4,1,40400,101,1,1 };
	const oid gsmModule1_oid[] = { 1,3,6,1,4,1,40400,101,1,2 };
	const oid gsmModule2_oid[] = { 1,3,6,1,4,1,40400,101,1,3 };
	const oid radioModule_oid[] = { 1,3,6,1,4,1,40400,101,1,4 };
	const oid dspModule_oid[] = { 1,3,6,1,4,1,40400,101,1,6 };
	const oid microphoneModule1_oid[] = { 1,3,6,1,4,1,40400,101,1,7 };
	const oid microphoneModule2_oid[] = { 1,3,6,1,4,1,40400,101,1,8 };
	const oid controlModule_oid[] = { 1,3,6,1,4,1,40400,101,1,9 };
	
    /*
	const oid devIP_oid[] = { 1,3,6,1,4,1,40400,2,1,1 };
	const oid devMask_oid[] = { 1,3,6,1,4,1,40400,2,1,2 };
	const oid devGateway_oid[] = { 1,3,6,1,4,1,40400,2,1,3 };
	const oid devVoicePort_oid[] = { 1,3,6,1,4,1,40400,2,1,4};
	const oid devLogPort_oid[] = { 1,3,6,1,4,1,40400,2,1,5};
	
	const oid ccIP_oid[] = { 1,3,6,1,4,1,40400,2,2,1 };
	const oid ccVoicePort_oid[] = { 1,3,6,1,4,1,40400,2,2,2 };
	const oid ccServerPort_oid[] = { 1,3,6,1,4,1,40400,2,2,3 };

	const oid softwareVer_oid[] = { 1,3,6,1,4,1,40400,2,3,1 };
	
	const oid devID_oid[] = { 1,3,6,1,4,1,40400,2,4,1 };
	const oid groupID_oid[] = { 1,3,6,1,4,1,40400,2,4,2 };
	*/

    /* 本地管理*/
	const oid localFreq_oid[] = { 1,3,6,1,4,1,40400,2,1,1 };  //命令字同id1Freq_oid - id16Freq_oid相等
	const oid localPower_oid[] = { 1,3,6,1,4,1,40400,2,1,2 };
	const oid localOpenCloseLoop_oid[] = { 1,3,6,1,4,1,40400,2,1,3 };
	const oid lockingTime_oid[] = { 1,3,6,1,4,1,40400,2,1,4 };
	const oid halfVarianceThreshold_oid[] = { 1,3,6,1,4,1,40400,2,1,5 };
	const oid devId_oid[] = { 1,3,6,1,4,1,40400,2,1,6 };
	const oid localCc_oid[] = { 1,3,6,1,4,1,40400,2,1,7 };
	const oid version_oid[] = { 1,3,6,1,4,1,40400,2,1,8 };
	const oid fpgaVer_oid[] = { 1,3,6,1,4,1,40400,2,1,9 };
	const oid terminalCc_oid[] = { 1,3,6,1,4,1,40400,2,1,10 };
	const oid protocolMode_oid[] = { 1,3,6,1,4,1,40400,2,1,11 };
	const oid airSubNetid_oid[] = { 1,3,6,1,4,1,40400,2,1,12 };
	const oid localIp_oid[] = { 1,3,6,1,4,1,40400,2,1,13 };
	const oid localMac_oid[] = { 1,3,6,1,4,1,40400,2,1,14 };
	const oid workTimeout_oid[] = { 1,3,6,1,4,1,40400,2,1,17 };
	const oid gpsTimeout_oid[] = { 1,3,6,1,4,1,40400,2,1,18 };
	const oid stunTimeout_oid[] = { 1,3,6,1,4,1,40400,2,1,19 };
	const oid startTimeout_oid[] = { 1,3,6,1,4,1,40400,2,1,20 };
	const oid scanMode_oid[] = { 1,3,6,1,4,1,40400,2,1,21 };
	const oid alarmSwitchStatus_oid[] = { 1,3,6,1,4,1,40400,2,1,22 };
    const oid closeTranThreshold_oid[] = { 1,3,6,1,4,1,40400,2,1,23 };
    const oid tempAlarmStartThreshold_oid[] = { 1,3,6,1,4,1,40400,2,1,24 };
    const oid tempAlarmCloseThreshold_oid[] = { 1,3,6,1,4,1,40400,2,1,25 };
    const oid resumeTranThreshold_oid[] = { 1,3,6,1,4,1,40400,2,1,26 };
	/* 校准*/
    const oid emissiveVCOFreq_oid[] = { 1,3,6,1,4,1,40400,100,1,1 };
    const oid receivingVCOFreq_oid[] = { 1,3,6,1,4,1,40400,100,1,2 };
    const oid secondLocalOscillatorFreq_oid[] = { 1,3,6,1,4,1,40400,100,1,3 };
    const oid power_oid[] = { 1,3,6,1,4,1,40400,100,1,4 };
    const oid powerAmplifierSwitch_oid[] = { 1,3,6,1,4,1,40400,100,1,5 };
    const oid fpgaParam_oid[] = { 1,3,6,1,4,1,40400,100,1,6 };
	const oid debugEmissiveFreq_oid[] = { 1,3,6,1,4,1,40400,100,1,7 };
	const oid startDebug_oid[] = { 1,3,6,1,4,1,40400,100,1,8 };
	const oid debugOpenCloseLoop_oid[] = { 1,3,6,1,4,1,40400,100,1,9 };
	const oid debugPower_oid[] = { 1,3,6,1,4,1,40400,100,1,10 };
	const oid vgs_oid[] = { 1,3,6,1,4,1,40400,100,1,11 };
	const oid saveEeprom_oid[] = { 1,3,6,1,4,1,40400,100,1,12 };
	const oid set981_oid[] = { 1,3,6,1,4,1,40400,100,1,13 };
	const oid query981_oid[] = { 1,3,6,1,4,1,40400,100,1,14 };
	const oid set998_oid[] = { 1,3,6,1,4,1,40400,100,1,15 };
	const oid query998_oid[] = { 1,3,6,1,4,1,40400,100,1,16 };
	const oid devCallTimeout_oid[] = { 1,3,6,1,4,1,40400,100,1,17 };
	const oid errorRateFreq_oid[] = { 1,3,6,1,4,1,40400,100,1,18 };
	const oid saveIqData_oid[] = { 1,3,6,1,4,1,40400,100,1,19 };

	
    const oid afc_oid[] = { 1,3,6,1,4,1,40400,100,2,1 };
    const oid saveAFC_oid[] = { 1,3,6,1,4,1,40400,100,2,2 };
	
    const oid iqs_oid[] = { 1,3,6,1,4,1,40400,100,3,1 };
    const oid saveIQS_oid[] = { 1,3,6,1,4,1,40400,100,3,2 };
	const oid savePower_oid[] = { 1,3,6,1,4,1,40400,100,3,3 };
	
	const oid offset_oid[] = { 1,3,6,1,4,1,40400,100,4,1 };
    const oid saveOffset_oid[] = { 1,3,6,1,4,1,40400,100,4,2 };
	const oid calibrateOffset_oid[] = { 1,3,6,1,4,1,40400,100,4,3 };
	
	const oid phase_oid[] = { 1,3,6,1,4,1,40400,100,5,1 };
    const oid savePhase_oid[] = { 1,3,6,1,4,1,40400,100,5,2 };
	const oid calibratePhase_oid[] = { 1,3,6,1,4,1,40400,100,5,3 };

	const oid errorRate_oid[] = { 1,3,6,1,4,1,40400,100,6,1 };
	const oid startErrorRate_oid[] = { 1,3,6,1,4,1,40400,100,6,2 };

	const oid selectSignalSource_oid[] = { 1,3,6,1,4,1,40400,100,7,1 };
	const oid slotControl_oid[] = { 1,3,6,1,4,1,40400,100,7,2 };
	
    const oid localCombinedData_oid[] = { 1,3,6,1,4,1,40400,100,8,1 };
	const oid updateData_oid[] = { 1,3,6,1,4,1,40400,100,9,1 };
	const oid reboot_oid[] = { 1,3,6,1,4,1,40400,100,10,1 };
	/*  调测*/
    const oid printMark_oid[] = { 1,3,6,1,4,1,40400,200,1,1 };
	const oid connectCCFlag_oid[] = { 1,3,6,1,4,1,40400,200,1,2 };

/*
    const oid nodeINTrw_oid[] = { 1,3,6,1,4,1,40400,200,1 };
    const oid nodeUINTrw_oid[] = { 1,3,6,1,4,1,40400,200,2 };
    const oid nodeSTRrw_oid[] = { 1,3,6,1,4,1,40400,200,3 };
    const oid nodeIPrw_oid[] = { 1,3,6,1,4,1,40400,200,4 };
    const oid nodeINTr_oid[] = { 1,3,6,1,4,1,40400,200,5 };
    const oid nodeUINTr_oid[] = { 1,3,6,1,4,1,40400,200,6 };
    const oid nodeSTRr_oid[] = { 1,3,6,1,4,1,40400,200,7 };
    const oid nodeIPr_oid[] = { 1,3,6,1,4,1,40400,200,8 };
    const oid nodeOPAQUErw_oid[] = { 1,3,6,1,4,1,40400,200,9 };
    const oid nodeOPAQUEr_oid[] = { 1,3,6,1,4,1,40400,200,10 }; 
*/

  DEBUGMSGTL(("mgr_snmp_agent", "Initializing\n"));

     netsnmp_register_scalar(
        netsnmp_create_handler_registration("id1QueryAlarm", handle_id1QueryAlarm,
                               id1QueryAlarm_oid, OID_LENGTH(id1QueryAlarm_oid),
                               HANDLER_CAN_RWRITE
        ));
     netsnmp_register_scalar(
        netsnmp_create_handler_registration("id2QueryAlarm", handle_id2QueryAlarm,
                               id2QueryAlarm_oid, OID_LENGTH(id2QueryAlarm_oid),
                               HANDLER_CAN_RWRITE
        ));
     netsnmp_register_scalar(
        netsnmp_create_handler_registration("id3QueryAlarm", handle_id3QueryAlarm,
                               id3QueryAlarm_oid, OID_LENGTH(id3QueryAlarm_oid),
                               HANDLER_CAN_RWRITE
        ));
     netsnmp_register_scalar(
        netsnmp_create_handler_registration("id4QueryAlarm", handle_id4QueryAlarm,
                               id4QueryAlarm_oid, OID_LENGTH(id4QueryAlarm_oid),
                               HANDLER_CAN_RWRITE
        ));
     netsnmp_register_scalar(
        netsnmp_create_handler_registration("id5QueryAlarm", handle_id5QueryAlarm,
                               id5QueryAlarm_oid, OID_LENGTH(id5QueryAlarm_oid),
                               HANDLER_CAN_RWRITE
        ));
      netsnmp_register_scalar(
        netsnmp_create_handler_registration("id6QueryAlarm", handle_id6QueryAlarm,
                               id6QueryAlarm_oid, OID_LENGTH(id6QueryAlarm_oid),
                               HANDLER_CAN_RWRITE
        ));
     netsnmp_register_scalar(
        netsnmp_create_handler_registration("id7QueryAlarm", handle_id7QueryAlarm,
                               id7QueryAlarm_oid, OID_LENGTH(id7QueryAlarm_oid),
                               HANDLER_CAN_RWRITE
        ));
     netsnmp_register_scalar(
        netsnmp_create_handler_registration("id8QueryAlarm", handle_id8QueryAlarm,
                               id8QueryAlarm_oid, OID_LENGTH(id8QueryAlarm_oid),
                               HANDLER_CAN_RWRITE
        ));
     netsnmp_register_scalar(
        netsnmp_create_handler_registration("id9QueryAlarm", handle_id9QueryAlarm,
                               id9QueryAlarm_oid, OID_LENGTH(id9QueryAlarm_oid),
                               HANDLER_CAN_RWRITE
        ));
     netsnmp_register_scalar(
        netsnmp_create_handler_registration("id10QueryAlarm", handle_id10QueryAlarm,
                               id10QueryAlarm_oid, OID_LENGTH(id10QueryAlarm_oid),
                               HANDLER_CAN_RWRITE
        ));


      netsnmp_register_scalar(
        netsnmp_create_handler_registration("id11QueryAlarm", handle_id11QueryAlarm,
                               id11QueryAlarm_oid, OID_LENGTH(id11QueryAlarm_oid),
                               HANDLER_CAN_RWRITE
        ));
     netsnmp_register_scalar(
        netsnmp_create_handler_registration("id12QueryAlarm", handle_id12QueryAlarm,
                               id12QueryAlarm_oid, OID_LENGTH(id12QueryAlarm_oid),
                               HANDLER_CAN_RWRITE
        ));
     netsnmp_register_scalar(
        netsnmp_create_handler_registration("id13QueryAlarm", handle_id13QueryAlarm,
                               id13QueryAlarm_oid, OID_LENGTH(id13QueryAlarm_oid),
                               HANDLER_CAN_RWRITE
        ));
     netsnmp_register_scalar(
        netsnmp_create_handler_registration("id14QueryAlarm", handle_id14QueryAlarm,
                               id14QueryAlarm_oid, OID_LENGTH(id14QueryAlarm_oid),
                               HANDLER_CAN_RWRITE
        ));
     netsnmp_register_scalar(
        netsnmp_create_handler_registration("id15QueryAlarm", handle_id15QueryAlarm,
                               id15QueryAlarm_oid, OID_LENGTH(id15QueryAlarm_oid),
                               HANDLER_CAN_RWRITE
        ));
      netsnmp_register_scalar(
        netsnmp_create_handler_registration("id16QueryAlarm", handle_id16QueryAlarm,
                               id6QueryAlarm_oid, OID_LENGTH(id6QueryAlarm_oid),
                               HANDLER_CAN_RWRITE
        ));
     netsnmp_register_scalar(
        netsnmp_create_handler_registration("id17QueryAlarm", handle_id17QueryAlarm,
                               id17QueryAlarm_oid, OID_LENGTH(id17QueryAlarm_oid),
                               HANDLER_CAN_RWRITE
        ));
     netsnmp_register_scalar(
        netsnmp_create_handler_registration("id18QueryAlarm", handle_id18QueryAlarm,
                               id18QueryAlarm_oid, OID_LENGTH(id18QueryAlarm_oid),
                               HANDLER_CAN_RWRITE
        ));
     netsnmp_register_scalar(
        netsnmp_create_handler_registration("id19QueryAlarm", handle_id19QueryAlarm,
                               id19QueryAlarm_oid, OID_LENGTH(id19QueryAlarm_oid),
                               HANDLER_CAN_RWRITE
        ));
     netsnmp_register_scalar(
        netsnmp_create_handler_registration("id20QueryAlarm", handle_id20QueryAlarm,
                               id20QueryAlarm_oid, OID_LENGTH(id20QueryAlarm_oid),
                               HANDLER_CAN_RWRITE
        ));

      netsnmp_register_scalar(
        netsnmp_create_handler_registration("id21QueryAlarm", handle_id21QueryAlarm,
                               id21QueryAlarm_oid, OID_LENGTH(id21QueryAlarm_oid),
                               HANDLER_CAN_RWRITE
        ));
     netsnmp_register_scalar(
        netsnmp_create_handler_registration("id22QueryAlarm", handle_id22QueryAlarm,
                               id22QueryAlarm_oid, OID_LENGTH(id22QueryAlarm_oid),
                               HANDLER_CAN_RWRITE
        ));
     netsnmp_register_scalar(
        netsnmp_create_handler_registration("id23QueryAlarm", handle_id23QueryAlarm,
                               id23QueryAlarm_oid, OID_LENGTH(id23QueryAlarm_oid),
                               HANDLER_CAN_RWRITE
        ));
     netsnmp_register_scalar(
        netsnmp_create_handler_registration("id24QueryAlarm", handle_id24QueryAlarm,
                               id24QueryAlarm_oid, OID_LENGTH(id24QueryAlarm_oid),
                               HANDLER_CAN_RWRITE
        ));
     netsnmp_register_scalar(
        netsnmp_create_handler_registration("id25QueryAlarm", handle_id25QueryAlarm,
                               id25QueryAlarm_oid, OID_LENGTH(id25QueryAlarm_oid),
                               HANDLER_CAN_RWRITE
        ));
      netsnmp_register_scalar(
        netsnmp_create_handler_registration("id26QueryAlarm", handle_id26QueryAlarm,
                               id26QueryAlarm_oid, OID_LENGTH(id26QueryAlarm_oid),
                               HANDLER_CAN_RWRITE
        ));
     netsnmp_register_scalar(
        netsnmp_create_handler_registration("id27QueryAlarm", handle_id27QueryAlarm,
                               id27QueryAlarm_oid, OID_LENGTH(id27QueryAlarm_oid),
                               HANDLER_CAN_RWRITE
        ));
     netsnmp_register_scalar(
        netsnmp_create_handler_registration("id28QueryAlarm", handle_id28QueryAlarm,
                               id28QueryAlarm_oid, OID_LENGTH(id28QueryAlarm_oid),
                               HANDLER_CAN_RWRITE
        ));
     netsnmp_register_scalar(
        netsnmp_create_handler_registration("id29QueryAlarm", handle_id29QueryAlarm,
                               id29QueryAlarm_oid, OID_LENGTH(id29QueryAlarm_oid),
                               HANDLER_CAN_RWRITE
        ));
     netsnmp_register_scalar(
        netsnmp_create_handler_registration("id30QueryAlarm", handle_id30QueryAlarm,
                               id30QueryAlarm_oid, OID_LENGTH(id30QueryAlarm_oid),
                               HANDLER_CAN_RWRITE
        ));
      netsnmp_register_scalar(
        netsnmp_create_handler_registration("id31QueryAlarm", handle_id31QueryAlarm,
                               id31QueryAlarm_oid, OID_LENGTH(id31QueryAlarm_oid),
                               HANDLER_CAN_RWRITE
        ));
       netsnmp_register_scalar(
        netsnmp_create_handler_registration("id32QueryAlarm", handle_id32QueryAlarm,
                               id32QueryAlarm_oid, OID_LENGTH(id32QueryAlarm_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id1Freq", handle_id1Freq,
                               id1Freq_oid, OID_LENGTH(id1Freq_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id2Freq", handle_id2Freq,
                               id2Freq_oid, OID_LENGTH(id2Freq_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id3Freq", handle_id3Freq,
                               id3Freq_oid, OID_LENGTH(id3Freq_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id4Freq", handle_id4Freq,
                               id4Freq_oid, OID_LENGTH(id4Freq_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id5Freq", handle_id5Freq,
                               id5Freq_oid, OID_LENGTH(id5Freq_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id6Freq", handle_id6Freq,
                               id6Freq_oid, OID_LENGTH(id6Freq_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id7Freq", handle_id7Freq,
                               id7Freq_oid, OID_LENGTH(id7Freq_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id8Freq", handle_id8Freq,
                               id8Freq_oid, OID_LENGTH(id8Freq_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id9Freq", handle_id9Freq,
                               id9Freq_oid, OID_LENGTH(id9Freq_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id10Freq", handle_id10Freq,
                               id10Freq_oid, OID_LENGTH(id10Freq_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id11Freq", handle_id11Freq,
                               id11Freq_oid, OID_LENGTH(id11Freq_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id12Freq", handle_id12Freq,
                               id12Freq_oid, OID_LENGTH(id12Freq_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id13Freq", handle_id13Freq,
                               id13Freq_oid, OID_LENGTH(id13Freq_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id14Freq", handle_id14Freq,
                               id14Freq_oid, OID_LENGTH(id14Freq_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id15Freq", handle_id15Freq,
                               id15Freq_oid, OID_LENGTH(id15Freq_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id16Freq", handle_id16Freq,
                               id16Freq_oid, OID_LENGTH(id16Freq_oid),
                               HANDLER_CAN_RWRITE
        ));
	netsnmp_register_scalar(
        netsnmp_create_handler_registration("id17Freq", handle_id17Freq,
                               id17Freq_oid, OID_LENGTH(id17Freq_oid),
                               HANDLER_CAN_RWRITE
        ));
	netsnmp_register_scalar(
        netsnmp_create_handler_registration("id18Freq", handle_id18Freq,
                               id18Freq_oid, OID_LENGTH(id18Freq_oid),
                               HANDLER_CAN_RWRITE
        ));
	netsnmp_register_scalar(
        netsnmp_create_handler_registration("id19Freq", handle_id19Freq,
                               id19Freq_oid, OID_LENGTH(id19Freq_oid),
                               HANDLER_CAN_RWRITE
        ));
	netsnmp_register_scalar(
        netsnmp_create_handler_registration("id20Freq", handle_id20Freq,
                               id20Freq_oid, OID_LENGTH(id20Freq_oid),
                               HANDLER_CAN_RWRITE
        ));
	netsnmp_register_scalar(
        netsnmp_create_handler_registration("id21Freq", handle_id21Freq,
                               id21Freq_oid, OID_LENGTH(id21Freq_oid),
                               HANDLER_CAN_RWRITE
        ));
	netsnmp_register_scalar(
        netsnmp_create_handler_registration("id22Freq", handle_id22Freq,
                               id22Freq_oid, OID_LENGTH(id22Freq_oid),
                               HANDLER_CAN_RWRITE
        ));
	netsnmp_register_scalar(
        netsnmp_create_handler_registration("id23Freq", handle_id23Freq,
                               id23Freq_oid, OID_LENGTH(id23Freq_oid),
                               HANDLER_CAN_RWRITE
        ));
	netsnmp_register_scalar(
        netsnmp_create_handler_registration("id24Freq", handle_id24Freq,
                               id24Freq_oid, OID_LENGTH(id24Freq_oid),
                               HANDLER_CAN_RWRITE
        ));
	netsnmp_register_scalar(
        netsnmp_create_handler_registration("id25Freq", handle_id25Freq,
                               id25Freq_oid, OID_LENGTH(id25Freq_oid),
                               HANDLER_CAN_RWRITE
        ));
	netsnmp_register_scalar(
        netsnmp_create_handler_registration("id26Freq", handle_id26Freq,
                               id26Freq_oid, OID_LENGTH(id26Freq_oid),
                               HANDLER_CAN_RWRITE
        ));

	netsnmp_register_scalar(
        netsnmp_create_handler_registration("id27Freq", handle_id27Freq,
                               id27Freq_oid, OID_LENGTH(id27Freq_oid),
                               HANDLER_CAN_RWRITE
        ));
	netsnmp_register_scalar(
        netsnmp_create_handler_registration("id28Freq", handle_id28Freq,
                               id28Freq_oid, OID_LENGTH(id28Freq_oid),
                               HANDLER_CAN_RWRITE
        ));netsnmp_register_scalar(
        netsnmp_create_handler_registration("id29Freq", handle_id29Freq,
                               id29Freq_oid, OID_LENGTH(id29Freq_oid),
                               HANDLER_CAN_RWRITE
        ));
	netsnmp_register_scalar(
        netsnmp_create_handler_registration("id30Freq", handle_id30Freq,
                               id30Freq_oid, OID_LENGTH(id30Freq_oid),
                               HANDLER_CAN_RWRITE
        ));
	netsnmp_register_scalar(
        netsnmp_create_handler_registration("id31Freq", handle_id31Freq,
                               id31Freq_oid, OID_LENGTH(id31Freq_oid),
                               HANDLER_CAN_RWRITE
        ));
		netsnmp_register_scalar(
        netsnmp_create_handler_registration("id32Freq", handle_id32Freq,
                               id32Freq_oid, OID_LENGTH(id32Freq_oid),
                               HANDLER_CAN_RWRITE
        ));
        
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id1Power", handle_id1Power,
                               id1Power_oid, OID_LENGTH(id1Power_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id2Power", handle_id2Power,
                               id2Power_oid, OID_LENGTH(id2Power_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id3Power", handle_id3Power,
                               id3Power_oid, OID_LENGTH(id3Power_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id4Power", handle_id4Power,
                               id4Power_oid, OID_LENGTH(id4Power_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id5Power", handle_id5Power,
                               id5Power_oid, OID_LENGTH(id5Power_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id6Power", handle_id6Power,
                               id6Power_oid, OID_LENGTH(id6Power_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id7Power", handle_id7Power,
                               id7Power_oid, OID_LENGTH(id7Power_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id8Power", handle_id8Power,
                               id8Power_oid, OID_LENGTH(id8Power_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id9Power", handle_id9Power,
                               id9Power_oid, OID_LENGTH(id9Power_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id10Power", handle_id10Power,
                               id10Power_oid, OID_LENGTH(id10Power_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id11Power", handle_id11Power,
                               id11Power_oid, OID_LENGTH(id11Power_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id12Power", handle_id12Power,
                               id12Power_oid, OID_LENGTH(id12Power_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id13Power", handle_id13Power,
                               id13Power_oid, OID_LENGTH(id13Power_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id14Power", handle_id14Power,
                               id14Power_oid, OID_LENGTH(id14Power_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id15Power", handle_id15Power,
                               id15Power_oid, OID_LENGTH(id15Power_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id16Power", handle_id16Power,
                               id16Power_oid, OID_LENGTH(id16Power_oid),
                               HANDLER_CAN_RWRITE
        ));

	 netsnmp_register_scalar(
        netsnmp_create_handler_registration("id17Power", handle_id17Power,
                               id17Power_oid, OID_LENGTH(id17Power_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id18Power", handle_id18Power,
                               id18Power_oid, OID_LENGTH(id18Power_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id19Power", handle_id19Power,
                               id19Power_oid, OID_LENGTH(id19Power_oid),
                               HANDLER_CAN_RWRITE
        ));
  
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id20Power", handle_id20Power,
                               id20Power_oid, OID_LENGTH(id20Power_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id21Power", handle_id21Power,
                               id21Power_oid, OID_LENGTH(id21Power_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id22Power", handle_id22Power,
                               id22Power_oid, OID_LENGTH(id22Power_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id23Power", handle_id23Power,
                               id23Power_oid, OID_LENGTH(id23Power_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id24Power", handle_id24Power,
                               id24Power_oid, OID_LENGTH(id24Power_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id25Power", handle_id25Power,
                               id25Power_oid, OID_LENGTH(id25Power_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id26Power", handle_id26Power,
                               id26Power_oid, OID_LENGTH(id26Power_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id27Power", handle_id27Power,
                               id27Power_oid, OID_LENGTH(id27Power_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id28Power", handle_id28Power,
                               id28Power_oid, OID_LENGTH(id28Power_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id29Power", handle_id29Power,
                               id29Power_oid, OID_LENGTH(id29Power_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id30Power", handle_id30Power,
                               id30Power_oid, OID_LENGTH(id30Power_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("id31Power", handle_id31Power,
                               id31Power_oid, OID_LENGTH(id31Power_oid),
                               HANDLER_CAN_RWRITE
        ));
	  netsnmp_register_scalar(
        netsnmp_create_handler_registration("id32Power", handle_id32Power,
                               id32Power_oid, OID_LENGTH(id32Power_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("localFreq", handle_localFreq,
                               localFreq_oid, OID_LENGTH(localFreq_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("localPower", handle_localPower,
                               localPower_oid, OID_LENGTH(localPower_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("localOpenCloseLoop", handle_localOpenCloseLoop,
                               localOpenCloseLoop_oid, OID_LENGTH(localOpenCloseLoop_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("lockingTime", handle_lockingTime,
                               lockingTime_oid, OID_LENGTH(lockingTime_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("halfVarianceThreshold", handle_halfVarianceThreshold,
                               halfVarianceThreshold_oid, OID_LENGTH(halfVarianceThreshold_oid),
                               HANDLER_CAN_RWRITE
        ));
	netsnmp_register_scalar(
        netsnmp_create_handler_registration("devId", handle_devId,
                               devId_oid, OID_LENGTH(devId_oid),
                               HANDLER_CAN_RWRITE
        ));
	netsnmp_register_scalar(
        netsnmp_create_handler_registration("localCc", handle_localCc,
                               localCc_oid, OID_LENGTH(localCc_oid),
                               HANDLER_CAN_RWRITE
        ));
	netsnmp_register_scalar(
        netsnmp_create_handler_registration("version", handle_version,
                               version_oid, OID_LENGTH(version_oid),
                               HANDLER_CAN_RWRITE
        ));
	netsnmp_register_scalar(
        netsnmp_create_handler_registration("fpgaVer", handle_fpgaVer,
                               fpgaVer_oid, OID_LENGTH(fpgaVer_oid),
                               HANDLER_CAN_RWRITE
        ));
	netsnmp_register_scalar(
        netsnmp_create_handler_registration("terminalCc", handle_terminalCc,
                               terminalCc_oid, OID_LENGTH(terminalCc_oid),
                               HANDLER_CAN_RWRITE
        ));

	netsnmp_register_scalar(
        netsnmp_create_handler_registration("protocolMode", handle_protocolMode,
                               protocolMode_oid, OID_LENGTH(protocolMode_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("airSubNetid", handle_airSubNetid,
                               airSubNetid_oid, OID_LENGTH(airSubNetid_oid),
                               HANDLER_CAN_RWRITE
        ));
	 netsnmp_register_scalar(
        netsnmp_create_handler_registration("localIp", handle_localIp,
                               localIp_oid, OID_LENGTH(localIp_oid),
                               HANDLER_CAN_RWRITE
        ));
	 netsnmp_register_scalar(
        netsnmp_create_handler_registration("localMac", handle_localMac,
                               localMac_oid, OID_LENGTH(localMac_oid),
                               HANDLER_CAN_RWRITE
        ));
   netsnmp_register_scalar(
        netsnmp_create_handler_registration("workTimeout", handle_workTimeout,
                               workTimeout_oid, OID_LENGTH(workTimeout_oid),
                               HANDLER_CAN_RWRITE
        ));
	netsnmp_register_scalar(
        netsnmp_create_handler_registration("gpsTimeout", handle_gpsTimeout,
                               gpsTimeout_oid, OID_LENGTH(gpsTimeout_oid),
                               HANDLER_CAN_RWRITE
        ));
	netsnmp_register_scalar(
        netsnmp_create_handler_registration("stunTimeout", handle_stunTimeout,
                               stunTimeout_oid, OID_LENGTH(stunTimeout_oid),
                               HANDLER_CAN_RWRITE
        ));

	netsnmp_register_scalar(
        netsnmp_create_handler_registration("startTimeout", handle_startTimeout,
                               startTimeout_oid, OID_LENGTH(startTimeout_oid),
                               HANDLER_CAN_RWRITE
        ));

	netsnmp_register_scalar(
			netsnmp_create_handler_registration("scanMode", handle_scanMode,
								   scanMode_oid, OID_LENGTH(scanMode_oid),
								   HANDLER_CAN_RWRITE
			));

	netsnmp_register_scalar(
			netsnmp_create_handler_registration("alarmSwitchStatus", handle_alarmSwitchStatus,
								   alarmSwitchStatus_oid, OID_LENGTH(alarmSwitchStatus_oid),
								   HANDLER_CAN_RWRITE
			));
    netsnmp_register_scalar(
			netsnmp_create_handler_registration("closeTranThreshold", handle_closeTranThreshold,
								   closeTranThreshold_oid, OID_LENGTH(closeTranThreshold_oid),
								   HANDLER_CAN_RWRITE
			));
    netsnmp_register_scalar(
			netsnmp_create_handler_registration("resumeTranThreshold", handle_resumeTranThreshold,
								   resumeTranThreshold_oid, OID_LENGTH(resumeTranThreshold_oid),
								   HANDLER_CAN_RWRITE
			));
    netsnmp_register_scalar(
			netsnmp_create_handler_registration("tempAlarmStartThreshold", handle_tempAlarmStartThreshold,
								   tempAlarmStartThreshold_oid, OID_LENGTH(tempAlarmStartThreshold_oid),
								   HANDLER_CAN_RWRITE
			));
    netsnmp_register_scalar(
			netsnmp_create_handler_registration("tempAlarmCloseThreshold", handle_tempAlarmCloseThreshold,
								   tempAlarmCloseThreshold_oid, OID_LENGTH(tempAlarmCloseThreshold_oid),
								   HANDLER_CAN_RWRITE
			));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("emissiveVCOFreq", handle_emissiveVCOFreq,
                               emissiveVCOFreq_oid, OID_LENGTH(emissiveVCOFreq_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("receivingVCOFreq", handle_receivingVCOFreq,
                               receivingVCOFreq_oid, OID_LENGTH(receivingVCOFreq_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("secondLocalOscillatorFreq", handle_secondLocalOscillatorFreq,
                               secondLocalOscillatorFreq_oid, OID_LENGTH(secondLocalOscillatorFreq_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("power", handle_power,
                               power_oid, OID_LENGTH(power_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("powerAmplifierSwitch", handle_powerAmplifierSwitch,
                               powerAmplifierSwitch_oid, OID_LENGTH(powerAmplifierSwitch_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("fpgaParam", handle_fpgaParam,
                               fpgaParam_oid, OID_LENGTH(fpgaParam_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("debugEmissiveFreq", handle_debugEmissiveFreq,
                               debugEmissiveFreq_oid, OID_LENGTH(debugEmissiveFreq_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("afc", handle_afc,
                               afc_oid, OID_LENGTH(afc_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("saveAFC", handle_saveAFC,
                               saveAFC_oid, OID_LENGTH(saveAFC_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("iqs", handle_iqs,
                               iqs_oid, OID_LENGTH(iqs_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("saveIQS", handle_saveIQS,
                               saveIQS_oid, OID_LENGTH(saveIQS_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("savePower", handle_savePower,
                               savePower_oid, OID_LENGTH(savePower_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("offset", handle_offset,
                               offset_oid, OID_LENGTH(offset_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("saveOffset", handle_saveOffset,
                               saveOffset_oid, OID_LENGTH(saveOffset_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("calibrateOffset", handle_calibrateOffset,
                               calibrateOffset_oid, OID_LENGTH(calibrateOffset_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("phase", handle_phase,
                               phase_oid, OID_LENGTH(phase_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("savePhase", handle_savePhase,
                               savePhase_oid, OID_LENGTH(savePhase_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("calibratePhase", handle_calibratePhase,
                               calibratePhase_oid, OID_LENGTH(calibratePhase_oid),
                               HANDLER_CAN_RWRITE
        ));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("errorRate", handle_errorRate,
							   errorRate_oid, OID_LENGTH(errorRate_oid),
							   HANDLER_CAN_RONLY
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("printMark", handle_printMark,
							   printMark_oid, OID_LENGTH(printMark_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("connectCCFlag", handle_connectCCFlag,
							   connectCCFlag_oid, OID_LENGTH(connectCCFlag_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("startDebug", handle_startDebug,
							   startDebug_oid, OID_LENGTH(startDebug_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("startErrorRate", handle_startErrorRate,
							   startErrorRate_oid, OID_LENGTH(startErrorRate_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("selectSignalSource", handle_selectSignalSource,
							   selectSignalSource_oid, OID_LENGTH(selectSignalSource_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("debugOpenCloseLoop", handle_debugOpenCloseLoop,
							   debugOpenCloseLoop_oid, OID_LENGTH(debugOpenCloseLoop_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("debugPower", handle_debugPower,
							   debugPower_oid, OID_LENGTH(debugPower_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("slotControl", handle_slotControl,
							   slotControl_oid, OID_LENGTH(slotControl_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("vgs", handle_vgs,
							   vgs_oid, OID_LENGTH(vgs_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
			netsnmp_create_handler_registration("saveEeprom", handle_saveEeprom,
								   saveEeprom_oid, OID_LENGTH(saveEeprom_oid),
								   HANDLER_CAN_RWRITE
			));

	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id1StartNeighbor", handle_id1StartNeighbor,
							   id1StartNeighbor_oid, OID_LENGTH(id1StartNeighbor_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id2StartNeighbor", handle_id2StartNeighbor,
							   id2StartNeighbor_oid, OID_LENGTH(id2StartNeighbor_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id3StartNeighbor", handle_id3StartNeighbor,
							   id3StartNeighbor_oid, OID_LENGTH(id3StartNeighbor_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id4StartNeighbor", handle_id4StartNeighbor,
							   id4StartNeighbor_oid, OID_LENGTH(id4StartNeighbor_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id5StartNeighbor", handle_id5StartNeighbor,
							   id5StartNeighbor_oid, OID_LENGTH(id5StartNeighbor_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id6StartNeighbor", handle_id6StartNeighbor,
							   id6StartNeighbor_oid, OID_LENGTH(id6StartNeighbor_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id7StartNeighbor", handle_id7StartNeighbor,
							   id7StartNeighbor_oid, OID_LENGTH(id7StartNeighbor_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id8StartNeighbor", handle_id8StartNeighbor,
							   id8StartNeighbor_oid, OID_LENGTH(id8StartNeighbor_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id9StartNeighbor", handle_id9StartNeighbor,
							   id9StartNeighbor_oid, OID_LENGTH(id9StartNeighbor_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id10StartNeighbor", handle_id10StartNeighbor,
							   id10StartNeighbor_oid, OID_LENGTH(id10StartNeighbor_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id11StartNeighbor", handle_id11StartNeighbor,
							   id11StartNeighbor_oid, OID_LENGTH(id11StartNeighbor_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id12StartNeighbor", handle_id12StartNeighbor,
							   id12StartNeighbor_oid, OID_LENGTH(id12StartNeighbor_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id13StartNeighbor", handle_id13StartNeighbor,
							   id13StartNeighbor_oid, OID_LENGTH(id13StartNeighbor_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id14StartNeighbor", handle_id14StartNeighbor,
							   id14StartNeighbor_oid, OID_LENGTH(id14StartNeighbor_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id15StartNeighbor", handle_id15StartNeighbor,
							   id15StartNeighbor_oid, OID_LENGTH(id15StartNeighbor_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id16StartNeighbor", handle_id16StartNeighbor,
							   id16StartNeighbor_oid, OID_LENGTH(id16StartNeighbor_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id17StartNeighbor", handle_id17StartNeighbor,
							   id17StartNeighbor_oid, OID_LENGTH(id17StartNeighbor_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id18StartNeighbor", handle_id18StartNeighbor,
							   id18StartNeighbor_oid, OID_LENGTH(id18StartNeighbor_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id19StartNeighbor", handle_id19StartNeighbor,
							   id19StartNeighbor_oid, OID_LENGTH(id19StartNeighbor_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id20StartNeighbor", handle_id20StartNeighbor,
							   id20StartNeighbor_oid, OID_LENGTH(id20StartNeighbor_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id21StartNeighbor", handle_id21StartNeighbor,
							   id21StartNeighbor_oid, OID_LENGTH(id21StartNeighbor_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id22StartNeighbor", handle_id22StartNeighbor,
							   id22StartNeighbor_oid, OID_LENGTH(id22StartNeighbor_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id23StartNeighbor", handle_id23StartNeighbor,
							   id23StartNeighbor_oid, OID_LENGTH(id23StartNeighbor_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id24StartNeighbor", handle_id24StartNeighbor,
							   id24StartNeighbor_oid, OID_LENGTH(id24StartNeighbor_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id25StartNeighbor", handle_id25StartNeighbor,
							   id25StartNeighbor_oid, OID_LENGTH(id25StartNeighbor_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id26StartNeighbor", handle_id26StartNeighbor,
							   id26StartNeighbor_oid, OID_LENGTH(id26StartNeighbor_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id27StartNeighbor", handle_id27StartNeighbor,
							   id27StartNeighbor_oid, OID_LENGTH(id27StartNeighbor_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id28StartNeighbor", handle_id28StartNeighbor,
							   id28StartNeighbor_oid, OID_LENGTH(id28StartNeighbor_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id29StartNeighbor", handle_id29StartNeighbor,
							   id29StartNeighbor_oid, OID_LENGTH(id29StartNeighbor_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id30StartNeighbor", handle_id30StartNeighbor,
							   id30StartNeighbor_oid, OID_LENGTH(id30StartNeighbor_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id31StartNeighbor", handle_id31StartNeighbor,
							   id31StartNeighbor_oid, OID_LENGTH(id31StartNeighbor_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id32StartNeighbor", handle_id32StartNeighbor,
							   id32StartNeighbor_oid, OID_LENGTH(id32StartNeighbor_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id1NeighborPeriod", handle_id1NeighborPeriod,
							   id1NeighborPeriod_oid, OID_LENGTH(id1NeighborPeriod_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id2NeighborPeriod", handle_id2NeighborPeriod,
							   id2NeighborPeriod_oid, OID_LENGTH(id2NeighborPeriod_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id3NeighborPeriod", handle_id3NeighborPeriod,
							   id3NeighborPeriod_oid, OID_LENGTH(id3NeighborPeriod_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id4NeighborPeriod", handle_id4NeighborPeriod,
							   id4NeighborPeriod_oid, OID_LENGTH(id4NeighborPeriod_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id5NeighborPeriod", handle_id5NeighborPeriod,
							   id5NeighborPeriod_oid, OID_LENGTH(id5NeighborPeriod_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id6NeighborPeriod", handle_id6NeighborPeriod,
							   id6NeighborPeriod_oid, OID_LENGTH(id6NeighborPeriod_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id7NeighborPeriod", handle_id7NeighborPeriod,
							   id7NeighborPeriod_oid, OID_LENGTH(id7NeighborPeriod_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id8NeighborPeriod", handle_id8NeighborPeriod,
							   id8NeighborPeriod_oid, OID_LENGTH(id8NeighborPeriod_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id9NeighborPeriod", handle_id9NeighborPeriod,
							   id9NeighborPeriod_oid, OID_LENGTH(id9NeighborPeriod_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id10NeighborPeriod", handle_id10NeighborPeriod,
							   id10NeighborPeriod_oid, OID_LENGTH(id10NeighborPeriod_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id11NeighborPeriod", handle_id11NeighborPeriod,
							   id11NeighborPeriod_oid, OID_LENGTH(id11NeighborPeriod_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id12NeighborPeriod", handle_id12NeighborPeriod,
							   id12NeighborPeriod_oid, OID_LENGTH(id12NeighborPeriod_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id13NeighborPeriod", handle_id13NeighborPeriod,
							   id13NeighborPeriod_oid, OID_LENGTH(id13NeighborPeriod_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id14NeighborPeriod", handle_id14NeighborPeriod,
							   id14NeighborPeriod_oid, OID_LENGTH(id14NeighborPeriod_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id15NeighborPeriod", handle_id15NeighborPeriod,
							   id15NeighborPeriod_oid, OID_LENGTH(id15NeighborPeriod_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id16NeighborPeriod", handle_id16NeighborPeriod,
							   id16NeighborPeriod_oid, OID_LENGTH(id16NeighborPeriod_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id17NeighborPeriod", handle_id17NeighborPeriod,
							   id17NeighborPeriod_oid, OID_LENGTH(id17NeighborPeriod_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id18NeighborPeriod", handle_id18NeighborPeriod,
							   id18NeighborPeriod_oid, OID_LENGTH(id18NeighborPeriod_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id19NeighborPeriod", handle_id19NeighborPeriod,
							   id19NeighborPeriod_oid, OID_LENGTH(id19NeighborPeriod_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id20NeighborPeriod", handle_id20NeighborPeriod,
							   id20NeighborPeriod_oid, OID_LENGTH(id20NeighborPeriod_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id21NeighborPeriod", handle_id21NeighborPeriod,
							   id21NeighborPeriod_oid, OID_LENGTH(id21NeighborPeriod_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id22NeighborPeriod", handle_id22NeighborPeriod,
							   id22NeighborPeriod_oid, OID_LENGTH(id22NeighborPeriod_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id23NeighborPeriod", handle_id23NeighborPeriod,
							   id23NeighborPeriod_oid, OID_LENGTH(id23NeighborPeriod_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id24NeighborPeriod", handle_id24NeighborPeriod,
							   id24NeighborPeriod_oid, OID_LENGTH(id24NeighborPeriod_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id25NeighborPeriod", handle_id25NeighborPeriod,
							   id25NeighborPeriod_oid, OID_LENGTH(id25NeighborPeriod_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id26NeighborPeriod", handle_id26NeighborPeriod,
							   id26NeighborPeriod_oid, OID_LENGTH(id26NeighborPeriod_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id27NeighborPeriod", handle_id27NeighborPeriod,
							   id27NeighborPeriod_oid, OID_LENGTH(id27NeighborPeriod_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id28NeighborPeriod", handle_id28NeighborPeriod,
							   id28NeighborPeriod_oid, OID_LENGTH(id28NeighborPeriod_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id29NeighborPeriod", handle_id29NeighborPeriod,
							   id29NeighborPeriod_oid, OID_LENGTH(id29NeighborPeriod_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id30NeighborPeriod", handle_id30NeighborPeriod,
							   id30NeighborPeriod_oid, OID_LENGTH(id30NeighborPeriod_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id31NeighborPeriod", handle_id31NeighborPeriod,
							   id31NeighborPeriod_oid, OID_LENGTH(id31NeighborPeriod_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id32NeighborPeriod", handle_id32NeighborPeriod,
							   id32NeighborPeriod_oid, OID_LENGTH(id32NeighborPeriod_oid),
							   HANDLER_CAN_RWRITE
		));



	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id1CombinedDataPacket", handle_id1CombinedDataPacket,
							   id1CombinedDataPacket_oid, OID_LENGTH(id1CombinedDataPacket_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id2CombinedDataPacket", handle_id2CombinedDataPacket,
							   id2CombinedDataPacket_oid, OID_LENGTH(id2CombinedDataPacket_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id3CombinedDataPacket", handle_id3CombinedDataPacket,
							   id3CombinedDataPacket_oid, OID_LENGTH(id3CombinedDataPacket_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id4CombinedDataPacket", handle_id4CombinedDataPacket,
							   id4CombinedDataPacket_oid, OID_LENGTH(id4CombinedDataPacket_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id5CombinedDataPacket", handle_id5CombinedDataPacket,
							   id5CombinedDataPacket_oid, OID_LENGTH(id5CombinedDataPacket_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id6CombinedDataPacket", handle_id6CombinedDataPacket,
							   id6CombinedDataPacket_oid, OID_LENGTH(id6CombinedDataPacket_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id7CombinedDataPacket", handle_id7CombinedDataPacket,
							   id7CombinedDataPacket_oid, OID_LENGTH(id7CombinedDataPacket_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id8CombinedDataPacket", handle_id8CombinedDataPacket,
							   id8CombinedDataPacket_oid, OID_LENGTH(id8CombinedDataPacket_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id9CombinedDataPacket", handle_id9CombinedDataPacket,
							   id9CombinedDataPacket_oid, OID_LENGTH(id9CombinedDataPacket_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id10CombinedDataPacket", handle_id10CombinedDataPacket,
							   id10CombinedDataPacket_oid, OID_LENGTH(id10CombinedDataPacket_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id11CombinedDataPacket", handle_id11CombinedDataPacket,
							   id11CombinedDataPacket_oid, OID_LENGTH(id11CombinedDataPacket_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id12CombinedDataPacket", handle_id12CombinedDataPacket,
							   id12CombinedDataPacket_oid, OID_LENGTH(id12CombinedDataPacket_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id13CombinedDataPacket", handle_id13CombinedDataPacket,
							   id13CombinedDataPacket_oid, OID_LENGTH(id13CombinedDataPacket_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id14CombinedDataPacket", handle_id14CombinedDataPacket,
							   id14CombinedDataPacket_oid, OID_LENGTH(id14CombinedDataPacket_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id15CombinedDataPacket", handle_id15CombinedDataPacket,
							   id15CombinedDataPacket_oid, OID_LENGTH(id15CombinedDataPacket_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id16CombinedDataPacket", handle_id16CombinedDataPacket,
							   id16CombinedDataPacket_oid, OID_LENGTH(id16CombinedDataPacket_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id17CombinedDataPacket", handle_id17CombinedDataPacket,
							   id17CombinedDataPacket_oid, OID_LENGTH(id17CombinedDataPacket_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id18CombinedDataPacket", handle_id18CombinedDataPacket,
							   id18CombinedDataPacket_oid, OID_LENGTH(id18CombinedDataPacket_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id19CombinedDataPacket", handle_id19CombinedDataPacket,
							   id19CombinedDataPacket_oid, OID_LENGTH(id19CombinedDataPacket_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id20CombinedDataPacket", handle_id20CombinedDataPacket,
							   id20CombinedDataPacket_oid, OID_LENGTH(id20CombinedDataPacket_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id21CombinedDataPacket", handle_id21CombinedDataPacket,
							   id21CombinedDataPacket_oid, OID_LENGTH(id21CombinedDataPacket_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id22CombinedDataPacket", handle_id22CombinedDataPacket,
							   id22CombinedDataPacket_oid, OID_LENGTH(id22CombinedDataPacket_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id23CombinedDataPacket", handle_id23CombinedDataPacket,
							   id23CombinedDataPacket_oid, OID_LENGTH(id23CombinedDataPacket_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id24CombinedDataPacket", handle_id24CombinedDataPacket,
							   id24CombinedDataPacket_oid, OID_LENGTH(id24CombinedDataPacket_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id25CombinedDataPacket", handle_id25CombinedDataPacket,
							   id25CombinedDataPacket_oid, OID_LENGTH(id25CombinedDataPacket_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id26CombinedDataPacket", handle_id26CombinedDataPacket,
							   id26CombinedDataPacket_oid, OID_LENGTH(id26CombinedDataPacket_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id27CombinedDataPacket", handle_id27CombinedDataPacket,
							   id27CombinedDataPacket_oid, OID_LENGTH(id27CombinedDataPacket_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id28CombinedDataPacket", handle_id28CombinedDataPacket,
							   id28CombinedDataPacket_oid, OID_LENGTH(id28CombinedDataPacket_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id29CombinedDataPacket", handle_id29CombinedDataPacket,
							   id29CombinedDataPacket_oid, OID_LENGTH(id29CombinedDataPacket_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id30CombinedDataPacket", handle_id30CombinedDataPacket,
							   id30CombinedDataPacket_oid, OID_LENGTH(id30CombinedDataPacket_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id31CombinedDataPacket", handle_id31CombinedDataPacket,
							   id31CombinedDataPacket_oid, OID_LENGTH(id31CombinedDataPacket_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("id32CombinedDataPacket", handle_id32CombinedDataPacket,
							   id32CombinedDataPacket_oid, OID_LENGTH(id32CombinedDataPacket_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("localCombinedData", handle_localCombinedData,
							   localCombinedData_oid, OID_LENGTH(localCombinedData_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("updateData", handle_updateData,
							   updateData_oid, OID_LENGTH(updateData_oid),
							   HANDLER_CAN_RWRITE
		));

	netsnmp_register_scalar(
		netsnmp_create_handler_registration("reboot", handle_reboot,
							   reboot_oid, OID_LENGTH(reboot_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("set981", handle_set981,
							   set981_oid, OID_LENGTH(set981_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("query981", handle_query981,
							   query981_oid, OID_LENGTH(query981_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("set998", handle_set998,
							   set998_oid, OID_LENGTH(set998_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("query998", handle_query998,
							   query998_oid, OID_LENGTH(query998_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("devCallTimeout", handle_devCallTimeout,
							   devCallTimeout_oid, OID_LENGTH(devCallTimeout_oid),
							   HANDLER_CAN_RWRITE
		));
	netsnmp_register_scalar(
		netsnmp_create_handler_registration("errorRateFreq", handle_errorRateFreq,
							  errorRateFreq_oid, OID_LENGTH(errorRateFreq_oid),
							   HANDLER_CAN_RWRITE
		));

	netsnmp_register_scalar(
		netsnmp_create_handler_registration("saveIqData", handle_saveIqData,
							  saveIqData_oid, OID_LENGTH(saveIqData_oid),
							   HANDLER_CAN_RWRITE
		));
		
	/*手咪相关*/
    netsnmp_register_scalar(
			netsnmp_create_handler_registration("centerModule", handle_centerModule,
								   centerModule_oid, OID_LENGTH(centerModule_oid),
								   HANDLER_CAN_RWRITE
			));
	netsnmp_register_scalar(
			netsnmp_create_handler_registration("gsmModule1", handle_gsmModule1,
								   gsmModule1_oid, OID_LENGTH(gsmModule1_oid),
								   HANDLER_CAN_RWRITE
			));
	netsnmp_register_scalar(
			netsnmp_create_handler_registration("gsmModule2", handle_gsmModule2,
								   gsmModule2_oid, OID_LENGTH(gsmModule2_oid),
								   HANDLER_CAN_RWRITE
			));
	netsnmp_register_scalar(
			netsnmp_create_handler_registration("radioModule", handle_radioModule,
								   radioModule_oid, OID_LENGTH(radioModule_oid),
								   HANDLER_CAN_RWRITE
			));
	netsnmp_register_scalar(
			netsnmp_create_handler_registration("dspModule", handle_dspModule,
								   dspModule_oid, OID_LENGTH(dspModule_oid),
								   HANDLER_CAN_RWRITE
			));
	netsnmp_register_scalar(
			netsnmp_create_handler_registration("microphoneModule1", handle_microphoneModule1,
								   microphoneModule1_oid, OID_LENGTH(microphoneModule1_oid),
								   HANDLER_CAN_RWRITE
			));
	netsnmp_register_scalar(
			netsnmp_create_handler_registration("microphoneModule2", handle_microphoneModule2,
								   microphoneModule2_oid, OID_LENGTH(microphoneModule2_oid),
								   HANDLER_CAN_RWRITE
			));

	netsnmp_register_scalar(
			netsnmp_create_handler_registration("controlModule", handle_controlModule,
								   controlModule_oid, OID_LENGTH(controlModule_oid),
								   HANDLER_CAN_RWRITE
			));
		
/*
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("nodeINTrw", handle_nodeINTrw,
                               nodeINTrw_oid, OID_LENGTH(nodeINTrw_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("nodeUINTrw", handle_nodeUINTrw,
                               nodeUINTrw_oid, OID_LENGTH(nodeUINTrw_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("nodeSTRrw", handle_nodeSTRrw,
                               nodeSTRrw_oid, OID_LENGTH(nodeSTRrw_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("nodeIPrw", handle_nodeIPrw,
                               nodeIPrw_oid, OID_LENGTH(nodeIPrw_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("nodeINTr", handle_nodeINTr,
                               nodeINTr_oid, OID_LENGTH(nodeINTr_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("nodeUINTr", handle_nodeUINTr,
                               nodeUINTr_oid, OID_LENGTH(nodeUINTr_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("nodeSTRr", handle_nodeSTRr,
                               nodeSTRr_oid, OID_LENGTH(nodeSTRr_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("nodeIPr", handle_nodeIPr,
                               nodeIPr_oid, OID_LENGTH(nodeIPr_oid),
                               HANDLER_CAN_RONLY
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("nodeOPAQUErw", handle_nodeOPAQUErw,
                               nodeOPAQUErw_oid, OID_LENGTH(nodeOPAQUErw_oid),
                               HANDLER_CAN_RWRITE
        ));
    netsnmp_register_scalar(
        netsnmp_create_handler_registration("nodeOPAQUEr", handle_nodeOPAQUEr,
                               nodeOPAQUEr_oid, OID_LENGTH(nodeOPAQUEr_oid),
                               HANDLER_CAN_RONLY
        ));
*/

}









int
handle_errorRateFreq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if (shm_ipc_addr->mgr_printf[1])
			{
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
			}
			sem_nm_p();
			shm_nm_addr->error_rate_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			send_local_nm_set_cmd(CMD_CODE_ERROR_RATE_FREQ, (unsigned char *)&freq);

			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->error_rate_freq.ack_flag)
				{
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_errorRateFreq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_id1Freq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_1;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_FREQ);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_FREQ, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
				{
					freq = shm_nm_addr->dev_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if((freq<MIN_FREQ)||(freq>MAX_FREQ))
			{
			    printf("set freq=%d not in 350000000~400000000\n",freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
				}
				sem_nm_p();
				shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_FREQ, (unsigned char *)&freq);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_FREQ, this_id, (unsigned char *)&freq);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id1Freq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_id2Freq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_2;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_FREQ);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_FREQ, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
				{
					freq = shm_nm_addr->dev_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if((freq<MIN_FREQ)||(freq>MAX_FREQ))
			{
			    printf("set freq=%d not in 350000000~400000000\n",freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
				}
				sem_nm_p();
				shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_FREQ, (unsigned char *)&freq);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_FREQ, this_id, (unsigned char *)&freq);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id2Freq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_id3Freq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_3;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_FREQ);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_FREQ, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
				{
					freq = shm_nm_addr->dev_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if((freq<MIN_FREQ)||(freq>MAX_FREQ))
			{
			    printf("set freq=%d not in 350000000~400000000\n",freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
				}
				sem_nm_p();
				shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_FREQ, (unsigned char *)&freq);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_FREQ, this_id, (unsigned char *)&freq);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id3Freq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_id4Freq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_4;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_FREQ);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_FREQ, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
				{
					freq = shm_nm_addr->dev_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if((freq<MIN_FREQ)||(freq>MAX_FREQ))
			{
			    printf("set freq=%d not in 350000000~400000000\n",freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
				}
				sem_nm_p();
				shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_FREQ, (unsigned char *)&freq);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_FREQ, this_id, (unsigned char *)&freq);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id4Freq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_id5Freq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_5;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_FREQ);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_FREQ, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
				{
					freq = shm_nm_addr->dev_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if((freq<MIN_FREQ)||(freq>MAX_FREQ))
			{
			    printf("set freq=%d not in 350000000~400000000\n",freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
				}
				sem_nm_p();
				shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_FREQ, (unsigned char *)&freq);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_FREQ, this_id, (unsigned char *)&freq);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id5Freq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_id6Freq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_6;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_FREQ);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_FREQ, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
				{
					freq = shm_nm_addr->dev_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if((freq<MIN_FREQ)||(freq>MAX_FREQ))
			{
			    printf("set freq=%d not in 350000000~400000000\n",freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
				}
				sem_nm_p();
				shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_FREQ, (unsigned char *)&freq);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_FREQ, this_id, (unsigned char *)&freq);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id6Freq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_id7Freq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_7;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_FREQ);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_FREQ, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
				{
					freq = shm_nm_addr->dev_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if((freq<MIN_FREQ)||(freq>MAX_FREQ))
			{
			    printf("set freq=%d not in 350000000~400000000\n",freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
				}
				sem_nm_p();
				shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_FREQ, (unsigned char *)&freq);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_FREQ, this_id, (unsigned char *)&freq);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id7Freq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_id8Freq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_8;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_FREQ);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_FREQ, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
				{
					freq = shm_nm_addr->dev_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if((freq<MIN_FREQ)||(freq>MAX_FREQ))
			{
			    printf("set freq=%d not in 350000000~400000000\n",freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
				}
				sem_nm_p();
				shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_FREQ, (unsigned char *)&freq);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_FREQ, this_id, (unsigned char *)&freq);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id8Freq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_id9Freq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_9;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_FREQ);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_FREQ, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
				{
					freq = shm_nm_addr->dev_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if((freq<MIN_FREQ)||(freq>MAX_FREQ))
			{
			    printf("set freq=%d not in 350000000~400000000\n",freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
				}
				sem_nm_p();
				shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_FREQ, (unsigned char *)&freq);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_FREQ, this_id, (unsigned char *)&freq);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id9Freq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_id10Freq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_10;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_FREQ);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_FREQ, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
				{
					freq = shm_nm_addr->dev_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if((freq<MIN_FREQ)||(freq>MAX_FREQ))
			{
			    printf("set freq=%d not in 350000000~400000000\n",freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
				}
				sem_nm_p();
				shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_FREQ, (unsigned char *)&freq);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_FREQ, this_id, (unsigned char *)&freq);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id10Freq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_id11Freq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_11;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_FREQ);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_FREQ, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
				{
					freq = shm_nm_addr->dev_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if((freq<MIN_FREQ)||(freq>MAX_FREQ))
			{
			    printf("set freq=%d not in 350000000~400000000\n",freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
				}
				sem_nm_p();
				shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_FREQ, (unsigned char *)&freq);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_FREQ, this_id, (unsigned char *)&freq);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id11Freq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_id12Freq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_12;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_FREQ);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_FREQ, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
				{
					freq = shm_nm_addr->dev_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if((freq<MIN_FREQ)||(freq>MAX_FREQ))
			{
			    printf("set freq=%d not in 350000000~400000000\n",freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
				}
				sem_nm_p();
				shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_FREQ, (unsigned char *)&freq);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_FREQ, this_id, (unsigned char *)&freq);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id12Freq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_id13Freq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_13;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_FREQ);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_FREQ, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
				{
					freq = shm_nm_addr->dev_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if((freq<MIN_FREQ)||(freq>MAX_FREQ))
			{
			    printf("set freq=%d not in 350000000~400000000\n",freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
				}
				sem_nm_p();
				shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_FREQ, (unsigned char *)&freq);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_FREQ, this_id, (unsigned char *)&freq);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id13Freq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_id14Freq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_14;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_FREQ);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_FREQ, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
				{
					freq = shm_nm_addr->dev_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if((freq<MIN_FREQ)||(freq>MAX_FREQ))
			{
			    printf("set freq=%d not in 350000000~400000000\n",freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
				}
				sem_nm_p();
				shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_FREQ, (unsigned char *)&freq);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_FREQ, this_id, (unsigned char *)&freq);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id14Freq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_id15Freq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_15;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_FREQ);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_FREQ, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
				{
					freq = shm_nm_addr->dev_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if((freq<MIN_FREQ)||(freq>MAX_FREQ))
			{
			    printf("set freq=%d not in 350000000~400000000\n",freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
				}
				sem_nm_p();
				shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_FREQ, (unsigned char *)&freq);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_FREQ, this_id, (unsigned char *)&freq);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id15Freq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_id16Freq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_16;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_FREQ);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_FREQ, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
				{
					freq = shm_nm_addr->dev_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if((freq<MIN_FREQ)||(freq>MAX_FREQ))
			{
			    printf("set freq=%d not in 350000000~400000000\n",freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
				}
				sem_nm_p();
				shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_FREQ, (unsigned char *)&freq);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_FREQ, this_id, (unsigned char *)&freq);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id16Freq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_id17Freq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_17;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_FREQ);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_FREQ, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
				{
					freq = shm_nm_addr->dev_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if((freq<MIN_FREQ)||(freq>MAX_FREQ))
			{
			    printf("set freq=%d not in 350000000~400000000\n",freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
				}
				sem_nm_p();
				shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_FREQ, (unsigned char *)&freq);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_FREQ, this_id, (unsigned char *)&freq);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id17Freq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_id18Freq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_18;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_FREQ);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_FREQ, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
				{
					freq = shm_nm_addr->dev_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if((freq<MIN_FREQ)||(freq>MAX_FREQ))
			{
			    printf("set freq=%d not in 350000000~400000000\n",freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
				}
				sem_nm_p();
				shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_FREQ, (unsigned char *)&freq);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_FREQ, this_id, (unsigned char *)&freq);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id18Freq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_id19Freq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_19;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_FREQ);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_FREQ, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
				{
					freq = shm_nm_addr->dev_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if((freq<MIN_FREQ)||(freq>MAX_FREQ))
			{
			    printf("set freq=%d not in 350000000~400000000\n",freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
				}
				sem_nm_p();
				shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_FREQ, (unsigned char *)&freq);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_FREQ, this_id, (unsigned char *)&freq);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id19Freq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_id20Freq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_20;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_FREQ);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_FREQ, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
				{
					freq = shm_nm_addr->dev_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if((freq<MIN_FREQ)||(freq>MAX_FREQ))
			{
			    printf("set freq=%d not in 350000000~400000000\n",freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
				}
				sem_nm_p();
				shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_FREQ, (unsigned char *)&freq);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_FREQ, this_id, (unsigned char *)&freq);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id20Freq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_id21Freq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_21;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_FREQ);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_FREQ, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
				{
					freq = shm_nm_addr->dev_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if((freq<MIN_FREQ)||(freq>MAX_FREQ))
			{
			    printf("set freq=%d not in 350000000~400000000\n",freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
				}
				sem_nm_p();
				shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_FREQ, (unsigned char *)&freq);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_FREQ, this_id, (unsigned char *)&freq);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id21Freq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_id22Freq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_22;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_FREQ);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_FREQ, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
				{
					freq = shm_nm_addr->dev_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if((freq<MIN_FREQ)||(freq>MAX_FREQ))
			{
			    printf("set freq=%d not in 350000000~400000000\n",freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
				}
				sem_nm_p();
				shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_FREQ, (unsigned char *)&freq);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_FREQ, this_id, (unsigned char *)&freq);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id22Freq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_id23Freq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_23;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_FREQ);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_FREQ, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
				{
					freq = shm_nm_addr->dev_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if((freq<MIN_FREQ)||(freq>MAX_FREQ))
			{
			    printf("set freq=%d not in 350000000~400000000\n",freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
				}
				sem_nm_p();
				shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_FREQ, (unsigned char *)&freq);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_FREQ, this_id, (unsigned char *)&freq);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id23Freq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_id24Freq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_24;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_FREQ);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_FREQ, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
				{
					freq = shm_nm_addr->dev_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if((freq<MIN_FREQ)||(freq>MAX_FREQ))
			{
			    printf("set freq=%d not in 350000000~400000000\n",freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
				}
				sem_nm_p();
				shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_FREQ, (unsigned char *)&freq);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_FREQ, this_id, (unsigned char *)&freq);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id24Freq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_id25Freq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_25;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_FREQ);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_FREQ, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
				{
					freq = shm_nm_addr->dev_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if((freq<MIN_FREQ)||(freq>MAX_FREQ))
			{
			    printf("set freq=%d not in 350000000~400000000\n",freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
				}
				sem_nm_p();
				shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_FREQ, (unsigned char *)&freq);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_FREQ, this_id, (unsigned char *)&freq);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id25Freq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_id26Freq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_26;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_FREQ);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_FREQ, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
				{
					freq = shm_nm_addr->dev_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if((freq<MIN_FREQ)||(freq>MAX_FREQ))
			{
			    printf("set freq=%d not in 350000000~400000000\n",freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
				}
				sem_nm_p();
				shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_FREQ, (unsigned char *)&freq);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_FREQ, this_id, (unsigned char *)&freq);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id26Freq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_id27Freq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_27;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_FREQ);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_FREQ, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
				{
					freq = shm_nm_addr->dev_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if((freq<MIN_FREQ)||(freq>MAX_FREQ))
			{
			    printf("set freq=%d not in 350000000~400000000\n",freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
				}
				sem_nm_p();
				shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_FREQ, (unsigned char *)&freq);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_FREQ, this_id, (unsigned char *)&freq);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id27Freq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_id28Freq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_28;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_FREQ);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_FREQ, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
				{
					freq = shm_nm_addr->dev_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if((freq<MIN_FREQ)||(freq>MAX_FREQ))
			{
			    printf("set freq=%d not in 350000000~400000000\n",freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
				}
				sem_nm_p();
				shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_FREQ, (unsigned char *)&freq);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_FREQ, this_id, (unsigned char *)&freq);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id28Freq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_id29Freq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_29;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_FREQ);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_FREQ, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
				{
					freq = shm_nm_addr->dev_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if((freq<MIN_FREQ)||(freq>MAX_FREQ))
			{
			    printf("set freq=%d not in 350000000~400000000\n",freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
				}
				sem_nm_p();
				shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_FREQ, (unsigned char *)&freq);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_FREQ, this_id, (unsigned char *)&freq);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id29Freq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_id30Freq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_30;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_FREQ);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_FREQ, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
				{
					freq = shm_nm_addr->dev_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if((freq<MIN_FREQ)||(freq>MAX_FREQ))
			{
			    printf("set freq=%d not in 350000000~400000000\n",freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
				}
				sem_nm_p();
				shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_FREQ, (unsigned char *)&freq);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_FREQ, this_id, (unsigned char *)&freq);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id30Freq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_id31Freq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_31;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_FREQ);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_FREQ, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
				{
					freq = shm_nm_addr->dev_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if((freq<MIN_FREQ)||(freq>MAX_FREQ))
			{
			    printf("set freq=%d not in 350000000~400000000\n",freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
				}
				sem_nm_p();
				shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_FREQ, (unsigned char *)&freq);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_FREQ, this_id, (unsigned char *)&freq);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id31Freq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_id32Freq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_32;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_FREQ);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_FREQ, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
				{
					freq = shm_nm_addr->dev_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if((freq<MIN_FREQ)||(freq>MAX_FREQ))
			{
			    printf("set freq=%d not in 350000000~400000000\n",freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
				}
				sem_nm_p();
				shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_FREQ, (unsigned char *)&freq);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_FREQ, this_id, (unsigned char *)&freq);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id32Freq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_id1Power(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int power = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_1;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_POWER);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_POWER, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
				{
					power = shm_nm_addr->dev_Power.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &power, sizeof(power));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			power = *((unsigned int *)requests->requestvb->val.integer);
			for(i=0;i<5;i++)
			{
			    if(power==power_range[i])
			    {
			        flag=1;
					break;
			    }
			}
			if(flag)
			{
			    flag=0;
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
				}
				sem_nm_p();
				shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_POWER, (unsigned char *)&power);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_POWER, this_id, (unsigned char *)&power);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set power=%d not in 1,5,10,16,20\n",power);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id1Power\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_id2Power(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int power = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_2;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_POWER);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_POWER, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
				{
					power = shm_nm_addr->dev_Power.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &power, sizeof(power));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			power = *((unsigned int *)requests->requestvb->val.integer);
			for(i=0;i<5;i++)
			{
			    if(power==power_range[i])
			    {
			        flag=1;
					break;
			    }
			}
			if(flag)
			{
			    flag=0;
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
				}
				sem_nm_p();
				shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_POWER, (unsigned char *)&power);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_POWER, this_id, (unsigned char *)&power);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set power=%d not in 1,5,10,16,20\n",power);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id2Power\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_id3Power(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int power = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_3;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_POWER);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_POWER, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
				{
					power = shm_nm_addr->dev_Power.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &power, sizeof(power));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			power = *((unsigned int *)requests->requestvb->val.integer);
			for(i=0;i<5;i++)
			{
			    if(power==power_range[i])
			    {
			        flag=1;
					break;
			    }
			}
			if(flag)
			{
			    flag=0;
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
				}
				sem_nm_p();
				shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_POWER, (unsigned char *)&power);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_POWER, this_id, (unsigned char *)&power);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set power=%d not in 1,5,10,16,20\n",power);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id3Power\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_id4Power(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int power = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_4;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_POWER);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_POWER, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
				{
					power = shm_nm_addr->dev_Power.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &power, sizeof(power));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			power = *((unsigned int *)requests->requestvb->val.integer);
			for(i=0;i<5;i++)
			{
			    if(power==power_range[i])
			    {
			        flag=1;
					break;
			    }
			}
			if(flag)
			{
			    flag=0;
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
				}
				sem_nm_p();
				shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_POWER, (unsigned char *)&power);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_POWER, this_id, (unsigned char *)&power);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set power=%d not in 1,5,10,16,20\n",power);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id4Power\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_id5Power(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int power = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_5;
	int  flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_POWER);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_POWER, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
				{
					power = shm_nm_addr->dev_Power.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &power, sizeof(power));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			power = *((unsigned int *)requests->requestvb->val.integer);
			for(i=0;i<5;i++)
			{
			    if(power==power_range[i])
			    {
			        flag=1;
					break;
			    }
			}
			if(flag)
			{
			    flag=0;
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
				}
				sem_nm_p();
				shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_POWER, (unsigned char *)&power);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_POWER, this_id, (unsigned char *)&power);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set power=%d not in 1,5,10,16,20\n",power);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id5Power\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_id6Power(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int power = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_6;
	int flag=0;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_POWER);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_POWER, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
				{
					power = shm_nm_addr->dev_Power.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &power, sizeof(power));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			power = *((unsigned int *)requests->requestvb->val.integer);
			for(i=0;i<5;i++)
			{
			    if(power==power_range[i])
			    {
			        flag=1;
					break;
			    }
			}
			if(flag)
			{
			    flag=0;
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
				}
				sem_nm_p();
				shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_POWER, (unsigned char *)&power);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_POWER, this_id, (unsigned char *)&power);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set power=%d not in 1,5,10,16,20\n",power);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id6Power\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_id7Power(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int power = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_7;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_POWER);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_POWER, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
				{
					power = shm_nm_addr->dev_Power.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &power, sizeof(power));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			power = *((unsigned int *)requests->requestvb->val.integer);
			for(i=0;i<5;i++)
			{
			    if(power==power_range[i])
			    {
			        flag=1;
					break;
			    }
			}
			if(flag)
			{
			    flag=0;
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
				}
				sem_nm_p();
				shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_POWER, (unsigned char *)&power);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_POWER, this_id, (unsigned char *)&power);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set power=%d not in 1,5,10,16,20\n",power);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id7Power\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_id8Power(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int power = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_8;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_POWER);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_POWER, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
				{
					power = shm_nm_addr->dev_Power.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &power, sizeof(power));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			power = *((unsigned int *)requests->requestvb->val.integer);
			for(i=0;i<5;i++)
			{
			    if(power==power_range[i])
			    {
			        flag=1;
					break;
			    }
			}
			if(flag)
			{
			    flag=0;
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
				}
				sem_nm_p();
				shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_POWER, (unsigned char *)&power);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_POWER, this_id, (unsigned char *)&power);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set power=%d not in 1,5,10,16,20\n",power);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id8Power\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_id9Power(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int power = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_9;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_POWER);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_POWER, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
				{
					power = shm_nm_addr->dev_Power.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &power, sizeof(power));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			power = *((unsigned int *)requests->requestvb->val.integer);
			for(i=0;i<5;i++)
			{
			    if(power==power_range[i])
			    {
			        flag=1;
					break;
			    }
			}
			if(flag)
			{
			    flag=0;
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
				}
				sem_nm_p();
				shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_POWER, (unsigned char *)&power);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_POWER, this_id, (unsigned char *)&power);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set power=%d not in 1,5,10,16,20\n",power);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id9Power\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_id10Power(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int power = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_10;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_POWER);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_POWER, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
				{
					power = shm_nm_addr->dev_Power.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &power, sizeof(power));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			power = *((unsigned int *)requests->requestvb->val.integer);
			for(i=0;i<5;i++)
			{
			    if(power==power_range[i])
			    {
			        flag=1;
					break;
			    }
			}
			if(flag)
			{
			    flag=0;
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
				}
				sem_nm_p();
				shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_POWER, (unsigned char *)&power);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_POWER, this_id, (unsigned char *)&power);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set power=%d not in 1,5,10,16,20\n",power);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id10Power\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_id11Power(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int power = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_11;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_POWER);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_POWER, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
				{
					power = shm_nm_addr->dev_Power.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &power, sizeof(power));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			power = *((unsigned int *)requests->requestvb->val.integer);
			for(i=0;i<5;i++)
			{
			    if(power==power_range[i])
			    {
			        flag=1;
					break;
			    }
			}
			if(flag)
			{
			    flag=0;
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
				}
				sem_nm_p();
				shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_POWER, (unsigned char *)&power);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_POWER, this_id, (unsigned char *)&power);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set power=%d not in 1,5,10,16,20\n",power);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id11Power\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_id12Power(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int power = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_12;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_POWER);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_POWER, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
				{
					power = shm_nm_addr->dev_Power.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &power, sizeof(power));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			power = *((unsigned int *)requests->requestvb->val.integer);
			for(i=0;i<5;i++)
			{
			    if(power==power_range[i])
			    {
			        flag=1;
					break;
			    }
			}
			if(flag)
			{
			    flag=0;
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
				}
				sem_nm_p();
				shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_POWER, (unsigned char *)&power);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_POWER, this_id, (unsigned char *)&power);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set power=%d not in 1,5,10,16,20\n",power);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id12Power\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_id13Power(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int power = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_13;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_POWER);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_POWER, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
				{
					power = shm_nm_addr->dev_Power.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &power, sizeof(power));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			power = *((unsigned int *)requests->requestvb->val.integer);
			for(i=0;i<5;i++)
			{
			    if(power==power_range[i])
			    {
			        flag=1;
					break;
			    }
			}
			if(flag)
			{
			    flag=0;
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
				}
				sem_nm_p();
				shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_POWER, (unsigned char *)&power);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_POWER, this_id, (unsigned char *)&power);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set power=%d not in 1,5,10,16,20\n",power);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id13Power\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_id14Power(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int power = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_14;
	int flag=0;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_POWER);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_POWER, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
				{
					power = shm_nm_addr->dev_Power.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &power, sizeof(power));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			power = *((unsigned int *)requests->requestvb->val.integer);
			for(i=0;i<5;i++)
			{
			    if(power==power_range[i])
			    {
			        flag=1;
					break;
			    }
			}
			if(flag)
			{
			    flag=0;
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
				}
				sem_nm_p();
				shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_POWER, (unsigned char *)&power);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_POWER, this_id, (unsigned char *)&power);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set power=%d not in 1,5,10,16,20\n",power);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id14Power\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_id15Power(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int power = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_15;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_POWER);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_POWER, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
				{
					power = shm_nm_addr->dev_Power.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &power, sizeof(power));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			power = *((unsigned int *)requests->requestvb->val.integer);
			for(i=0;i<5;i++)
			{
			    if(power==power_range[i])
			    {
			        flag=1;
					break;
			    }
			}
			if(flag)
			{
			    flag=0;
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
				}
				sem_nm_p();
				shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_POWER, (unsigned char *)&power);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_POWER, this_id, (unsigned char *)&power);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set power=%d not in 1,5,10,16,20\n",power);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id15Power\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_id16Power(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int power = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_16;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_POWER);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_POWER, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
				{
					power = shm_nm_addr->dev_Power.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &power, sizeof(power));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			power = *((unsigned int *)requests->requestvb->val.integer);
			for(i=0;i<5;i++)
			{
			    if(power==power_range[i])
			    {
			        flag=1;
					break;
			    }
			}
			if(flag)
			{
			    flag=0;
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
				}
				sem_nm_p();
				shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_POWER, (unsigned char *)&power);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_POWER, this_id, (unsigned char *)&power);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set power=%d not in 1,5,10,16,20\n",power);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id16Power\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_id17Power(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int power = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_17;
	int flag=0;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_POWER);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_POWER, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
				{
					power = shm_nm_addr->dev_Power.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &power, sizeof(power));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			power = *((unsigned int *)requests->requestvb->val.integer);
			for(i=0;i<5;i++)
			{
			    if(power==power_range[i])
			    {
			        flag=1;
					break;
			    }
			}
			if(flag)
			{
			    flag=0;
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
				}
				sem_nm_p();
				shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_POWER, (unsigned char *)&power);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_POWER, this_id, (unsigned char *)&power);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set power=%d not in 1,5,10,16,20\n",power);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id17Power\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_id18Power(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int power = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_18;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_POWER);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_POWER, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
				{
					power = shm_nm_addr->dev_Power.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &power, sizeof(power));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			power = *((unsigned int *)requests->requestvb->val.integer);
			for(i=0;i<5;i++)
			{
			    if(power==power_range[i])
			    {
			        flag=1;
					break;
			    }
			}
			if(flag)
			{
			    flag=0;
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
				}
				sem_nm_p();
				shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_POWER, (unsigned char *)&power);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_POWER, this_id, (unsigned char *)&power);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set power=%d not in 1,5,10,16,20\n",power);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id18Power\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_id19Power(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int power = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_19;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_POWER);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_POWER, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
				{
					power = shm_nm_addr->dev_Power.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &power, sizeof(power));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			power = *((unsigned int *)requests->requestvb->val.integer);
			for(i=0;i<5;i++)
			{
			    if(power==power_range[i])
			    {
			        flag=1;
					break;
			    }
			}
			if(flag)
			{
			    flag=0;
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
				}
				sem_nm_p();
				shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_POWER, (unsigned char *)&power);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_POWER, this_id, (unsigned char *)&power);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set power=%d not in 1,5,10,16,20\n",power);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id19Power\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_id20Power(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int power = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_20;
	int flag=0;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_POWER);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_POWER, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
				{
					power = shm_nm_addr->dev_Power.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &power, sizeof(power));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			power = *((unsigned int *)requests->requestvb->val.integer);
			for(i=0;i<5;i++)
			{
			    if(power==power_range[i])
			    {
			        flag=1;
					break;
			    }
			}
			if(flag)
			{
			    flag=0;
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
				}
				sem_nm_p();
				shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_POWER, (unsigned char *)&power);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_POWER, this_id, (unsigned char *)&power);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set power=%d not in 1,5,10,16,20\n",power);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id20Power\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_id21Power(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int power = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_21;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_POWER);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_POWER, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
				{
					power = shm_nm_addr->dev_Power.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &power, sizeof(power));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			power = *((unsigned int *)requests->requestvb->val.integer);
			for(i=0;i<5;i++)
			{
			    if(power==power_range[i])
			    {
			        flag=1;
					break;
			    }
			}
			if(flag)
			{
			    flag=0;
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
				}
				sem_nm_p();
				shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_POWER, (unsigned char *)&power);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_POWER, this_id, (unsigned char *)&power);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set power=%d not in 1,5,10,16,20\n",power);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id21Power\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_id22Power(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int power = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_22;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_POWER);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_POWER, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
				{
					power = shm_nm_addr->dev_Power.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &power, sizeof(power));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			power = *((unsigned int *)requests->requestvb->val.integer);
			for(i=0;i<5;i++)
			{
			    if(power==power_range[i])
			    {
			        flag=1;
					break;
			    }
			}
			if(flag)
			{
			    flag=0;
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
				}
				sem_nm_p();
				shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_POWER, (unsigned char *)&power);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_POWER, this_id, (unsigned char *)&power);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set power=%d not in 1,5,10,16,20\n",power);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id22Power\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_id23Power(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int power = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_23;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_POWER);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_POWER, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
				{
					power = shm_nm_addr->dev_Power.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &power, sizeof(power));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			power = *((unsigned int *)requests->requestvb->val.integer);
			for(i=0;i<5;i++)
			{
			    if(power==power_range[i])
			    {
			        flag=1;
					break;
			    }
			}
			if(flag)
			{
			    flag=0;
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
				}
				sem_nm_p();
				shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_POWER, (unsigned char *)&power);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_POWER, this_id, (unsigned char *)&power);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set power=%d not in 1,5,10,16,20\n",power);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id23Power\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_id24Power(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int power = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_24;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_POWER);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_POWER, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
				{
					power = shm_nm_addr->dev_Power.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &power, sizeof(power));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			power = *((unsigned int *)requests->requestvb->val.integer);
			for(i=0;i<5;i++)
			{
			    if(power==power_range[i])
			    {
			        flag=1;
					break;
			    }
			}
			if(flag)
			{
			    flag=0;
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
				}
				sem_nm_p();
				shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_POWER, (unsigned char *)&power);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_POWER, this_id, (unsigned char *)&power);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set power=%d not in 1,5,10,16,20\n",power);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id24Power\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_id25Power(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int power = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_25;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_POWER);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_POWER, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
				{
					power = shm_nm_addr->dev_Power.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &power, sizeof(power));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			power = *((unsigned int *)requests->requestvb->val.integer);
			for(i=0;i<5;i++)
			{
			    if(power==power_range[i])
			    {
			        flag=1;
					break;
			    }
			}
			if(flag)
			{
			    flag=0;
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
				}
				sem_nm_p();
				shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_POWER, (unsigned char *)&power);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_POWER, this_id, (unsigned char *)&power);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set power=%d not in 1,5,10,16,20\n",power);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id25Power\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_id26Power(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int power = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_26;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_POWER);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_POWER, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
				{
					power = shm_nm_addr->dev_Power.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &power, sizeof(power));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			power = *((unsigned int *)requests->requestvb->val.integer);
			for(i=0;i<5;i++)
			{
			    if(power==power_range[i])
			    {
			        flag=1;
					break;
			    }
			}
			if(flag)
			{
			    flag=0;
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
				}
				sem_nm_p();
				shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_POWER, (unsigned char *)&power);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_POWER, this_id, (unsigned char *)&power);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set power=%d not in 1,5,10,16,20\n",power);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id26Power\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_id27Power(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int power = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_27;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_POWER);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_POWER, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
				{
					power = shm_nm_addr->dev_Power.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &power, sizeof(power));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			power = *((unsigned int *)requests->requestvb->val.integer);
			for(i=0;i<5;i++)
			{
			    if(power==power_range[i])
			    {
			        flag=1;
					break;
			    }
			}
			if(flag)
			{
			    flag=0;
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
				}
				sem_nm_p();
				shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_POWER, (unsigned char *)&power);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_POWER, this_id, (unsigned char *)&power);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set power=%d not in 1,5,10,16,20\n",power);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id27Power\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_id28Power(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int power = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_28;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_POWER);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_POWER, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
				{
					power = shm_nm_addr->dev_Power.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &power, sizeof(power));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			power = *((unsigned int *)requests->requestvb->val.integer);
			for(i=0;i<5;i++)
			{
			    if(power==power_range[i])
			    {
			        flag=1;
					break;
			    }
			}
			if(flag)
			{
			    flag=0;
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
				}
				sem_nm_p();
				shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_POWER, (unsigned char *)&power);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_POWER, this_id, (unsigned char *)&power);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set power=%d not in 1,5,10,16,20\n",power);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id28Power\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_id29Power(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int power = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_29;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_POWER);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_POWER, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
				{
					power = shm_nm_addr->dev_Power.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &power, sizeof(power));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			power = *((unsigned int *)requests->requestvb->val.integer);
			for(i=0;i<5;i++)
			{
			    if(power==power_range[i])
			    {
			        flag=1;
					break;
			    }
			}
			if(flag)
			{
			    flag=0;
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
				}
				sem_nm_p();
				shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_POWER, (unsigned char *)&power);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_POWER, this_id, (unsigned char *)&power);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set power=%d not in 1,5,10,16,20\n",power);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id29Power\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_id30Power(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int power = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_30;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_POWER);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_POWER, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
				{
					power = shm_nm_addr->dev_Power.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &power, sizeof(power));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			power = *((unsigned int *)requests->requestvb->val.integer);
			for(i=0;i<5;i++)
			{
			    if(power==power_range[i])
			    {
			        flag=1;
					break;
			    }
			}
			if(flag)
			{
			    flag=0;
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
				}
				sem_nm_p();
				shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_POWER, (unsigned char *)&power);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_POWER, this_id, (unsigned char *)&power);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set power=%d not in 1,5,10,16,20\n",power);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id30Power\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_id31Power(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int power = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_31;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_POWER);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_POWER, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
				{
					power = shm_nm_addr->dev_Power.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &power, sizeof(power));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			power = *((unsigned int *)requests->requestvb->val.integer);
			for(i=0;i<5;i++)
			{
			    if(power==power_range[i])
			    {
			        flag=1;
					break;
			    }
			}
			if(flag)
			{
			    flag=0;
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
				}
				sem_nm_p();
				shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_POWER, (unsigned char *)&power);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_POWER, this_id, (unsigned char *)&power);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set power=%d not in 1,5,10,16,20\n",power);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id31Power\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_id32Power(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int power = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_32;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_DEV_POWER);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_DEV_POWER, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
				{
					power = shm_nm_addr->dev_Power.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &power, sizeof(power));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			power = *((unsigned int *)requests->requestvb->val.integer);
			for(i=0;i<5;i++)
			{
			    if(power==power_range[i])
			    {
			        flag=1;
					break;
			    }
			}
			if(flag)
			{
			    flag=0;
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
				}
				sem_nm_p();
				shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_DEV_POWER, (unsigned char *)&power);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_DEV_POWER, this_id, (unsigned char *)&power);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set power=%d not in 1,5,10,16,20\n",power);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id32Power\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_localFreq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_DEV_FREQ);
			
			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
				{
					freq = shm_nm_addr->dev_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if((freq<MIN_FREQ)||(freq>MAX_FREQ))
			{
			    printf("set freq=%d not in 350000000~400000000\n",freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
				}
				sem_nm_p();
				shm_nm_addr->dev_freq.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();

				send_local_nm_set_cmd(CMD_CODE_DEV_FREQ, (unsigned char *)&freq);
		
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_freq.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_localFreq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_localPower(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info   *reqinfo,
                       netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int dev_Power = 0;
	struct timeval delay; 
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_DEV_POWER);
			
			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
				{
					dev_Power = shm_nm_addr->dev_Power.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET power : %u\n", __FILE__, __FUNCTION__, __LINE__, dev_Power);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &dev_Power, sizeof(dev_Power));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			dev_Power = *((unsigned int *)requests->requestvb->val.integer);
			for(i=0;i<5;i++)
			{
			    if(dev_Power==power_range[i])
			    {
			        flag=1;
					break;
			    }
			}
			if(flag)
			{
			    flag=0;
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION power : %u\n", __FILE__, __FUNCTION__, __LINE__, dev_Power);
				}
				sem_nm_p();
				shm_nm_addr->dev_Power.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				send_local_nm_set_cmd(CMD_CODE_DEV_POWER, (unsigned char *)&dev_Power);
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_Power.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set power=%d not in 1,5,10,16,20\n",dev_Power);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_localPower\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_localOpenCloseLoop(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info   *reqinfo,
                       netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int open_close_loop = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->open_close_loop.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_OPEN_CLOSE_LOOP);
			
			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->open_close_loop.ack_flag)
				{
					open_close_loop = shm_nm_addr->open_close_loop.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET open_close_loop : %u\n", __FILE__, __FUNCTION__, __LINE__, open_close_loop);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &open_close_loop, sizeof(open_close_loop));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			
			open_close_loop = *((unsigned int *)requests->requestvb->val.integer);
			if((open_close_loop==0)||(open_close_loop==1))
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION open_close_loop : %u\n", __FILE__, __FUNCTION__, __LINE__, open_close_loop);
				}
				sem_nm_p();
				shm_nm_addr->open_close_loop.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				send_local_nm_set_cmd(CMD_CODE_OPEN_CLOSE_LOOP, (unsigned char *)&open_close_loop);
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->open_close_loop.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set open_close_loop=%d not in 0,1\n",open_close_loop);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_localOpenCloseLoop\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_lockingTime(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info   *reqinfo,
                       netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int locking_time = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->locking_time.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_LOCKING_TIME);
			
			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->locking_time.ack_flag)
				{
					locking_time = shm_nm_addr->locking_time.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET locking_time : %u\n", __FILE__, __FUNCTION__, __LINE__, locking_time);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &locking_time, sizeof(locking_time));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			locking_time = *((unsigned int *)requests->requestvb->val.integer);
			if((locking_time<MIN_LOCK_TIME)||(locking_time>MAX_LOCK_TIME))
			{
			    printf("set locking_time=%d not in 0~65535\n",locking_time);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION locking_time : %u\n", __FILE__, __FUNCTION__, __LINE__, locking_time);
				}
				sem_nm_p();
				shm_nm_addr->locking_time.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				send_local_nm_set_cmd(CMD_CODE_LOCKING_TIME, (unsigned char *)&locking_time);
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->locking_time.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_lockingTime\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_halfVarianceThreshold(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info   *reqinfo,
                       netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int half_variance_threshold = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->half_variance_threshold.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_HALF_VARIANCE_THRESHOLD);
			
			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->half_variance_threshold.ack_flag)
				{
					half_variance_threshold = shm_nm_addr->half_variance_threshold.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET half_variance_threshold : %u\n", __FILE__, __FUNCTION__, __LINE__, half_variance_threshold);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &half_variance_threshold, sizeof(half_variance_threshold));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			half_variance_threshold = *((unsigned int *)requests->requestvb->val.integer);
			if((half_variance_threshold<MIN_VARIANCE)||(half_variance_threshold>MAX_VARIANCE))
			{
			    printf("set half_variance_threshold=%d not in 0~65535\n",half_variance_threshold);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION half_variance_threshold : %u\n", __FILE__, __FUNCTION__, __LINE__, half_variance_threshold);
				}
				sem_nm_p();
				shm_nm_addr->half_variance_threshold.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				send_local_nm_set_cmd(CMD_CODE_HALF_VARIANCE_THRESHOLD, (unsigned char *)&half_variance_threshold);
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->half_variance_threshold.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_halfVarianceThreshold\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_devId(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info   *reqinfo,
                       netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int dev_id = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_id.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_DEV_ID);
			
			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_id.ack_flag)
				{
					dev_id= shm_nm_addr->dev_id.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET dev_id : %u\n", __FILE__, __FUNCTION__, __LINE__, dev_id);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &dev_id, sizeof(dev_id));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			dev_id = *((unsigned int *)requests->requestvb->val.integer);
			if((dev_id<MIN_DEV_ID)||(dev_id>MAX_DEV_ID))
			{
			    printf("set dev_id=%d not in 0~31\n",dev_id);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION dev_id : %u\n", __FILE__, __FUNCTION__, __LINE__, dev_id);
				}
				sem_nm_p();
				shm_nm_addr->dev_id.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				send_local_nm_set_cmd(CMD_CODE_DEV_ID, (unsigned char *)&dev_id);
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->dev_id.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_devId\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_localCc(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info   *reqinfo,
                       netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int cc = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->local_cc.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_LOCAL_CC);
			
			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->local_cc.ack_flag)
				{
					cc= shm_nm_addr->local_cc.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET cc : %u\n", __FILE__, __FUNCTION__, __LINE__, cc);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &cc, sizeof(cc));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			cc= *((unsigned int *)requests->requestvb->val.integer);
			if((cc<MIN_CC)||(cc>MAX_CC))
			{
			    printf("set cc=%d not in 0~15\n",cc);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION cc : %u\n", __FILE__, __FUNCTION__, __LINE__, cc);
				}
				sem_nm_p();
				shm_nm_addr->local_cc.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				send_local_nm_set_cmd(CMD_CODE_LOCAL_CC, (unsigned char *)&cc);
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->local_cc.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_localCc\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}





int
handle_alarmSwitchStatus(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info   *reqinfo,
                       netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int alarm_status = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->alarm_switch_status.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_ALARM_SWITCH);
			
			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->alarm_switch_status.ack_flag)
				{
					alarm_status= shm_nm_addr->alarm_switch_status.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET alarm_status : %u\n", __FILE__, __FUNCTION__, __LINE__, alarm_status);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &alarm_status, sizeof(alarm_status));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			alarm_status= *((unsigned int *)requests->requestvb->val.integer);
			
			if (shm_ipc_addr->mgr_printf[1])
			{
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION alarm_status : %u\n", __FILE__, __FUNCTION__, __LINE__, alarm_status);
			}
			sem_nm_p();
			shm_nm_addr->alarm_switch_status.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
				
			send_local_nm_set_cmd(CMD_CODE_ALARM_SWITCH, (unsigned char *)&alarm_status);
				
			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->alarm_switch_status.ack_flag)
				{
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_alarmSwitchStatus\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}








int
handle_closeTranThreshold(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info   *reqinfo,
                       netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int threshold = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->close_transmit_threshold.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_CLOSE_TRAN_THRESHOLD);
			
			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->close_transmit_threshold.ack_flag)
				{
					threshold= shm_nm_addr->close_transmit_threshold.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET close_transmit_threshold : %u\n", __FILE__, __FUNCTION__, __LINE__,threshold);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &threshold, sizeof(threshold));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			threshold= *((unsigned int *)requests->requestvb->val.integer);
			
			if (shm_ipc_addr->mgr_printf[1])
			{
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION close_transmit_threshold  : %u\n", __FILE__, __FUNCTION__, __LINE__, threshold);
			}
			sem_nm_p();
			shm_nm_addr->close_transmit_threshold.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
				
			send_local_nm_set_cmd(CMD_CODE_CLOSE_TRAN_THRESHOLD, (unsigned char *)&threshold);
				
			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->close_transmit_threshold.ack_flag)
				{
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_closeTranThreshold\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}












int
handle_resumeTranThreshold(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info   *reqinfo,
                       netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int threshold = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->resume_transmit_threshold.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_RESUME_TRAN_THRESHOLD);
			
			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->resume_transmit_threshold.ack_flag)
				{
					threshold= shm_nm_addr->resume_transmit_threshold.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET resume_transmit_threshold : %u\n", __FILE__, __FUNCTION__, __LINE__,threshold);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &threshold, sizeof(threshold));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			threshold= *((unsigned int *)requests->requestvb->val.integer);
			
			if (shm_ipc_addr->mgr_printf[1])
			{
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION resume_transmit_threshold  : %u\n", __FILE__, __FUNCTION__, __LINE__, threshold);
			}
			sem_nm_p();
			shm_nm_addr->resume_transmit_threshold.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
				
			send_local_nm_set_cmd(CMD_CODE_RESUME_TRAN_THRESHOLD, (unsigned char *)&threshold);
				
			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->resume_transmit_threshold.ack_flag)
				{
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_resumeTranThreshold\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}





int
handle_tempAlarmStartThreshold(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info   *reqinfo,
                       netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int threshold = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->tempratue_alarm_start_threshold.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_START_TEMP_ALARM);
			
			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->tempratue_alarm_start_threshold.ack_flag)
				{
					threshold= shm_nm_addr->tempratue_alarm_start_threshold.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET tempratue_alarm_start_threshold : %u\n", __FILE__, __FUNCTION__, __LINE__,threshold);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &threshold, sizeof(threshold));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			threshold= *((unsigned int *)requests->requestvb->val.integer);
			
			if (shm_ipc_addr->mgr_printf[1])
			{
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION tempratue_alarm_start_threshold  : %u\n", __FILE__, __FUNCTION__, __LINE__, threshold);
			}
			sem_nm_p();
			shm_nm_addr->tempratue_alarm_start_threshold.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
				
			send_local_nm_set_cmd(CMD_CODE_START_TEMP_ALARM, (unsigned char *)&threshold);
				
			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->tempratue_alarm_start_threshold.ack_flag)
				{
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_tempAlarmStartThreshold\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}









int
handle_tempAlarmCloseThreshold(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info   *reqinfo,
                       netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int threshold = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->tempratue_alarm_close_threshold.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_CLOSE_TEMP_ALARM);
			
			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->tempratue_alarm_close_threshold.ack_flag)
				{
					threshold= shm_nm_addr->tempratue_alarm_close_threshold.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET tempratue_alarm_close_threshold : %u\n", __FILE__, __FUNCTION__, __LINE__,threshold);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &threshold, sizeof(threshold));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			threshold= *((unsigned int *)requests->requestvb->val.integer);
			
			if (shm_ipc_addr->mgr_printf[1])
			{
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION tempratue_alarm_close_threshold  : %u\n", __FILE__, __FUNCTION__, __LINE__, threshold);
			}
			sem_nm_p();
			shm_nm_addr->tempratue_alarm_close_threshold.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
				
			send_local_nm_set_cmd(CMD_CODE_CLOSE_TEMP_ALARM, (unsigned char *)&threshold);
				
			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->tempratue_alarm_close_threshold.ack_flag)
				{
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_tempAlarmCloseThreshold\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_version(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned char version[50];
	struct timeval delay; 
    int i;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->version.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
						
			send_local_nm_get_cmd(CMD_CODE_VERSION);
		    for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
	
				if (ACK_FLAG_OK ==shm_nm_addr->version.ack_flag)
				{   
				    memcpy(version,shm_nm_addr->version.data,sizeof(version));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET version : %s\n", __FILE__, __FUNCTION__, __LINE__, version);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, version, sizeof(version));
					break;
				}

			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
			break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy(version, requests->requestvb->val.string, sizeof(version));
			if (shm_ipc_addr->mgr_printf[1])
			{
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION version : %s\n", __FILE__, __FUNCTION__, __LINE__, version);
			}
			sem_nm_p();
			shm_nm_addr->version.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			
			send_local_nm_set_cmd(CMD_CODE_VERSION,version);			

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->version.ack_flag)
				{
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_version\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_fpgaVer(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned char fpga_version[50];
	struct timeval delay; 
    int i;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->fpga_version.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
						
			send_local_nm_get_cmd(CMD_CODE_FPGA_VERSION);
		    for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
	
				if (ACK_FLAG_OK ==shm_nm_addr->fpga_version.ack_flag)
				{   
				    memcpy(fpga_version,shm_nm_addr->fpga_version.data,sizeof(fpga_version));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET fpga_version : %s\n", __FILE__, __FUNCTION__, __LINE__, fpga_version);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, fpga_version, sizeof(fpga_version));
					break;
				}

			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
			break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy(fpga_version, requests->requestvb->val.string, sizeof(fpga_version));
			if (shm_ipc_addr->mgr_printf[1])
			{
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION fpga_version : %s\n", __FILE__, __FUNCTION__, __LINE__, fpga_version);
			}
			sem_nm_p();
			shm_nm_addr->fpga_version.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			send_local_nm_set_cmd(CMD_CODE_FPGA_VERSION,fpga_version);

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->fpga_version.ack_flag)
				{
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fpgaVer\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_terminalCc(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info   *reqinfo,
                       netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int terminal_cc = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->terminal_cc.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_TERMINAL_CC);
			
			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->terminal_cc.ack_flag)
				{
					terminal_cc= shm_nm_addr->terminal_cc.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET terminal_cc : %u\n", __FILE__, __FUNCTION__, __LINE__, terminal_cc);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &terminal_cc, sizeof(terminal_cc));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			terminal_cc= *((unsigned int *)requests->requestvb->val.integer);
			if((terminal_cc<MIN_CC)||(terminal_cc>MAX_CC))
			{
			    printf("set terminal_cc=%d not in 0~15\n",terminal_cc);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION terminal_cc : %u\n", __FILE__, __FUNCTION__, __LINE__, terminal_cc);
				}
				sem_nm_p();
				shm_nm_addr->terminal_cc.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				send_local_nm_set_cmd(CMD_CODE_TERMINAL_CC, (unsigned char *)&terminal_cc);
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->terminal_cc.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_terminalCc\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



int
handle_protocolMode(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info   *reqinfo,
                       netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int protocol_mode = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->protocol_mode.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_PROTOCOL_MODE);
			
			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->protocol_mode.ack_flag)
				{
					protocol_mode= shm_nm_addr->protocol_mode.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET protocol_mode : %u\n", __FILE__, __FUNCTION__, __LINE__, protocol_mode);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &protocol_mode, sizeof(protocol_mode));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			protocol_mode= *((unsigned int *)requests->requestvb->val.integer);
			if((protocol_mode<0)||(protocol_mode>1))
			{
			    printf("set protocol_mode=%d not in 0,1\n",protocol_mode);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION protocol_mode : %u\n", __FILE__, __FUNCTION__, __LINE__, protocol_mode);
				}
				sem_nm_p();
				shm_nm_addr->protocol_mode.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				send_local_nm_set_cmd(CMD_CODE_PROTOCOL_MODE, (unsigned char *)&protocol_mode);
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->protocol_mode.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_protocolMode\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



int
handle_airSubNetid(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info   *reqinfo,
                       netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int air_subnet_id = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->air_subnet_id.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_AIR_SUBNET_ID);
			
			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->air_subnet_id.ack_flag)
				{
					air_subnet_id= shm_nm_addr->air_subnet_id.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET air_subnet_id : %u\n", __FILE__, __FUNCTION__, __LINE__, air_subnet_id);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &air_subnet_id, sizeof(air_subnet_id));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			air_subnet_id= *((unsigned int *)requests->requestvb->val.integer);
			if((air_subnet_id<MIN_NETMASK_ID)||(air_subnet_id>MAX_NETMASK_ID))
			{
			    printf("set air_subnet_id=%d not in 0~255\n",air_subnet_id);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION air_subnet_id : %u\n", __FILE__, __FUNCTION__, __LINE__, air_subnet_id);
				}
				sem_nm_p();
				shm_nm_addr->air_subnet_id.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				send_local_nm_set_cmd(CMD_CODE_AIR_SUBNET_ID, (unsigned char *)&air_subnet_id);
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->air_subnet_id.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_airSubNetid\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_workTimeout(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info   *reqinfo,
                       netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int work_time_out = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->work_time_out.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_WORK_TIME_OUT);
			
			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->work_time_out.ack_flag)
				{
					work_time_out= shm_nm_addr->work_time_out.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET work_time_out : %u\n", __FILE__, __FUNCTION__, __LINE__, work_time_out);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &work_time_out, sizeof(work_time_out));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			work_time_out= *((unsigned int *)requests->requestvb->val.integer);
			if((work_time_out<MIN_TIMEOUT)||(work_time_out>MAX_TIMEOUT))
			{
			    printf("set work_time_out=%d not in 0~65535\n",work_time_out);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION work_time_out : %u\n", __FILE__, __FUNCTION__, __LINE__,work_time_out);
				}
				sem_nm_p();
				shm_nm_addr->work_time_out.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				send_local_nm_set_cmd(CMD_CODE_WORK_TIME_OUT, (unsigned char *)&work_time_out);
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->work_time_out.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_workTimeout\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}





int
handle_gpsTimeout(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info   *reqinfo,
                       netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int gps_time_out = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->gps_time_out.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_GPS_TIME_OUT);
			
			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->gps_time_out.ack_flag)
				{
					gps_time_out= shm_nm_addr->gps_time_out.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET gps_time_out : %u\n", __FILE__, __FUNCTION__, __LINE__, gps_time_out);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &gps_time_out, sizeof(gps_time_out));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			gps_time_out= *((unsigned int *)requests->requestvb->val.integer);
			if((gps_time_out<MIN_TIMEOUT)||(gps_time_out>MAX_TIMEOUT))
			{
			    printf("set gps_time_out=%d not in 0~65535\n",gps_time_out);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION gps_time_out : %u\n", __FILE__, __FUNCTION__, __LINE__,gps_time_out);
				}
				sem_nm_p();
				shm_nm_addr->gps_time_out.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				send_local_nm_set_cmd(CMD_CODE_GPS_TIME_OUT, (unsigned char *)&gps_time_out);
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->gps_time_out.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_gpsTimeout\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}








int
handle_stunTimeout(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info   *reqinfo,
                       netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int stun_time_out = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->stun_time_out.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_STUN_TIME_OUT);
			
			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->stun_time_out.ack_flag)
				{
					stun_time_out= shm_nm_addr->stun_time_out.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET stun_time_out : %u\n", __FILE__, __FUNCTION__, __LINE__, stun_time_out);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &stun_time_out, sizeof(stun_time_out));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			stun_time_out= *((unsigned int *)requests->requestvb->val.integer);
			if((stun_time_out<MIN_TIMEOUT)||(stun_time_out>MAX_TIMEOUT))
			{
			    printf("set stun_time_out=%d not in 0~65535\n",stun_time_out);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION stun_time_out : %u\n", __FILE__, __FUNCTION__, __LINE__,stun_time_out);
				}
				sem_nm_p();
				shm_nm_addr->stun_time_out.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				send_local_nm_set_cmd(CMD_CODE_STUN_TIME_OUT, (unsigned char *)&stun_time_out);
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->stun_time_out.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_stunTimeout\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}







int
handle_startTimeout(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info   *reqinfo,
                       netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int start_time_out = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->start_time_out.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_START_TIME_OUT);
			
			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_time_out.ack_flag)
				{
					start_time_out= shm_nm_addr->start_time_out.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET start_time_out : %u\n", __FILE__, __FUNCTION__, __LINE__, start_time_out);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &start_time_out, sizeof(start_time_out));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			start_time_out= *((unsigned int *)requests->requestvb->val.integer);
			if((start_time_out<MIN_TIMEOUT)||(start_time_out>MAX_TIMEOUT))
			{
			    printf("set start_time_out=%d not in 0~65535\n",start_time_out);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION start_time_out : %u\n", __FILE__, __FUNCTION__, __LINE__,start_time_out);
				}
				sem_nm_p();
				shm_nm_addr->start_time_out.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				send_local_nm_set_cmd(CMD_CODE_START_TIME_OUT, (unsigned char *)&start_time_out);
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->start_time_out.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_startTimeout\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_localIp(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned char local_ip[50];
	struct timeval delay; 
    int i;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->local_ip.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
						
			send_local_nm_get_cmd(CMD_CODE_LOCAL_IP);
		    for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
	
				if (ACK_FLAG_OK ==shm_nm_addr->local_ip.ack_flag)
				{
	                memset(local_ip,0,sizeof(local_ip));			
				    memcpy(local_ip,shm_nm_addr->local_ip.data,sizeof(local_ip));
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, local_ip, sizeof(local_ip));
					break;
				}

			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
			break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memset(local_ip,0,sizeof(local_ip));
			memcpy(local_ip, requests->requestvb->val.string, sizeof(local_ip));
			sem_nm_p();
			shm_nm_addr->local_ip.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			
			send_local_nm_set_cmd(CMD_CODE_LOCAL_IP,local_ip);			

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->local_ip.ack_flag)
				{
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_localIp\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}











int
handle_localMac(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned char local_mac[6];
	unsigned char test[50];
	struct timeval delay; 
    int i;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->local_mac.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
						
			send_local_nm_get_cmd(CMD_CODE_LOCAL_MAC);
		    for (i = 0; i <timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
	
				if (ACK_FLAG_OK ==shm_nm_addr->local_mac.ack_flag)
				{   
				    memcpy(local_mac,shm_nm_addr->local_mac.data,sizeof(local_mac));
					if (shm_ipc_addr->mgr_printf[1])
					{
					    sprintf(test,"%x:%x:%x:%x:%x:%x",local_mac[0],local_mac[1],local_mac[2],local_mac[3],local_mac[4],local_mac[5]);
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET local_mac : %s\n", __FILE__, __FUNCTION__, __LINE__, test);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, local_mac, sizeof(local_mac));
					break;
				}

			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
			break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy(local_mac, requests->requestvb->val.string, sizeof(local_mac));
			if (shm_ipc_addr->mgr_printf[1])
			{
			    sprintf(test,"%x:%x:%x:%x:%x:%x",local_mac[0],local_mac[1],local_mac[2],local_mac[3],local_mac[4],local_mac[5]);
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION local_mac : %s\n", __FILE__, __FUNCTION__, __LINE__, test);
			}
			sem_nm_p();
			shm_nm_addr->local_mac.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			
			send_local_nm_set_cmd(CMD_CODE_LOCAL_MAC,local_mac);			

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->local_mac.ack_flag)
				{
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_localMac\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_emissiveVCOFreq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->emissive_vco_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_EMISSIVE_VCO_FREQ);
			
			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->emissive_vco_freq.ack_flag)
				{
					freq = shm_nm_addr->emissive_vco_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if (shm_ipc_addr->mgr_printf[1])
			{
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
			}
			sem_nm_p();
			shm_nm_addr->emissive_vco_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			send_local_nm_set_cmd(CMD_CODE_EMISSIVE_VCO_FREQ, (unsigned char *)&freq);

			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->emissive_vco_freq.ack_flag)
				{
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_emissiveVCOFreq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_receivingVCOFreq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->receiving_vco_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_RECEIVING_VCO_FREQ);
			
			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->receiving_vco_freq.ack_flag)
				{
					freq = shm_nm_addr->receiving_vco_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if (shm_ipc_addr->mgr_printf[1])
			{
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
			}
			sem_nm_p();
			shm_nm_addr->receiving_vco_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			send_local_nm_set_cmd(CMD_CODE_RECEIVING_VCO_FREQ, (unsigned char *)&freq);

			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->receiving_vco_freq.ack_flag)
				{
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_receivingVCOFreq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_secondLocalOscillatorFreq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 

    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->second_local_oscillator.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_SECOND_LOCAL_OSCILLATOR);
			
			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->second_local_oscillator.ack_flag)
				{
					freq = shm_nm_addr->second_local_oscillator.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if (shm_ipc_addr->mgr_printf[1])
			{
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
			}
			sem_nm_p();
			shm_nm_addr->second_local_oscillator.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			send_local_nm_set_cmd(CMD_CODE_SECOND_LOCAL_OSCILLATOR, (unsigned char *)&freq);

			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->second_local_oscillator.ack_flag)
				{
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_secondLocalOscillatorFreq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_powerAmplifierSwitch(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int power_switch = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            power_switch = *((unsigned int *)requests->requestvb->val.integer);
			if (shm_ipc_addr->mgr_printf[1])
			{
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION power_switch : %u\n", __FILE__, __FUNCTION__, __LINE__, power_switch);
			}
			sem_nm_p();
			shm_nm_addr->power_amplifier_switch.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			send_local_nm_set_cmd(CMD_CODE_POWER_AMPLIFIER_SWITCH, (unsigned char *)&power_switch);

			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->power_amplifier_switch.ack_flag)
				{
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_powerAmplifierSwitch\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



int
handle_saveIqData(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int data_switch = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            data_switch = *((unsigned int *)requests->requestvb->val.integer);
			if (shm_ipc_addr->mgr_printf[1])
			{
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION iq_data_switch : %u\n", __FILE__, __FUNCTION__, __LINE__, data_switch);
			}
			sem_nm_p();
			shm_nm_addr->save_iq_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			send_local_nm_set_cmd(CMD_CODE_SAVE_IQ_DATA, (unsigned char *)&data_switch);

			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->save_iq_data.ack_flag)
				{
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_powerAmplifierSwitch\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_fpgaParam(netsnmp_mib_handler *handler,
                              netsnmp_handler_registration *reginfo,
                              netsnmp_agent_request_info   *reqinfo,
                              netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned char fpga_param[244] = {0};
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->fpga_param.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_FPGA_PARAM);
			
			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->fpga_param.ack_flag)
				{
					memcpy(fpga_param, shm_nm_addr->fpga_param.data, sizeof(fpga_param));
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, fpga_param, sizeof(fpga_param));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_fpgaParam\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_power(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info   *reqinfo,
                       netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int power = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_POWER);
			
			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->power.ack_flag)
				{
					power = shm_nm_addr->power.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &power, sizeof(power));
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			power = *((unsigned int *)requests->requestvb->val.integer);
			if (shm_ipc_addr->mgr_printf[1])
			{
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION power : %u\n", __FILE__, __FUNCTION__, __LINE__, power);
			}
			sem_nm_p();
			shm_nm_addr->power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			send_local_nm_set_cmd(CMD_CODE_POWER, (unsigned char *)&power);

			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->power.ack_flag)
				{
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_power\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_debugEmissiveFreq(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int freq = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->debug_emissive_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_DEBUG_EMISSIVE_FREQ);
			
			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->debug_emissive_freq.ack_flag)
				{
					freq = shm_nm_addr->debug_emissive_freq.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &freq, sizeof(freq));
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			freq = *((unsigned int *)requests->requestvb->val.integer);
			if (shm_ipc_addr->mgr_printf[1])
			{
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION freq : %u\n", __FILE__, __FUNCTION__, __LINE__, freq);
			}
			sem_nm_p();
			shm_nm_addr->debug_emissive_freq.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			send_local_nm_set_cmd(CMD_CODE_DEBUG_EMISSIVE_FREQ, (unsigned char *)&freq);

			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->debug_emissive_freq.ack_flag)
				{
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_debugEmissiveFreq\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_afc(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info   *reqinfo,
                       netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int afc = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->afc.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_AFC);
			
			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->afc.ack_flag)
				{
					afc = shm_nm_addr->afc.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET afc : %u\n", __FILE__, __FUNCTION__, __LINE__, afc);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &afc, sizeof(afc));
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			afc = *((unsigned int *)requests->requestvb->val.integer);
			if (shm_ipc_addr->mgr_printf[1])
			{
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION afc : %u\n", __FILE__, __FUNCTION__, __LINE__, afc);
			}
			sem_nm_p();
			shm_nm_addr->afc.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			send_local_nm_set_cmd(CMD_CODE_AFC, (unsigned char *)&afc);

			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->afc.ack_flag)
				{
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_afc\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_saveAFC(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int save_afc = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			save_afc = *((unsigned int *)requests->requestvb->val.integer);
			if (shm_ipc_addr->mgr_printf[1])
			{
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION save_afc : %u\n", __FILE__, __FUNCTION__, __LINE__, save_afc);
			}
			sem_nm_p();
			shm_nm_addr->save_afc.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			send_local_nm_set_cmd(CMD_CODE_SAVE_AFC, (unsigned char *)&save_afc);

			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->save_afc.ack_flag)
				{
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_saveAFC\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_iqs(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info   *reqinfo,
                       netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int iqs = 0;
	struct timeval delay; 

    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->iqs.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_IQS);
			
			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->iqs.ack_flag)
				{
					iqs = shm_nm_addr->iqs.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET iqs : %u\n", __FILE__, __FUNCTION__, __LINE__, iqs);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &iqs, sizeof(iqs));
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			iqs = *((unsigned int *)requests->requestvb->val.integer);
			if (shm_ipc_addr->mgr_printf[1])
			{
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION iqs : %u\n", __FILE__, __FUNCTION__, __LINE__, iqs);
			}
			sem_nm_p();
			shm_nm_addr->iqs.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			send_local_nm_set_cmd(CMD_CODE_IQS, (unsigned char *)&iqs);

			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->iqs.ack_flag)
				{
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_iqs\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_saveIQS(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	int i = 0;
	unsigned char iqs[8] = {0};
	unsigned int save_id = 0;
	unsigned int save_val = 0;
	struct timeval delay; 

    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy(iqs, requests->requestvb->val.string, sizeof(iqs));
			if (shm_ipc_addr->mgr_printf[1])
			{
				memcpy((unsigned char *)&save_id, iqs, sizeof(unsigned int));
				memcpy((unsigned char *)&save_val, iqs + sizeof(unsigned int), sizeof(unsigned int));
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION save_id : %u, save_val : %u\n", __FILE__, __FUNCTION__, __LINE__, save_id, save_val);
			}
			sem_nm_p();
			shm_nm_addr->save_iqs.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			send_local_nm_set_cmd(CMD_CODE_SAVE_IQS, iqs);

			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->save_iqs.ack_flag)
				{
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_saveIQS\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_savePower(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	int i = 0;
	unsigned char power[8] = {0};
	unsigned int save_id = 0;
	unsigned int save_val = 0;
	struct timeval delay; 

    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy(power, requests->requestvb->val.string, sizeof(power));
			if (shm_ipc_addr->mgr_printf[1])
			{
				memcpy((unsigned char *)&save_id, power, sizeof(unsigned int));
				memcpy((unsigned char *)&save_val, power + sizeof(unsigned int), sizeof(unsigned int));
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION save_id : %u, save_val : %u\n", __FILE__, __FUNCTION__, __LINE__, save_id, save_val);
			}
			sem_nm_p();
			shm_nm_addr->save_power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			send_local_nm_set_cmd(CMD_CODE_SAVE_POWER, power);

			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->save_power.ack_flag)
				{
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_savePower\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_offset(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info   *reqinfo,
                       netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int offset = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->offset.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_OFFSET);
			
			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->offset.ack_flag)
				{
					offset = shm_nm_addr->offset.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET offset : %u\n", __FILE__, __FUNCTION__, __LINE__, offset);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &offset, sizeof(offset));
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			offset = *((unsigned int *)requests->requestvb->val.integer);
			if (shm_ipc_addr->mgr_printf[1])
			{
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION offset : %u\n", __FILE__, __FUNCTION__, __LINE__, offset);
			}
			sem_nm_p();
			shm_nm_addr->offset.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			send_local_nm_set_cmd(CMD_CODE_OFFSET, (unsigned char *)&offset);

			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->offset.ack_flag)
				{
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_offset\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_saveOffset(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned char offset[8] = {0};
	unsigned int save_id = 0;
	unsigned int save_val = 0;
	struct timeval delay; 

    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy(offset, requests->requestvb->val.string, sizeof(offset));
			if (shm_ipc_addr->mgr_printf[1])
			{
				memcpy((unsigned char *)&save_id, offset, sizeof(unsigned int));
				memcpy((unsigned char *)&save_val, offset + sizeof(unsigned int), sizeof(unsigned int));
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION save_id : %u, save_val : %u\n", __FILE__, __FUNCTION__, __LINE__, save_id, save_val);
			}
			sem_nm_p();
			shm_nm_addr->save_offset.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			send_local_nm_set_cmd(CMD_CODE_SAVE_OFFSET, offset);

			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->save_offset.ack_flag)
				{
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_saveOffset\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_calibrateOffset(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info   *reqinfo,
                       netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int calibrate_offset = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->calibrate_offset.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_CALIBRATE_OFFSET);
			
			for (i = 0; i < (CALIBRATE_DELAY / POLLING_INTERVA); i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->calibrate_offset.ack_flag)
				{
					calibrate_offset = shm_nm_addr->calibrate_offset.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET calibrate_offset : %u\n", __FILE__, __FUNCTION__, __LINE__, calibrate_offset);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &calibrate_offset, sizeof(calibrate_offset));
					break;
				}
			}
			if (i == (CALIBRATE_DELAY / POLLING_INTERVA))
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			calibrate_offset = *((unsigned int *)requests->requestvb->val.integer);
			if (shm_ipc_addr->mgr_printf[1])
			{
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION calibrate_offset : %u\n", __FILE__, __FUNCTION__, __LINE__, calibrate_offset);
			}
			sem_nm_p();
			shm_nm_addr->calibrate_offset.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			send_local_nm_set_cmd(CMD_CODE_CALIBRATE_OFFSET, (unsigned char *)&calibrate_offset);

			for (i = 0; i < (CALIBRATE_DELAY / POLLING_INTERVA); i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->calibrate_offset.ack_flag)
				{
					break;
				}
			}
			if (i == (CALIBRATE_DELAY / POLLING_INTERVA))
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_calibrateOffset\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_phase(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info   *reqinfo,
                       netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int phase = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->phase.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_PHASE);
			
			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->phase.ack_flag)
				{
					phase = shm_nm_addr->phase.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET phase : %u\n", __FILE__, __FUNCTION__, __LINE__, phase);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &phase, sizeof(phase));
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			phase = *((unsigned int *)requests->requestvb->val.integer);
			if (shm_ipc_addr->mgr_printf[1])
			{
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION phase : %u\n", __FILE__, __FUNCTION__, __LINE__, phase);
			}
			sem_nm_p();
			shm_nm_addr->phase.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			send_local_nm_set_cmd(CMD_CODE_PHASE, (unsigned char *)&phase);

			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->phase.ack_flag)
				{
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_phase\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_savePhase(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned char phase[8] = {0};
	unsigned int save_id = 0;
	unsigned int save_val = 0;
	struct timeval delay; 

    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy(phase, requests->requestvb->val.string, sizeof(phase));
			if (shm_ipc_addr->mgr_printf[1])
			{
				memcpy((unsigned char *)&save_id, phase, sizeof(unsigned int));
				memcpy((unsigned char *)&save_val, phase + sizeof(unsigned int), sizeof(unsigned int));
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION save_id : %u, save_val : %u\n", __FILE__, __FUNCTION__, __LINE__, save_id, save_val);
			}
			sem_nm_p();
			shm_nm_addr->save_phase.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			send_local_nm_set_cmd(CMD_CODE_SAVE_PHASE, phase);

			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->save_phase.ack_flag)
				{
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_savePhase\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_calibratePhase(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info   *reqinfo,
                       netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int calibrate_phase = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->calibrate_phase.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_CALIBRATE_PHASE);
			
			for (i = 0; i < CALIBRATE_PHASE_DELAY / POLLING_INTERVA; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->calibrate_phase.ack_flag)
				{
					calibrate_phase = shm_nm_addr->calibrate_phase.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET calibrate_phase : %u\n", __FILE__, __FUNCTION__, __LINE__, calibrate_phase);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &calibrate_phase, sizeof(calibrate_phase));
					break;
				}
			}
			if (i == (CALIBRATE_PHASE_DELAY / POLLING_INTERVA))
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			calibrate_phase = *((unsigned int *)requests->requestvb->val.integer);
			if (shm_ipc_addr->mgr_printf[1])
			{
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION calibrate_phase : %u\n", __FILE__, __FUNCTION__, __LINE__, calibrate_phase);
			}
			sem_nm_p();
			shm_nm_addr->calibrate_phase.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			send_local_nm_set_cmd(CMD_CODE_CALIBRATE_PHASE, (unsigned char *)&calibrate_phase);

			for (i = 0; i < CALIBRATE_PHASE_DELAY / POLLING_INTERVA; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->calibrate_phase.ack_flag)
				{
					break;
				}
			}
			if (i == (CALIBRATE_PHASE_DELAY / POLLING_INTERVA))
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_calibratePhase\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_errorRate(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info   *reqinfo,
                       netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int error_rate = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->error_rate.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_ERROR_RATE);
			
			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->error_rate.ack_flag)
				{
					error_rate = shm_nm_addr->error_rate.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET error_rate : %u\n", __FILE__, __FUNCTION__, __LINE__, error_rate);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &error_rate, sizeof(error_rate));
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_errorRate\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_printMark(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	int ret;
	unsigned int print_mark = 0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_ipc_p();
			print_mark = shm_ipc_addr->mgr_printf[1];
			sem_ipc_v();
			snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &print_mark, sizeof(print_mark));
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			print_mark = *((unsigned int *)requests->requestvb->val.integer);
			if (shm_ipc_addr->mgr_printf[1])
			{
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION print_mark : %u\n", __FILE__, __FUNCTION__, __LINE__, print_mark);
			}
			sem_ipc_p();
			shm_ipc_addr->mgr_printf[1] = print_mark;
			sem_ipc_v();
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_printMark\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_connectCCFlag(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
	int ret;
	unsigned int connect_flag = 0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_ipc_p();
			connect_flag = shm_ipc_addr->is_connect_cc;
			sem_ipc_v();
			snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &connect_flag, sizeof(connect_flag));
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			connect_flag = *((unsigned int *)requests->requestvb->val.integer);
			if (shm_ipc_addr->mgr_printf[1])
			{
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION connect_flag : %u\n", __FILE__, __FUNCTION__, __LINE__, connect_flag);
			}
			sem_ipc_p();
			shm_ipc_addr->is_connect_cc = connect_flag;
			sem_ipc_v();
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_connectCCFlag\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_debugPower(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info   *reqinfo,
                       netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int debug_power = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->debug_power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_DEBUG_POWER);
			
			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->debug_power.ack_flag)
				{
					debug_power = shm_nm_addr->debug_power.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET debug_power : %u\n", __FILE__, __FUNCTION__, __LINE__, debug_power);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &debug_power, sizeof(debug_power));
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			debug_power = *((unsigned int *)requests->requestvb->val.integer);
			if (shm_ipc_addr->mgr_printf[1])
			{
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION debug_power : %u\n", __FILE__, __FUNCTION__, __LINE__, debug_power);
			}
			sem_nm_p();
			shm_nm_addr->debug_power.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			send_local_nm_set_cmd(CMD_CODE_DEBUG_POWER, (unsigned char *)&debug_power);

			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->debug_power.ack_flag)
				{
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_debugPower\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_debugOpenCloseLoop(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info   *reqinfo,
                       netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int debug_open_close_loop = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->debug_open_close_loop.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_DEBUG_OPEN_CLOSE_LOOP);
			
			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->debug_open_close_loop.ack_flag)
				{
					debug_open_close_loop = shm_nm_addr->debug_open_close_loop.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET debug_open_close_loop : %u\n", __FILE__, __FUNCTION__, __LINE__, debug_open_close_loop);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &debug_open_close_loop, sizeof(debug_open_close_loop));
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			debug_open_close_loop = *((unsigned int *)requests->requestvb->val.integer);
			if (shm_ipc_addr->mgr_printf[1])
			{
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION debug_open_close_loop : %u\n", __FILE__, __FUNCTION__, __LINE__, debug_open_close_loop);
			}
			sem_nm_p();
			shm_nm_addr->debug_open_close_loop.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			send_local_nm_set_cmd(CMD_CODE_DEBUG_OPEN_CLOSE_LOOP, (unsigned char *)&debug_open_close_loop);

			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->debug_open_close_loop.ack_flag)
				{
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_debugOpenCloseLoop\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_startDebug(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info   *reqinfo,
                       netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int start_debug = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->start_debug.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_START_DEBUG);
			
			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_debug.ack_flag)
				{
					start_debug = shm_nm_addr->start_debug.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET start_debug : %u\n", __FILE__, __FUNCTION__, __LINE__, start_debug);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &start_debug, sizeof(start_debug));
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			start_debug = *((unsigned int *)requests->requestvb->val.integer);
			if (shm_ipc_addr->mgr_printf[1])
			{
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION start_debug : %u\n", __FILE__, __FUNCTION__, __LINE__, start_debug);
			}
			sem_nm_p();
			shm_nm_addr->start_debug.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			send_local_nm_set_cmd(CMD_CODE_START_DEBUG, (unsigned char *)&start_debug);

			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_debug.ack_flag)
				{
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_startDebug\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_startErrorRate(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info   *reqinfo,
                       netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int start_error_rate = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->start_error_rate.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_START_ERR_RATE);
			
			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_error_rate.ack_flag)
				{
					start_error_rate = shm_nm_addr->start_error_rate.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET start_error_rate : %u\n", __FILE__, __FUNCTION__, __LINE__, start_error_rate);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &start_error_rate, sizeof(start_error_rate));
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			start_error_rate = *((unsigned int *)requests->requestvb->val.integer);
			if (shm_ipc_addr->mgr_printf[1])
			{
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION start_error_rate : %u\n", __FILE__, __FUNCTION__, __LINE__, start_error_rate);
			}
			sem_nm_p();
			shm_nm_addr->start_error_rate.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			send_local_nm_set_cmd(CMD_CODE_START_ERR_RATE, (unsigned char *)&start_error_rate);

			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_error_rate.ack_flag)
				{
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_startErrorRate\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_selectSignalSource(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int signal_source = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            signal_source = *((unsigned int *)requests->requestvb->val.integer);
			if (shm_ipc_addr->mgr_printf[1])
			{
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION signal_source : %u\n", __FILE__, __FUNCTION__, __LINE__, signal_source);
			}
			sem_nm_p();
			shm_nm_addr->select_signal_source.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			send_local_nm_set_cmd(CMD_CODE_SELECT_SIGNAL_SOURCE, (unsigned char *)&signal_source);

			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->select_signal_source.ack_flag)
				{
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_selectSignalSource\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_slotControl(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int slot_control = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            slot_control = *((unsigned int *)requests->requestvb->val.integer);
			if (shm_ipc_addr->mgr_printf[1])
			{
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION slot_control : %u\n", __FILE__, __FUNCTION__, __LINE__, slot_control);
			}
			sem_nm_p();
			shm_nm_addr->slot_control.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			send_local_nm_set_cmd(CMD_CODE_SLOT_CONTROL, (unsigned char *)&slot_control);

			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->slot_control.ack_flag)
				{
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_slotControl\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_vgs(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info   *reqinfo,
                       netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int vgs = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->vgs.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_get_cmd(CMD_CODE_VGS);
			
			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->vgs.ack_flag)
				{
					vgs = shm_nm_addr->vgs.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET vgs : %u\n", __FILE__, __FUNCTION__, __LINE__, vgs);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &vgs, sizeof(vgs));
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			vgs = *((unsigned int *)requests->requestvb->val.integer);
			if (shm_ipc_addr->mgr_printf[1])
			{
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION vgs : %u\n", __FILE__, __FUNCTION__, __LINE__, vgs);
			}
			sem_nm_p();
			shm_nm_addr->vgs.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			send_local_nm_set_cmd(CMD_CODE_VGS, (unsigned char *)&vgs);

			for (i = 0; i < debug_timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->vgs.ack_flag)
				{
					break;
				}
			}
			if (i == debug_timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_vgs\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_saveEeprom(netsnmp_mib_handler *handler,
                       netsnmp_handler_registration *reginfo,
                       netsnmp_agent_request_info   *reqinfo,
                       netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int save_flag = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			save_flag = *((unsigned int *)requests->requestvb->val.integer);
			if (shm_ipc_addr->mgr_printf[1])
			{
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION save_flag : %u\n", __FILE__, __FUNCTION__, __LINE__, save_flag);
			}
			sem_nm_p();
			shm_nm_addr->save_eeprom.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			send_local_nm_set_cmd(CMD_CODE_SAVE_EEPROM, (unsigned char *)&save_flag);

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->save_eeprom.ack_flag)
				{
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_vgs\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}







int
handle_id1StartNeighbor(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int startneighbor = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_1;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->start_neighbor.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_START_NEIGHBOR);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_START_NEIGHBOR, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
				{
					startneighbor= shm_nm_addr->start_neighbor.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &startneighbor, sizeof(startneighbor));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			startneighbor = *((unsigned int *)requests->requestvb->val.integer);
			if((startneighbor==0)||(startneighbor==1))
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
				}
				sem_nm_p();
				shm_nm_addr->start_neighbor.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_START_NEIGHBOR, (unsigned char *)&startneighbor);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_START_NEIGHBOR, this_id, (unsigned char *)&startneighbor);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set startneighbor=%d not in 0,1\n",startneighbor);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id1StartNeighbor\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



int
handle_id2StartNeighbor(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int startneighbor = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_2;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->start_neighbor.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_START_NEIGHBOR);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_START_NEIGHBOR, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
				{
					startneighbor= shm_nm_addr->start_neighbor.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &startneighbor, sizeof(startneighbor));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			startneighbor = *((unsigned int *)requests->requestvb->val.integer);
			if((startneighbor==0)||(startneighbor==1))
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
				}
				sem_nm_p();
				shm_nm_addr->start_neighbor.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_START_NEIGHBOR, (unsigned char *)&startneighbor);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_START_NEIGHBOR, this_id, (unsigned char *)&startneighbor);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set startneighbor=%d not in 0,1\n",startneighbor);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id2StartNeighbor\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



int
handle_id3StartNeighbor(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int startneighbor = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_3;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->start_neighbor.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_START_NEIGHBOR);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_START_NEIGHBOR, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
				{
					startneighbor= shm_nm_addr->start_neighbor.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &startneighbor, sizeof(startneighbor));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			startneighbor = *((unsigned int *)requests->requestvb->val.integer);
			if((startneighbor==0)||(startneighbor==1))
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
				}
				sem_nm_p();
				shm_nm_addr->start_neighbor.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_START_NEIGHBOR, (unsigned char *)&startneighbor);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_START_NEIGHBOR, this_id, (unsigned char *)&startneighbor);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set startneighbor=%d not in 0,1\n",startneighbor);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id3StartNeighbor\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id4StartNeighbor(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int startneighbor = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_4;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->start_neighbor.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_START_NEIGHBOR);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_START_NEIGHBOR, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
				{
					startneighbor= shm_nm_addr->start_neighbor.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &startneighbor, sizeof(startneighbor));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			startneighbor = *((unsigned int *)requests->requestvb->val.integer);
			if((startneighbor==0)||(startneighbor==1))
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
				}
				sem_nm_p();
				shm_nm_addr->start_neighbor.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_START_NEIGHBOR, (unsigned char *)&startneighbor);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_START_NEIGHBOR, this_id, (unsigned char *)&startneighbor);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set startneighbor=%d not in 0,1\n",startneighbor);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id4StartNeighbor\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id5StartNeighbor(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int startneighbor = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_5;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->start_neighbor.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_START_NEIGHBOR);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_START_NEIGHBOR, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
				{
					startneighbor= shm_nm_addr->start_neighbor.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &startneighbor, sizeof(startneighbor));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			startneighbor = *((unsigned int *)requests->requestvb->val.integer);
			if((startneighbor==0)||(startneighbor==1))
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
				}
				sem_nm_p();
				shm_nm_addr->start_neighbor.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_START_NEIGHBOR, (unsigned char *)&startneighbor);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_START_NEIGHBOR, this_id, (unsigned char *)&startneighbor);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set startneighbor=%d not in 0,1\n",startneighbor);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id5StartNeighbor\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id6StartNeighbor(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int startneighbor = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_6;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->start_neighbor.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_START_NEIGHBOR);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_START_NEIGHBOR, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
				{
					startneighbor= shm_nm_addr->start_neighbor.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &startneighbor, sizeof(startneighbor));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			startneighbor = *((unsigned int *)requests->requestvb->val.integer);
			if((startneighbor==0)||(startneighbor==1))
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
				}
				sem_nm_p();
				shm_nm_addr->start_neighbor.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_START_NEIGHBOR, (unsigned char *)&startneighbor);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_START_NEIGHBOR, this_id, (unsigned char *)&startneighbor);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set startneighbor=%d not in 0,1\n",startneighbor);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id6StartNeighbor\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}





int
handle_id7StartNeighbor(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int startneighbor = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_7;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->start_neighbor.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_START_NEIGHBOR);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_START_NEIGHBOR, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
				{
					startneighbor= shm_nm_addr->start_neighbor.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &startneighbor, sizeof(startneighbor));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			startneighbor = *((unsigned int *)requests->requestvb->val.integer);
			if((startneighbor==0)||(startneighbor==1))
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
				}
				sem_nm_p();
				shm_nm_addr->start_neighbor.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_START_NEIGHBOR, (unsigned char *)&startneighbor);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_START_NEIGHBOR, this_id, (unsigned char *)&startneighbor);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set startneighbor=%d not in 0,1\n",startneighbor);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id7StartNeighbor\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id8StartNeighbor(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int startneighbor = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_8;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->start_neighbor.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_START_NEIGHBOR);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_START_NEIGHBOR, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
				{
					startneighbor= shm_nm_addr->start_neighbor.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &startneighbor, sizeof(startneighbor));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			startneighbor = *((unsigned int *)requests->requestvb->val.integer);
			if((startneighbor==0)||(startneighbor==1))
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
				}
				sem_nm_p();
				shm_nm_addr->start_neighbor.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_START_NEIGHBOR, (unsigned char *)&startneighbor);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_START_NEIGHBOR, this_id, (unsigned char *)&startneighbor);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set startneighbor=%d not in 0,1\n",startneighbor);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id8StartNeighbor\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}





int
handle_id9StartNeighbor(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int startneighbor = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_9;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->start_neighbor.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_START_NEIGHBOR);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_START_NEIGHBOR, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
				{
					startneighbor= shm_nm_addr->start_neighbor.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &startneighbor, sizeof(startneighbor));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			startneighbor = *((unsigned int *)requests->requestvb->val.integer);
			if((startneighbor==0)||(startneighbor==1))
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
				}
				sem_nm_p();
				shm_nm_addr->start_neighbor.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_START_NEIGHBOR, (unsigned char *)&startneighbor);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_START_NEIGHBOR, this_id, (unsigned char *)&startneighbor);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set startneighbor=%d not in 0,1\n",startneighbor);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id9StartNeighbor\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id10StartNeighbor(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int startneighbor = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_10;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->start_neighbor.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_START_NEIGHBOR);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_START_NEIGHBOR, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
				{
					startneighbor= shm_nm_addr->start_neighbor.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &startneighbor, sizeof(startneighbor));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			startneighbor = *((unsigned int *)requests->requestvb->val.integer);
			if((startneighbor==0)||(startneighbor==1))
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
				}
				sem_nm_p();
				shm_nm_addr->start_neighbor.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_START_NEIGHBOR, (unsigned char *)&startneighbor);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_START_NEIGHBOR, this_id, (unsigned char *)&startneighbor);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set startneighbor=%d not in 0,1\n",startneighbor);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id10StartNeighbor\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



int
handle_id11StartNeighbor(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int startneighbor = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_11;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->start_neighbor.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_START_NEIGHBOR);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_START_NEIGHBOR, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
				{
					startneighbor= shm_nm_addr->start_neighbor.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &startneighbor, sizeof(startneighbor));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			startneighbor = *((unsigned int *)requests->requestvb->val.integer);
			if((startneighbor==0)||(startneighbor==1))
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
				}
				sem_nm_p();
				shm_nm_addr->start_neighbor.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_START_NEIGHBOR, (unsigned char *)&startneighbor);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_START_NEIGHBOR, this_id, (unsigned char *)&startneighbor);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set startneighbor=%d not in 0,1\n",startneighbor);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id11StartNeighbor\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



int
handle_id12StartNeighbor(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int startneighbor = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_12;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->start_neighbor.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_START_NEIGHBOR);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_START_NEIGHBOR, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
				{
					startneighbor= shm_nm_addr->start_neighbor.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &startneighbor, sizeof(startneighbor));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			startneighbor = *((unsigned int *)requests->requestvb->val.integer);
			if((startneighbor==0)||(startneighbor==1))
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
				}
				sem_nm_p();
				shm_nm_addr->start_neighbor.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_START_NEIGHBOR, (unsigned char *)&startneighbor);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_START_NEIGHBOR, this_id, (unsigned char *)&startneighbor);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set startneighbor=%d not in 0,1\n",startneighbor);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id12StartNeighbor\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



int
handle_id13StartNeighbor(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int startneighbor = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_13;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->start_neighbor.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_START_NEIGHBOR);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_START_NEIGHBOR, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
				{
					startneighbor= shm_nm_addr->start_neighbor.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &startneighbor, sizeof(startneighbor));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			startneighbor = *((unsigned int *)requests->requestvb->val.integer);
			if((startneighbor==0)||(startneighbor==1))
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
				}
				sem_nm_p();
				shm_nm_addr->start_neighbor.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_START_NEIGHBOR, (unsigned char *)&startneighbor);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_START_NEIGHBOR, this_id, (unsigned char *)&startneighbor);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set startneighbor=%d not in 0,1\n",startneighbor);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id13StartNeighbor\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id14StartNeighbor(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int startneighbor = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_14;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->start_neighbor.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_START_NEIGHBOR);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_START_NEIGHBOR, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
				{
					startneighbor= shm_nm_addr->start_neighbor.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &startneighbor, sizeof(startneighbor));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			startneighbor = *((unsigned int *)requests->requestvb->val.integer);
			if((startneighbor==0)||(startneighbor==1))
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
				}
				sem_nm_p();
				shm_nm_addr->start_neighbor.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_START_NEIGHBOR, (unsigned char *)&startneighbor);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_START_NEIGHBOR, this_id, (unsigned char *)&startneighbor);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set startneighbor=%d not in 0,1\n",startneighbor);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id14StartNeighbor\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id15StartNeighbor(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int startneighbor = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_15;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->start_neighbor.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_START_NEIGHBOR);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_START_NEIGHBOR, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
				{
					startneighbor= shm_nm_addr->start_neighbor.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &startneighbor, sizeof(startneighbor));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			startneighbor = *((unsigned int *)requests->requestvb->val.integer);
			if((startneighbor==0)||(startneighbor==1))
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
				}
				sem_nm_p();
				shm_nm_addr->start_neighbor.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_START_NEIGHBOR, (unsigned char *)&startneighbor);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_START_NEIGHBOR, this_id, (unsigned char *)&startneighbor);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set startneighbor=%d not in 0,1\n",startneighbor);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id15StartNeighbor\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id16StartNeighbor(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int startneighbor = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_16;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->start_neighbor.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_START_NEIGHBOR);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_START_NEIGHBOR, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
				{
					startneighbor= shm_nm_addr->start_neighbor.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &startneighbor, sizeof(startneighbor));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			startneighbor = *((unsigned int *)requests->requestvb->val.integer);
			if((startneighbor==0)||(startneighbor==1))
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
				}
				sem_nm_p();
				shm_nm_addr->start_neighbor.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_START_NEIGHBOR, (unsigned char *)&startneighbor);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_START_NEIGHBOR, this_id, (unsigned char *)&startneighbor);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set startneighbor=%d not in 0,1\n",startneighbor);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id16StartNeighbor\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}





int
handle_id17StartNeighbor(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int startneighbor = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_17;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->start_neighbor.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_START_NEIGHBOR);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_START_NEIGHBOR, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
				{
					startneighbor= shm_nm_addr->start_neighbor.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &startneighbor, sizeof(startneighbor));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			startneighbor = *((unsigned int *)requests->requestvb->val.integer);
			if((startneighbor==0)||(startneighbor==1))
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
				}
				sem_nm_p();
				shm_nm_addr->start_neighbor.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_START_NEIGHBOR, (unsigned char *)&startneighbor);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_START_NEIGHBOR, this_id, (unsigned char *)&startneighbor);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set startneighbor=%d not in 0,1\n",startneighbor);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id17StartNeighbor\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id18StartNeighbor(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int startneighbor = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_18;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->start_neighbor.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_START_NEIGHBOR);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_START_NEIGHBOR, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
				{
					startneighbor= shm_nm_addr->start_neighbor.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &startneighbor, sizeof(startneighbor));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			startneighbor = *((unsigned int *)requests->requestvb->val.integer);
			if((startneighbor==0)||(startneighbor==1))
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
				}
				sem_nm_p();
				shm_nm_addr->start_neighbor.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_START_NEIGHBOR, (unsigned char *)&startneighbor);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_START_NEIGHBOR, this_id, (unsigned char *)&startneighbor);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set startneighbor=%d not in 0,1\n",startneighbor);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id18StartNeighbor\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}





int
handle_id19StartNeighbor(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int startneighbor = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_19;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->start_neighbor.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_START_NEIGHBOR);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_START_NEIGHBOR, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
				{
					startneighbor= shm_nm_addr->start_neighbor.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &startneighbor, sizeof(startneighbor));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			startneighbor = *((unsigned int *)requests->requestvb->val.integer);
			if((startneighbor==0)||(startneighbor==1))
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
				}
				sem_nm_p();
				shm_nm_addr->start_neighbor.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_START_NEIGHBOR, (unsigned char *)&startneighbor);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_START_NEIGHBOR, this_id, (unsigned char *)&startneighbor);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set startneighbor=%d not in 0,1\n",startneighbor);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id19StartNeighbor\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id20StartNeighbor(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int startneighbor = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_20;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->start_neighbor.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_START_NEIGHBOR);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_START_NEIGHBOR, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
				{
					startneighbor= shm_nm_addr->start_neighbor.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &startneighbor, sizeof(startneighbor));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			startneighbor = *((unsigned int *)requests->requestvb->val.integer);
			if((startneighbor==0)||(startneighbor==1))
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
				}
				sem_nm_p();
				shm_nm_addr->start_neighbor.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_START_NEIGHBOR, (unsigned char *)&startneighbor);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_START_NEIGHBOR, this_id, (unsigned char *)&startneighbor);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set startneighbor=%d not in 0,1\n",startneighbor);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id20StartNeighbor\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_id21StartNeighbor(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int startneighbor = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_21;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->start_neighbor.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_START_NEIGHBOR);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_START_NEIGHBOR, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
				{
					startneighbor= shm_nm_addr->start_neighbor.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &startneighbor, sizeof(startneighbor));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			startneighbor = *((unsigned int *)requests->requestvb->val.integer);
			if((startneighbor==0)||(startneighbor==1))
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
				}
				sem_nm_p();
				shm_nm_addr->start_neighbor.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_START_NEIGHBOR, (unsigned char *)&startneighbor);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_START_NEIGHBOR, this_id, (unsigned char *)&startneighbor);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set startneighbor=%d not in 0,1\n",startneighbor);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id21StartNeighbor\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



int
handle_id22StartNeighbor(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int startneighbor = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_22;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->start_neighbor.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_START_NEIGHBOR);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_START_NEIGHBOR, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
				{
					startneighbor= shm_nm_addr->start_neighbor.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &startneighbor, sizeof(startneighbor));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			startneighbor = *((unsigned int *)requests->requestvb->val.integer);
			if((startneighbor==0)||(startneighbor==1))
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
				}
				sem_nm_p();
				shm_nm_addr->start_neighbor.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_START_NEIGHBOR, (unsigned char *)&startneighbor);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_START_NEIGHBOR, this_id, (unsigned char *)&startneighbor);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set startneighbor=%d not in 0,1\n",startneighbor);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id22StartNeighbor\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



int
handle_id23StartNeighbor(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int startneighbor = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_23;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->start_neighbor.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_START_NEIGHBOR);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_START_NEIGHBOR, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
				{
					startneighbor= shm_nm_addr->start_neighbor.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &startneighbor, sizeof(startneighbor));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			startneighbor = *((unsigned int *)requests->requestvb->val.integer);
			if((startneighbor==0)||(startneighbor==1))
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
				}
				sem_nm_p();
				shm_nm_addr->start_neighbor.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_START_NEIGHBOR, (unsigned char *)&startneighbor);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_START_NEIGHBOR, this_id, (unsigned char *)&startneighbor);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set startneighbor=%d not in 0,1\n",startneighbor);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id23StartNeighbor\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id24StartNeighbor(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int startneighbor = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_24;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->start_neighbor.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_START_NEIGHBOR);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_START_NEIGHBOR, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
				{
					startneighbor= shm_nm_addr->start_neighbor.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &startneighbor, sizeof(startneighbor));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			startneighbor = *((unsigned int *)requests->requestvb->val.integer);
			if((startneighbor==0)||(startneighbor==1))
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
				}
				sem_nm_p();
				shm_nm_addr->start_neighbor.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_START_NEIGHBOR, (unsigned char *)&startneighbor);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_START_NEIGHBOR, this_id, (unsigned char *)&startneighbor);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set startneighbor=%d not in 0,1\n",startneighbor);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id24StartNeighbor\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id25StartNeighbor(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int startneighbor = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_25;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->start_neighbor.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_START_NEIGHBOR);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_START_NEIGHBOR, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
				{
					startneighbor= shm_nm_addr->start_neighbor.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &startneighbor, sizeof(startneighbor));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			startneighbor = *((unsigned int *)requests->requestvb->val.integer);
			if((startneighbor==0)||(startneighbor==1))
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
				}
				sem_nm_p();
				shm_nm_addr->start_neighbor.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_START_NEIGHBOR, (unsigned char *)&startneighbor);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_START_NEIGHBOR, this_id, (unsigned char *)&startneighbor);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set startneighbor=%d not in 0,1\n",startneighbor);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id25StartNeighbor\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id26StartNeighbor(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int startneighbor = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_26;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->start_neighbor.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_START_NEIGHBOR);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_START_NEIGHBOR, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
				{
					startneighbor= shm_nm_addr->start_neighbor.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &startneighbor, sizeof(startneighbor));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			startneighbor = *((unsigned int *)requests->requestvb->val.integer);
			if((startneighbor==0)||(startneighbor==1))
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
				}
				sem_nm_p();
				shm_nm_addr->start_neighbor.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_START_NEIGHBOR, (unsigned char *)&startneighbor);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_START_NEIGHBOR, this_id, (unsigned char *)&startneighbor);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set startneighbor=%d not in 0,1\n",startneighbor);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id26StartNeighbor\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}





int
handle_id27StartNeighbor(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int startneighbor = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_27;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->start_neighbor.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_START_NEIGHBOR);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_START_NEIGHBOR, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
				{
					startneighbor= shm_nm_addr->start_neighbor.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &startneighbor, sizeof(startneighbor));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			startneighbor = *((unsigned int *)requests->requestvb->val.integer);
			if((startneighbor==0)||(startneighbor==1))
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
				}
				sem_nm_p();
				shm_nm_addr->start_neighbor.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_START_NEIGHBOR, (unsigned char *)&startneighbor);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_START_NEIGHBOR, this_id, (unsigned char *)&startneighbor);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set startneighbor=%d not in 0,1\n",startneighbor);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id27StartNeighbor\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id28StartNeighbor(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int startneighbor = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_28;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->start_neighbor.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_START_NEIGHBOR);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_START_NEIGHBOR, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
				{
					startneighbor= shm_nm_addr->start_neighbor.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &startneighbor, sizeof(startneighbor));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			startneighbor = *((unsigned int *)requests->requestvb->val.integer);
			if((startneighbor==0)||(startneighbor==1))
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
				}
				sem_nm_p();
				shm_nm_addr->start_neighbor.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_START_NEIGHBOR, (unsigned char *)&startneighbor);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_START_NEIGHBOR, this_id, (unsigned char *)&startneighbor);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set startneighbor=%d not in 0,1\n",startneighbor);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id28StartNeighbor\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}





int
handle_id29StartNeighbor(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int startneighbor = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_29;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->start_neighbor.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_START_NEIGHBOR);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_START_NEIGHBOR, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
				{
					startneighbor= shm_nm_addr->start_neighbor.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &startneighbor, sizeof(startneighbor));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			startneighbor = *((unsigned int *)requests->requestvb->val.integer);
			if((startneighbor==0)||(startneighbor==1))
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
				}
				sem_nm_p();
				shm_nm_addr->start_neighbor.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_START_NEIGHBOR, (unsigned char *)&startneighbor);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_START_NEIGHBOR, this_id, (unsigned char *)&startneighbor);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set startneighbor=%d not in 0,1\n",startneighbor);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id29StartNeighbor\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id30StartNeighbor(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int startneighbor = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_30;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->start_neighbor.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_START_NEIGHBOR);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_START_NEIGHBOR, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
				{
					startneighbor= shm_nm_addr->start_neighbor.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &startneighbor, sizeof(startneighbor));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			startneighbor = *((unsigned int *)requests->requestvb->val.integer);
			if((startneighbor==0)||(startneighbor==1))
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
				}
				sem_nm_p();
				shm_nm_addr->start_neighbor.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_START_NEIGHBOR, (unsigned char *)&startneighbor);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_START_NEIGHBOR, this_id, (unsigned char *)&startneighbor);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set startneighbor=%d not in 0,1\n",startneighbor);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id30StartNeighbor\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}






int
handle_id31StartNeighbor(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int startneighbor = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_31;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->start_neighbor.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_START_NEIGHBOR);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_START_NEIGHBOR, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
				{
					startneighbor= shm_nm_addr->start_neighbor.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &startneighbor, sizeof(startneighbor));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			startneighbor = *((unsigned int *)requests->requestvb->val.integer);
			if((startneighbor==0)||(startneighbor==1))
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
				}
				sem_nm_p();
				shm_nm_addr->start_neighbor.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_START_NEIGHBOR, (unsigned char *)&startneighbor);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_START_NEIGHBOR, this_id, (unsigned char *)&startneighbor);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set startneighbor=%d not in 0,1\n",startneighbor);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id31StartNeighbor\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}






int
handle_id32StartNeighbor(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int startneighbor = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_32;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->start_neighbor.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_START_NEIGHBOR);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_START_NEIGHBOR, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
				{
					startneighbor= shm_nm_addr->start_neighbor.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &startneighbor, sizeof(startneighbor));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			startneighbor = *((unsigned int *)requests->requestvb->val.integer);
			if((startneighbor==0)||(startneighbor==1))
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION startneighbor : %u\n", __FILE__, __FUNCTION__, __LINE__, startneighbor);
				}
				sem_nm_p();
				shm_nm_addr->start_neighbor.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_START_NEIGHBOR, (unsigned char *)&startneighbor);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_START_NEIGHBOR, this_id, (unsigned char *)&startneighbor);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->start_neighbor.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
			else
			{
			    printf("set startneighbor=%d not in 0,1\n",startneighbor);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id32StartNeighbor\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}






int handle_updateData(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	struct timeval delay; 
	int status=0;
	char buffer_active[]="active\n";
	char buffer_back[]="back\n";
	int  file_type=0;
	unsigned char ip[50]={0};
	unsigned char file_name[50]={0};
	unsigned char data_packet[200]={0};
	unsigned char code[200]={0};
	char bz2_file_name[50] = {0};
	FILE * fd;
	unsigned int size;
	EEPROM_FPGA_PARAM  fpga_param;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			printf("start transmit file\n");
			memset(data_packet,0,sizeof(data_packet));
			memcpy(data_packet, requests->requestvb->val.string, sizeof(data_packet));
			file_type=data_packet[0];
			memset(ip,0,sizeof(ip));
			memcpy(ip,data_packet+3,data_packet[1]);
			memset(file_name,0,sizeof(file_name));
			memcpy(file_name,data_packet+3+data_packet[1],data_packet[2]);
		    memset(code,0,sizeof(code));
			sprintf(code, "tftp -gr %s %s", file_name, ip);
            switch(file_type) 
			{
					
				case UPDATE_LOADAPP:
					
		   		    if(confirm_mount_point())
		   			{
		   			    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);	   
		   			}
		   			status=system((const char *)code);
					if(test_code(status))
					{
					    system("rm -rf loadapp*");
		   			    chdir("/");
		   				system("umount /mnt");
		   		        printf("tftp failed!\n");
		   			    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
					}
					else
					{
					    memset(bz2_file_name,0,sizeof(bz2_file_name));
		       		    if (0 != bin_to_bz2(file_name, bz2_file_name))
		       			{
		       		        printf(" bin_to_bz2 failed!\n");
		   					system("rm -rf loadapp*");
		   				    chdir("/");
		       			    system("umount /mnt");
		       				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);	
		       			}
						else
						{
						    memset(code, 0, sizeof(code));
		       			    sprintf(code, "tar -jxf %s", bz2_file_name);
		       				status = system((const char *)code);
							if(test_code(status))
							{
							    printf("system tar return failed!\n");
		   						system("rm -rf loadapp*");
		   						chdir("/");
		       			        system("umount /mnt");
		       			        netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);	
							}
							else
							{
							    fd=fopen("/mnt/loadflag","wb");
		       
		                        if(fd == NULL)
		                        {
		                            printf("open /mnt/loadflag file error!\n");
		   							system("rm -rf loadapp*");
		   							chdir("/");
		       			            system("umount /mnt");
		       	                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
		        
		                        }
		                        size=strlen(buffer_active);
		                        fwrite(buffer_active,size,1,fd);
		                        fclose(fd);
		   						if(strcmp((char *)buffer,"/dev/mtdblock5\n")!=0)
		       	                {
		               
		       	                    fd=fopen("/loadapp/loadflag","wb");
		       
		                            if(fd == NULL)
		                            {
		                                printf("open /loadapp/loadflag file failed!\n");
		   							    system("rm -rf loadapp*");
		   								chdir("/");
		       			                system("umount /mnt");
		                                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
		                            }
		                            size=strlen(buffer_back);
		                            fwrite(buffer_back,size,1,fd);
		                            fclose(fd); 
		       	                 }
		   						 system("cp -rf /loadapp/nas_config.ini /mnt");
								 system("cp -rf /loadapp/ConfigFile     /mnt");
								 system("cp -rf /loadapp/config.ini /mnt");
		   					     printf("update loadapp  success\n");
		   					     system("rm -rf loadapp*");
		   						 chdir("/");
		       			         system("umount /mnt");
							}
						}
					}
			        break;
				case UPDATE_DTB:
					chdir("/home");
					status=system((const char *)code);
					if(test_code(status))
					{
					    printf("tftp failed!\n");
		   			    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
					}
					else
					{
					    memset(bz2_file_name,0,sizeof(bz2_file_name));
						if (0 != bin_to_bz2(file_name, bz2_file_name))
		       			{
		       		        printf(" bin_to_bz2 failed!\n");
		       				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);	
		       			}
						else
						{
						    memset(code, 0, sizeof(code));
		       			    sprintf(code, "tar -jxf %s", bz2_file_name);
		       				status = system((const char *)code);
							if(test_code(status))
							{
							    printf("system tar return failed!\n");
		       			        netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);	
							}
							else
							{
							    status =system("flash_eraseall /dev/mtd2");
								if(test_code(status))
								{
								    printf("flash_eraseall failed!\n");
		   			                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);    
								}
								else
								{
								    status =system("flashcp soc_system.dtb /dev/mtd2");
									if(test_code(status))
									{
									     printf("flashcp failed!\n");
		   			                     netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
									}
									 printf("update dtb  success\n");
								}
								
								
							}
								
						}
					}
					break;
				
				case UPDATE_ZIMAGE:
					chdir("/home");
					status=system((const char *)code);
					if(test_code(status))
					{
					    printf("tftp failed!\n");
		   			    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
					}
					else
					{
					    memset(bz2_file_name,0,sizeof(bz2_file_name));
						if (0 != bin_to_bz2(file_name, bz2_file_name))
		       			{
		       		        printf(" bin_to_bz2 failed!\n");
		       				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);	
		       			}
						else
						{
						    memset(code, 0, sizeof(code));
		       			    sprintf(code, "tar -jxf %s", bz2_file_name);
		       				status = system((const char *)code);
							if(test_code(status))
							{
							    printf("system tar return failed!\n");
		       			        netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);	
							}
							else
							{
							    status =system("flash_eraseall /dev/mtd3");
								if(test_code(status))
								{
								    printf("flash_eraseall failed!\n");
		   			                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);    
								}
								else
								{
								    status =system("flashcp zImage /dev/mtd3");
									if(test_code(status))
									{
									     printf("flashcp failed!\n");
		   			                     netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
									}
									 printf("update zImage  success\n");
								}
								
							}
								
						}
					}
					break;
					
				case UPDATE_IMAGE:
					chdir("/home");
					status=system((const char *)code);
					if(test_code(status))
					{
					    printf("tftp failed!\n");
		   			    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
					}
					else
					{
					    memset(bz2_file_name,0,sizeof(bz2_file_name));
						if (0 != bin_to_bz2(file_name, bz2_file_name))
		       			{
		       		        printf(" bin_to_bz2 failed!\n");
		       				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);	
		       			}
						else
						{
						    memset(code, 0, sizeof(code));
		       			    sprintf(code, "tar -jxf %s", bz2_file_name);
		       				status = system((const char *)code);
							if(test_code(status))
							{
							    printf("system tar return failed!\n");
		       			        netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);	
							}
							else
							{
							    status =system("flash_eraseall /dev/mtd4");
								if(test_code(status))
								{
								    printf("flash_eraseall failed!\n");
		   			                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);    
								}
								else
								{
								    status =system("flashcp ramdisk.image.gz /dev/mtd4");
									if(test_code(status))
									{
									     printf("flashcp failed!\n");
		   			                     netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
									}
									 printf("update ramdisk.image  success\n");
								}
								
							}
								
						}
					}
					break;

				case UPDATE_RBF:
					chdir("/home");
					status=system((const char *)code);
					if(test_code(status))
					{
					    printf("tftp failed!\n");
		   			    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
					}
					else
					{
					    memset(bz2_file_name,0,sizeof(bz2_file_name));
						if (0 != bin_to_bz2(file_name, bz2_file_name))
		       			{
		       		        printf(" bin_to_bz2 failed!\n");
		       				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);	
		       			}
						else
						{
						    memset(code, 0, sizeof(code));
		       			    sprintf(code, "tar -jxf %s", bz2_file_name);
		       				status = system((const char *)code);
							if(test_code(status))
							{
							    printf("system tar return failed!\n");
		       			        netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);	
							}
							else
							{
							    status =system("flash_eraseall /dev/mtd1");
								if(test_code(status))
								{
								    printf("flash_eraseall failed!\n");
		   			                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);    
								}
								else
								{
								    status =system("flashcp soc_system.rbf /dev/mtd1");
									if(test_code(status))
									{
									     printf("flashcp failed!\n");
		   			                     netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
									}
									printf("update rbf  success\n");
								}
							}
								
						}
					}
					break;
			   case UPDATE_UBOOT:
					chdir("/home");
					status=system((const char *)code);
					if(test_code(status))
					{
					    printf("tftp failed!\n");
		   			    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
					}
					else
					{
					    memset(bz2_file_name,0,sizeof(bz2_file_name));
						if (0 != bin_to_bz2(file_name, bz2_file_name))
		       			{
		       		        printf(" bin_to_bz2 failed!\n");
		       				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);	
		       			}
						else
						{
						    memset(code, 0, sizeof(code));
		       			    sprintf(code, "tar -jxf %s", bz2_file_name);
		       				status = system((const char *)code);
							if(test_code(status))
							{
							    printf("system tar return failed!\n");
		       			        netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);	
							}
							else
							{
							    status =system("flash_eraseall /dev/mtd0");
								if(test_code(status))
								{
								    printf("flash_eraseall failed!\n");
		   			                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);    
								}
								else
								{
								    status =system("flashcp bootloader /dev/mtd0");
									if(test_code(status))
									{
									     printf("flashcp failed!\n");
		   			                     netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
									}
									printf("update uboot  success\n");
								}
							}
								
						}
					}
					break;
			   case FPGA_PARAM:
			   	    chdir("/home");
					status=system((const char *)code);
					if(test_code(status))
					{
					    printf("tftp failed!\n");
		   			    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
					}
					else
					{
					    memset(bz2_file_name,0,sizeof(bz2_file_name));
						if (0 != bin_to_bz2(file_name, bz2_file_name))
		       			{
		       		        printf(" bin_to_bz2 failed!\n");
		       				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);	
		       			}
						else
						{
						    memset(code, 0, sizeof(code));
		       			    sprintf(code, "tar -jxf %s", bz2_file_name);
		       				status = system((const char *)code);
							if(test_code(status))
							{
							    printf("system tar return failed!\n");
		       			        netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);	
							}
							else
							{	
								sem_nm_p();
								shm_nm_addr->fpga_eeprom.ack_flag= ACK_FLAG_CLR;
								sem_nm_v();

								send_local_nm_get_cmd(CMD_CODE_FPGA_EEPROM);
								for (i = 0; i < timeout_cnt; i++)
								{
									delay.tv_sec = 0;
									delay.tv_usec = POLLING_INTERVA;
									select(0, NULL, NULL, NULL, &delay);
									if (ACK_FLAG_OK == shm_nm_addr->fpga_eeprom.ack_flag)
									{
										break;
									}
								}
								if (i == timeout_cnt)
								{
									netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
								}

							}
								
						}
					}
					break;				
				default:
					
					break;	
				
                 }
			    break;

	        case MODE_SET_COMMIT:
	            /* XXX: delete temporary storage */
	            break;

	        case MODE_SET_UNDO:
	            /* XXX: UNDO and return to previous value for the object */
	            break;

	        default:
	            /* we should never get here, so this is a really bad error */
	            snmp_log(LOG_ERR, "unknown mode (%d) in handle_updatedData\n", reqinfo->mode );
	            return SNMP_ERR_GENERR;
	    }

	    return SNMP_ERR_NOERROR;
	}




	int
	handle_reboot(netsnmp_mib_handler *handler,
	                          netsnmp_handler_registration *reginfo,
	                          netsnmp_agent_request_info   *reqinfo,
	                          netsnmp_request_info         *requests)
	{
		
	    /* We are never called for a GETNEXT if it's registered as a
	       "instance", as it's "magically" handled for us.  */

	    /* a instance handler also only hands us one request at a time, so
	       we don't need to loop over a list of requests; we'll only get one. */
	    int ret;
	    switch(reqinfo->mode) {

	        case MODE_GET:
		
	            break;

	        /*
	         * SET REQUEST
	         *
	         * multiple states in the transaction.  See:
	         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
	         */
	        case MODE_SET_RESERVE1:
	                /* or you could use netsnmp_check_vb_type_and_size instead */
	            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
	            if ( ret != SNMP_ERR_NOERROR ) {
	                netsnmp_set_request_error(reqinfo, requests, ret );
	            }
	            break;

	        case MODE_SET_RESERVE2:
	            /* XXX malloc "undo" storage buffer */
	            break;

	        case MODE_SET_FREE:
	            /* XXX: free resources allocated in RESERVE1 and/or
	               RESERVE2.  Something failed somewhere, and the states
	               below won't be called. */
	            break;

	        case MODE_SET_ACTION:
	            /* XXX: perform the value change here */
				if (shm_ipc_addr->mgr_printf[1])
				{
				    LOG_DEBUG(s_i4LogMsgId, \
						     "receive reboot \n");
				}
				send_local_nm_get_cmd(CMD_CODE_REBOOT);
				
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_reboot\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_localCombinedData(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	struct timeval delay; 
	NM_COMBINED_DATA data;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
	        send_local_nm_get_cmd(CMD_CODE_COMBINED_DATA);
			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->combined_data.data,sizeof(NM_COMBINED_DATA));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, \
							   "\n |%s||%s||%d|\n"
							   "\r MODE_GET freq                : 0x%X\n"
							   "\r MODE_GET power               : 0x%X\n"
							   "\r MODE_GET start_neighbor      : 0x%X\n"
							   "\r MODE_GET start_alarm_report  : 0x%X\n"
							   "\r MODE_GET neighbor_period     : 0x%X\n",\
							   __FILE__, __FUNCTION__, __LINE__,\
							   data.freq, data.power, data.start_neighbor,data.start_alarm_report, data.neighbor_period);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(NM_COMBINED_DATA));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy((unsigned char *)&data, requests->requestvb->val.string, sizeof(NM_COMBINED_DATA));
			if((data.freq!=0xFFFFFFFF)&&((data.freq<MIN_FREQ)||(data.freq>MAX_FREQ)))
			{
			    printf("set freq=%d not in 350000000~400000000 or 0xffffffff\n",data.freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
			    if(data.power!=0xff)
			    {
					for(i=0;i<5;i++)
					{
						if(data.power==power_range[i])
						{
							flag=1;
							break;
						}
					}
			    }
				else
				{
				    flag=1;
				}

				if(!flag)
				{
					printf("set power=%d not in1,5,10,16,20\n",data.power);
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				}
				else
				{
				    flag=0;
					if((data.neighbor_period!=0xFFFF)&&((data.neighbor_period<MIN_PERIOD)||(data.neighbor_period>MAX_PERIOD)||(data.neighbor_period % 2)))
					{
						printf("set neighborperiod=%d not in 2,4,6...20\n",data.neighbor_period);
						netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
					}
					else
					{
						sem_nm_p();
						shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
						sem_nm_v();
						send_local_nm_set_cmd(CMD_CODE_COMBINED_DATA, (unsigned char *)&data);
						for (i = 0; i < timeout_cnt; i++)
						{
							delay.tv_sec = 0;
							delay.tv_usec = POLLING_INTERVA;
							select(0, NULL, NULL, NULL, &delay);
							if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
							{
								break;
							}
						}
						if (i == timeout_cnt)
						{
							netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
						}
					}
					
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_localCombinedData\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}





int
handle_id1QueryAlarm(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
    unsigned int j=0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_1;
	unsigned  char  data[8]={0};
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->alarm_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_QUERY_ALARM);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_QUERY_ALARM, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->alarm_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->alarm_data.data,sizeof(data));
					if (shm_ipc_addr->mgr_printf[1])
					{
		                for(j=0;j<8;j++)
                        {
                            LOG_DEBUG(s_i4LogMsgId, "0x%X    ",data[i]);
                        }      
						
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(data));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
		
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id2QueryAlarm\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}






int
handle_id2QueryAlarm(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
    unsigned int j=0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_2;
	unsigned  char  data[8]={0};
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->alarm_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_QUERY_ALARM);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_QUERY_ALARM, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->alarm_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->alarm_data.data,sizeof(data));
					if (shm_ipc_addr->mgr_printf[1])
					{
		                for(j=0;j<8;j++)
                        {
                            LOG_DEBUG(s_i4LogMsgId, "0x%X    ",data[i]);
                        }      
						
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(data));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
		
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id2QueryAlarm\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}







int
handle_id3QueryAlarm(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
    unsigned int j=0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_3;
	unsigned  char  data[8]={0};
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->alarm_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_QUERY_ALARM);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_QUERY_ALARM, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->alarm_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->alarm_data.data,sizeof(data));
					if (shm_ipc_addr->mgr_printf[1])
					{
		                for(j=0;j<8;j++)
                        {
                            LOG_DEBUG(s_i4LogMsgId, "0x%X    ",data[i]);
                        }      
						
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(data));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
		
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id3QueryAlarm\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}







int
handle_id4QueryAlarm(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
    unsigned int j=0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_4;
	unsigned  char  data[8]={0};
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->alarm_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_QUERY_ALARM);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_QUERY_ALARM, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->alarm_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->alarm_data.data,sizeof(data));
					if (shm_ipc_addr->mgr_printf[1])
					{
		                for(j=0;j<8;j++)
                        {
                            LOG_DEBUG(s_i4LogMsgId, "0x%X    ",data[i]);
                        }      
						
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(data));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
		
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id4QueryAlarm\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}









int
handle_id5QueryAlarm(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
    unsigned int j=0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_5;
	unsigned  char  data[8]={0};
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->alarm_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_QUERY_ALARM);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_QUERY_ALARM, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->alarm_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->alarm_data.data,sizeof(data));
					if (shm_ipc_addr->mgr_printf[1])
					{
		                for(j=0;j<8;j++)
                        {
                            LOG_DEBUG(s_i4LogMsgId, "0x%X    ",data[i]);
                        }      
						
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(data));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
		
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id5QueryAlarm\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}









int
handle_id6QueryAlarm(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
    unsigned int j=0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_6;
	unsigned  char  data[8]={0};
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->alarm_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_QUERY_ALARM);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_QUERY_ALARM, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->alarm_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->alarm_data.data,sizeof(data));
					if (shm_ipc_addr->mgr_printf[1])
					{
		                for(j=0;j<8;j++)
                        {
                            LOG_DEBUG(s_i4LogMsgId, "0x%X    ",data[i]);
                        }      
						
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(data));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
		
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id6QueryAlarm\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}









int
handle_id7QueryAlarm(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
    unsigned int j=0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_7;
	unsigned  char  data[8]={0};
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->alarm_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_QUERY_ALARM);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_QUERY_ALARM, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->alarm_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->alarm_data.data,sizeof(data));
					if (shm_ipc_addr->mgr_printf[1])
					{
		                for(j=0;j<8;j++)
                        {
                            LOG_DEBUG(s_i4LogMsgId, "0x%X    ",data[i]);
                        }      
						
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(data));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
		
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id7QueryAlarm\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}










int
handle_id8QueryAlarm(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
    unsigned int j=0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_8;
	unsigned  char  data[8]={0};
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->alarm_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_QUERY_ALARM);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_QUERY_ALARM, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->alarm_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->alarm_data.data,sizeof(data));
					if (shm_ipc_addr->mgr_printf[1])
					{
		                for(j=0;j<8;j++)
                        {
                            LOG_DEBUG(s_i4LogMsgId, "0x%X    ",data[i]);
                        }      
						
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(data));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
		
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id8QueryAlarm\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}









int
handle_id9QueryAlarm(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
    unsigned int j=0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_9;
	unsigned  char  data[8]={0};
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->alarm_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_QUERY_ALARM);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_QUERY_ALARM, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->alarm_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->alarm_data.data,sizeof(data));
					if (shm_ipc_addr->mgr_printf[1])
					{
		                for(j=0;j<8;j++)
                        {
                            LOG_DEBUG(s_i4LogMsgId, "0x%X    ",data[i]);
                        }      
						
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(data));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
		
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id9QueryAlarm\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}









int
handle_id10QueryAlarm(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
    unsigned int j=0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_10;
	unsigned  char  data[8]={0};
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->alarm_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_QUERY_ALARM);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_QUERY_ALARM, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->alarm_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->alarm_data.data,sizeof(data));
					if (shm_ipc_addr->mgr_printf[1])
					{
		                for(j=0;j<8;j++)
                        {
                            LOG_DEBUG(s_i4LogMsgId, "0x%X    ",data[i]);
                        }      
						
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(data));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
		
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id10QueryAlarm\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}









int
handle_id11QueryAlarm(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
    unsigned int j=0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_11;
	unsigned  char  data[8]={0};
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->alarm_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_QUERY_ALARM);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_QUERY_ALARM, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->alarm_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->alarm_data.data,sizeof(data));
					if (shm_ipc_addr->mgr_printf[1])
					{
		                for(j=0;j<8;j++)
                        {
                            LOG_DEBUG(s_i4LogMsgId, "0x%X    ",data[i]);
                        }      
						
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(data));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
		
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id11QueryAlarm\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}










int
handle_id12QueryAlarm(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
    unsigned int j=0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_12;
	unsigned  char  data[8]={0};
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->alarm_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_QUERY_ALARM);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_QUERY_ALARM, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->alarm_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->alarm_data.data,sizeof(data));
					if (shm_ipc_addr->mgr_printf[1])
					{
		                for(j=0;j<8;j++)
                        {
                            LOG_DEBUG(s_i4LogMsgId, "0x%X    ",data[i]);
                        }      
						
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(data));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
		
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id12QueryAlarm\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}










int
handle_id13QueryAlarm(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
    unsigned int j=0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_13;
	unsigned  char  data[8]={0};
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->alarm_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_QUERY_ALARM);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_QUERY_ALARM, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->alarm_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->alarm_data.data,sizeof(data));
					if (shm_ipc_addr->mgr_printf[1])
					{
		                for(j=0;j<8;j++)
                        {
                            LOG_DEBUG(s_i4LogMsgId, "0x%X    ",data[i]);
                        }      
						
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(data));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
		
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id13QueryAlarm\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}









int
handle_id14QueryAlarm(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
    unsigned int j=0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_14;
	unsigned  char  data[8]={0};
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->alarm_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_QUERY_ALARM);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_QUERY_ALARM, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->alarm_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->alarm_data.data,sizeof(data));
					if (shm_ipc_addr->mgr_printf[1])
					{
		                for(j=0;j<8;j++)
                        {
                            LOG_DEBUG(s_i4LogMsgId, "0x%X    ",data[i]);
                        }      
						
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(data));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
		
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id14QueryAlarm\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}










int
handle_id15QueryAlarm(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
    unsigned int j=0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_15;
	unsigned  char  data[8]={0};
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->alarm_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_QUERY_ALARM);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_QUERY_ALARM, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->alarm_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->alarm_data.data,sizeof(data));
					if (shm_ipc_addr->mgr_printf[1])
					{
		                for(j=0;j<8;j++)
                        {
                            LOG_DEBUG(s_i4LogMsgId, "0x%X    ",data[i]);
                        }      
						
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(data));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
		
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id15QueryAlarm\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}










int
handle_id16QueryAlarm(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
    unsigned int j=0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_16;
	unsigned  char  data[8]={0};
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->alarm_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_QUERY_ALARM);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_QUERY_ALARM, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->alarm_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->alarm_data.data,sizeof(data));
					if (shm_ipc_addr->mgr_printf[1])
					{
		                for(j=0;j<8;j++)
                        {
                            LOG_DEBUG(s_i4LogMsgId, "0x%X    ",data[i]);
                        }      
						
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(data));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
		
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id16QueryAlarm\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}








int
handle_id17QueryAlarm(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
    unsigned int j=0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_17;
	unsigned  char  data[8]={0};
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->alarm_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_QUERY_ALARM);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_QUERY_ALARM, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->alarm_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->alarm_data.data,sizeof(data));
					if (shm_ipc_addr->mgr_printf[1])
					{
		                for(j=0;j<8;j++)
                        {
                            LOG_DEBUG(s_i4LogMsgId, "0x%X    ",data[i]);
                        }      
						
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(data));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
		
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id17QueryAlarm\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}








int
handle_id18QueryAlarm(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
    unsigned int j=0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_18;
	unsigned  char  data[8]={0};
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->alarm_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_QUERY_ALARM);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_QUERY_ALARM, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->alarm_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->alarm_data.data,sizeof(data));
					if (shm_ipc_addr->mgr_printf[1])
					{
		                for(j=0;j<8;j++)
                        {
                            LOG_DEBUG(s_i4LogMsgId, "0x%X    ",data[i]);
                        }      
						
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(data));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
		
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id18QueryAlarm\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}









int
handle_id19QueryAlarm(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
    unsigned int j=0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_19;
	unsigned  char  data[8]={0};
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->alarm_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_QUERY_ALARM);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_QUERY_ALARM, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->alarm_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->alarm_data.data,sizeof(data));
					if (shm_ipc_addr->mgr_printf[1])
					{
		                for(j=0;j<8;j++)
                        {
                            LOG_DEBUG(s_i4LogMsgId, "0x%X    ",data[i]);
                        }      
						
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(data));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
		
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id19QueryAlarm\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}








int
handle_id20QueryAlarm(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
    unsigned int j=0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_20;
	unsigned  char  data[8]={0};
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->alarm_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_QUERY_ALARM);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_QUERY_ALARM, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->alarm_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->alarm_data.data,sizeof(data));
					if (shm_ipc_addr->mgr_printf[1])
					{
		                for(j=0;j<8;j++)
                        {
                            LOG_DEBUG(s_i4LogMsgId, "0x%X    ",data[i]);
                        }      
						
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(data));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
		
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id20QueryAlarm\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}








int
handle_id21QueryAlarm(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
    unsigned int j=0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_21;
	unsigned  char  data[8]={0};
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->alarm_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_QUERY_ALARM);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_QUERY_ALARM, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->alarm_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->alarm_data.data,sizeof(data));
					if (shm_ipc_addr->mgr_printf[1])
					{
		                for(j=0;j<8;j++)
                        {
                            LOG_DEBUG(s_i4LogMsgId, "0x%X    ",data[i]);
                        }      
						
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(data));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
		
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id21QueryAlarm\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}








int
handle_id22QueryAlarm(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
    unsigned int j=0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_22;
	unsigned  char  data[8]={0};
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->alarm_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_QUERY_ALARM);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_QUERY_ALARM, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->alarm_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->alarm_data.data,sizeof(data));
					if (shm_ipc_addr->mgr_printf[1])
					{
		                for(j=0;j<8;j++)
                        {
                            LOG_DEBUG(s_i4LogMsgId, "0x%X    ",data[i]);
                        }      
						
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(data));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
		
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id22QueryAlarm\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}









int
handle_id23QueryAlarm(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
    unsigned int j=0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_23;
	unsigned  char  data[8]={0};
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->alarm_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_QUERY_ALARM);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_QUERY_ALARM, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->alarm_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->alarm_data.data,sizeof(data));
					if (shm_ipc_addr->mgr_printf[1])
					{
		                for(j=0;j<8;j++)
                        {
                            LOG_DEBUG(s_i4LogMsgId, "0x%X    ",data[i]);
                        }      
						
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(data));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
		
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id23QueryAlarm\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}








int
handle_id24QueryAlarm(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
    unsigned int j=0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_24;
	unsigned  char  data[8]={0};
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->alarm_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_QUERY_ALARM);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_QUERY_ALARM, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->alarm_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->alarm_data.data,sizeof(data));
					if (shm_ipc_addr->mgr_printf[1])
					{
		                for(j=0;j<8;j++)
                        {
                            LOG_DEBUG(s_i4LogMsgId, "0x%X    ",data[i]);
                        }      
						
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(data));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
		
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id24QueryAlarm\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}









int
handle_id25QueryAlarm(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
    unsigned int j=0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_25;
	unsigned  char  data[8]={0};
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->alarm_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_QUERY_ALARM);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_QUERY_ALARM, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->alarm_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->alarm_data.data,sizeof(data));
					if (shm_ipc_addr->mgr_printf[1])
					{
		                for(j=0;j<8;j++)
                        {
                            LOG_DEBUG(s_i4LogMsgId, "0x%X    ",data[i]);
                        }      
						
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(data));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
		
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id25QueryAlarm\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}








int
handle_id26QueryAlarm(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
    unsigned int j=0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_26;
	unsigned  char  data[8]={0};
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->alarm_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_QUERY_ALARM);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_QUERY_ALARM, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->alarm_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->alarm_data.data,sizeof(data));
					if (shm_ipc_addr->mgr_printf[1])
					{
		                for(j=0;j<8;j++)
                        {
                            LOG_DEBUG(s_i4LogMsgId, "0x%X    ",data[i]);
                        }      
						
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(data));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
		
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id26QueryAlarm\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}








int
handle_id27QueryAlarm(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
    unsigned int j=0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_27;
	unsigned  char  data[8]={0};
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->alarm_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_QUERY_ALARM);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_QUERY_ALARM, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->alarm_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->alarm_data.data,sizeof(data));
					if (shm_ipc_addr->mgr_printf[1])
					{
		                for(j=0;j<8;j++)
                        {
                            LOG_DEBUG(s_i4LogMsgId, "0x%X    ",data[i]);
                        }      
						
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(data));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
		
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id27QueryAlarm\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}







int
handle_id28QueryAlarm(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
    unsigned int j=0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_28;
	unsigned  char  data[8]={0};
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->alarm_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_QUERY_ALARM);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_QUERY_ALARM, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->alarm_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->alarm_data.data,sizeof(data));
					if (shm_ipc_addr->mgr_printf[1])
					{
		                for(j=0;j<8;j++)
                        {
                            LOG_DEBUG(s_i4LogMsgId, "0x%X    ",data[i]);
                        }      
						
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(data));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
		
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id28QueryAlarm\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}







int
handle_id29QueryAlarm(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
    unsigned int j=0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_29;
	unsigned  char  data[8]={0};
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->alarm_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_QUERY_ALARM);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_QUERY_ALARM, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->alarm_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->alarm_data.data,sizeof(data));
					if (shm_ipc_addr->mgr_printf[1])
					{
		                for(j=0;j<8;j++)
                        {
                            LOG_DEBUG(s_i4LogMsgId, "0x%X    ",data[i]);
                        }      
						
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(data));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
		
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id29QueryAlarm\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}







int
handle_id30QueryAlarm(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
    unsigned int j=0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_30;
	unsigned  char  data[8]={0};
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->alarm_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_QUERY_ALARM);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_QUERY_ALARM, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->alarm_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->alarm_data.data,sizeof(data));
					if (shm_ipc_addr->mgr_printf[1])
					{
		                for(j=0;j<8;j++)
                        {
                            LOG_DEBUG(s_i4LogMsgId, "0x%X    ",data[i]);
                        }      
						
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(data));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
		
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id30QueryAlarm\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}







int
handle_id31QueryAlarm(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
    unsigned int j=0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_31;
	unsigned  char  data[8]={0};
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->alarm_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_QUERY_ALARM);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_QUERY_ALARM, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->alarm_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->alarm_data.data,sizeof(data));
					if (shm_ipc_addr->mgr_printf[1])
					{
		                for(j=0;j<8;j++)
                        {
                            LOG_DEBUG(s_i4LogMsgId, "0x%X    ",data[i]);
                        }      
						
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(data));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
		
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id31QueryAlarm\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}








int
handle_id32QueryAlarm(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
    unsigned int j=0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_32;
	unsigned  char  data[MGR_ALARM_BYTE_MAX]={0};
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->alarm_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_QUERY_ALARM);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_QUERY_ALARM, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->alarm_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->alarm_data.data,sizeof(data));
					if (shm_ipc_addr->mgr_printf[1])
					{
		                for(j=0;j<8;j++)
                        {
                            LOG_DEBUG(s_i4LogMsgId, "0x%X    ",data[i]);
                        }      
						
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(data));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
		
			netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id32QueryAlarm\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_id1CombinedDataPacket(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_1;
	NM_COMBINED_DATA data;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_COMBINED_DATA);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_COMBINED_DATA, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->combined_data.data,sizeof(NM_COMBINED_DATA));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, \
							   "\n |%s||%s||%d|\n"
							   "\r MODE_GET freq                : 0x%X\n"
							   "\r MODE_GET power               : 0x%X\n"
							   "\r MODE_GET start_neighbor      : 0x%X\n"
							   "\r MODE_GET start_alarm_report  : 0x%X\n"
							   "\r MODE_GET neighbor_period     : 0x%X\n",\
							   __FILE__, __FUNCTION__, __LINE__,\
							   data.freq, data.power, data.start_neighbor,data.start_alarm_report, data.neighbor_period);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(NM_COMBINED_DATA));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy((unsigned char *)&data, requests->requestvb->val.string, sizeof(NM_COMBINED_DATA));
			if((data.freq!=0xFFFFFFFF)&&((data.freq<MIN_FREQ)||(data.freq>MAX_FREQ)))
			{
			    printf("set freq=%d not in 350000000~400000000 or 0xffffffff\n",data.freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
			    if(data.power!=0xff)
			    {
					for(i=0;i<5;i++)
					{
						if(data.power==power_range[i])
						{
							flag=1;
							break;
						}
					}
			    }
				else
				{
				    flag=1;
				}

				if(!flag)
				{
					printf("set power=%d not in1,5,10,16,20\n",data.power);
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				}
				else
				{
				    flag=0;
                    if((data.neighbor_period!=0xFFFF)&&((data.neighbor_period<MIN_PERIOD)||(data.neighbor_period>MAX_PERIOD)||(data.neighbor_period % 2)))
				    {
						printf("set neighborperiod=%d not in 2,4,6...20\n",data.neighbor_period);
						netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
					}
					else
					{
						sem_nm_p();
						shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
						sem_nm_v();
							
						if (is_local_dev(this_id))
						{
							send_local_nm_set_cmd(CMD_CODE_COMBINED_DATA, (unsigned char *)&data);
						}
						else
						{
							send_remote_nm_set_cmd(CMD_CODE_COMBINED_DATA, this_id, (unsigned char *)&data);
						}
							
						for (i = 0; i < timeout_cnt; i++)
						{
							delay.tv_sec = 0;
							delay.tv_usec = POLLING_INTERVA;
							select(0, NULL, NULL, NULL, &delay);
							if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
							{
								break;
							}
						}
						if (i == timeout_cnt)
						{
							netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
						}
					}
					
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id1CombinedDataPacket\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



int
handle_id2CombinedDataPacket(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_2;
	NM_COMBINED_DATA data;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_COMBINED_DATA);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_COMBINED_DATA, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->combined_data.data,sizeof(NM_COMBINED_DATA));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, \
							   "\n |%s||%s||%d|\n"
							   "\r MODE_GET freq                : 0x%X\n"
							   "\r MODE_GET power               : 0x%X\n"
							   "\r MODE_GET start_neighbor      : 0x%X\n"
							   "\r MODE_GET start_alarm_report  : 0x%X\n"
							   "\r MODE_GET neighbor_period     : 0x%X\n",\
							   __FILE__, __FUNCTION__, __LINE__,\
							   data.freq, data.power, data.start_neighbor,data.start_alarm_report, data.neighbor_period);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(NM_COMBINED_DATA));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy((unsigned char *)&data, requests->requestvb->val.string, sizeof(NM_COMBINED_DATA));
			if((data.freq!=0xFFFFFFFF)&&((data.freq<MIN_FREQ)||(data.freq>MAX_FREQ)))
			{
			    printf("set freq=%d not in 350000000~400000000 or 0xffffffff\n",data.freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
			    if(data.power!=0xff)
			    {
					for(i=0;i<5;i++)
					{
						if(data.power==power_range[i])
						{
							flag=1;
							break;
						}
					}
			    }
				else
				{
				    flag=1;
				}

				if(!flag)
				{
					printf("set power=%d not in1,5,10,16,20\n",data.power);
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				}
				else
				{
				    flag=0;
                    if((data.neighbor_period!=0xFFFF)&&((data.neighbor_period<MIN_PERIOD)||(data.neighbor_period>MAX_PERIOD)||(data.neighbor_period % 2)))
				    {
						printf("set neighborperiod=%d not in 2,4,6...20\n",data.neighbor_period);
						netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
					}
					else
					{
						sem_nm_p();
						shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
						sem_nm_v();
							
						if (is_local_dev(this_id))
						{
							send_local_nm_set_cmd(CMD_CODE_COMBINED_DATA, (unsigned char *)&data);
						}
						else
						{
							send_remote_nm_set_cmd(CMD_CODE_COMBINED_DATA, this_id, (unsigned char *)&data);
						}
							
						for (i = 0; i < timeout_cnt; i++)
						{
							delay.tv_sec = 0;
							delay.tv_usec = POLLING_INTERVA;
							select(0, NULL, NULL, NULL, &delay);
							if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
							{
								break;
							}
						}
						if (i == timeout_cnt)
						{
							netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
						}
					}
					
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id2CombinedDataPacket\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id3CombinedDataPacket(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_3;
	NM_COMBINED_DATA data;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_COMBINED_DATA);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_COMBINED_DATA, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->combined_data.data,sizeof(NM_COMBINED_DATA));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, \
							   "\n |%s||%s||%d|\n"
							   "\r MODE_GET freq                : 0x%X\n"
							   "\r MODE_GET power               : 0x%X\n"
							   "\r MODE_GET start_neighbor      : 0x%X\n"
							   "\r MODE_GET start_alarm_report  : 0x%X\n"
							   "\r MODE_GET neighbor_period     : 0x%X\n",\
							   __FILE__, __FUNCTION__, __LINE__,\
							   data.freq, data.power, data.start_neighbor,data.start_alarm_report, data.neighbor_period);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(NM_COMBINED_DATA));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy((unsigned char *)&data, requests->requestvb->val.string, sizeof(NM_COMBINED_DATA));
			if((data.freq!=0xFFFFFFFF)&&((data.freq<MIN_FREQ)||(data.freq>MAX_FREQ)))
			{
			    printf("set freq=%d not in 350000000~400000000 or 0xffffffff\n",data.freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
			    if(data.power!=0xff)
			    {
					for(i=0;i<5;i++)
					{
						if(data.power==power_range[i])
						{
							flag=1;
							break;
						}
					}
			    }
				else
				{
				    flag=1;
				}

				if(!flag)
				{
					printf("set power=%d not in1,5,10,16,20\n",data.power);
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				}
				else
				{
				    flag=0;
                    if((data.neighbor_period!=0xFFFF)&&((data.neighbor_period<MIN_PERIOD)||(data.neighbor_period>MAX_PERIOD)||(data.neighbor_period % 2)))
				    {
						printf("set neighborperiod=%d not in 2,4,6...20\n",data.neighbor_period);
						netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
					}
					else
					{
						sem_nm_p();
						shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
						sem_nm_v();
							
						if (is_local_dev(this_id))
						{
							send_local_nm_set_cmd(CMD_CODE_COMBINED_DATA, (unsigned char *)&data);
						}
						else
						{
							send_remote_nm_set_cmd(CMD_CODE_COMBINED_DATA, this_id, (unsigned char *)&data);
						}
							
						for (i = 0; i < timeout_cnt; i++)
						{
							delay.tv_sec = 0;
							delay.tv_usec = POLLING_INTERVA;
							select(0, NULL, NULL, NULL, &delay);
							if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
							{
								break;
							}
						}
						if (i == timeout_cnt)
						{
							netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
						}
					}
					
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id3CombinedDataPacket\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id4CombinedDataPacket(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_4;
	NM_COMBINED_DATA data;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_COMBINED_DATA);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_COMBINED_DATA, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->combined_data.data,sizeof(NM_COMBINED_DATA));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, \
							   "\n |%s||%s||%d|\n"
							   "\r MODE_GET freq                : 0x%X\n"
							   "\r MODE_GET power               : 0x%X\n"
							   "\r MODE_GET start_neighbor      : 0x%X\n"
							   "\r MODE_GET start_alarm_report  : 0x%X\n"
							   "\r MODE_GET neighbor_period     : 0x%X\n",\
							   __FILE__, __FUNCTION__, __LINE__,\
							   data.freq, data.power, data.start_neighbor,data.start_alarm_report, data.neighbor_period);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(NM_COMBINED_DATA));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy((unsigned char *)&data, requests->requestvb->val.string, sizeof(NM_COMBINED_DATA));
			if((data.freq!=0xFFFFFFFF)&&((data.freq<MIN_FREQ)||(data.freq>MAX_FREQ)))
			{
			    printf("set freq=%d not in 350000000~400000000 or 0xffffffff\n",data.freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
			    if(data.power!=0xff)
			    {
					for(i=0;i<5;i++)
					{
						if(data.power==power_range[i])
						{
							flag=1;
							break;
						}
					}
			    }
				else
				{
				    flag=1;
				}

				if(!flag)
				{
					printf("set power=%d not in1,5,10,16,20\n",data.power);
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				}
				else
				{
				    flag=0;
                    if((data.neighbor_period!=0xFFFF)&&((data.neighbor_period<MIN_PERIOD)||(data.neighbor_period>MAX_PERIOD)||(data.neighbor_period % 2)))
				    {
						printf("set neighborperiod=%d not in 2,4,6...20\n",data.neighbor_period);
						netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
					}
					else
					{
						sem_nm_p();
						shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
						sem_nm_v();
							
						if (is_local_dev(this_id))
						{
							send_local_nm_set_cmd(CMD_CODE_COMBINED_DATA, (unsigned char *)&data);
						}
						else
						{
							send_remote_nm_set_cmd(CMD_CODE_COMBINED_DATA, this_id, (unsigned char *)&data);
						}
							
						for (i = 0; i < timeout_cnt; i++)
						{
							delay.tv_sec = 0;
							delay.tv_usec = POLLING_INTERVA;
							select(0, NULL, NULL, NULL, &delay);
							if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
							{
								break;
							}
						}
						if (i == timeout_cnt)
						{
							netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
						}
					}
					
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id4CombinedDataPacket\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



int
handle_id5CombinedDataPacket(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_5;
	NM_COMBINED_DATA data;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_COMBINED_DATA);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_COMBINED_DATA, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->combined_data.data,sizeof(NM_COMBINED_DATA));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, \
							   "\n |%s||%s||%d|\n"
							   "\r MODE_GET freq                : 0x%X\n"
							   "\r MODE_GET power               : 0x%X\n"
							   "\r MODE_GET start_neighbor      : 0x%X\n"
							   "\r MODE_GET start_alarm_report  : 0x%X\n"
							   "\r MODE_GET neighbor_period     : 0x%X\n",\
							   __FILE__, __FUNCTION__, __LINE__,\
							   data.freq, data.power, data.start_neighbor,data.start_alarm_report, data.neighbor_period);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(NM_COMBINED_DATA));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy((unsigned char *)&data, requests->requestvb->val.string, sizeof(NM_COMBINED_DATA));
			if((data.freq!=0xFFFFFFFF)&&((data.freq<MIN_FREQ)||(data.freq>MAX_FREQ)))
			{
			    printf("set freq=%d not in 350000000~400000000 or 0xffffffff\n",data.freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
			    if(data.power!=0xff)
			    {
					for(i=0;i<5;i++)
					{
						if(data.power==power_range[i])
						{
							flag=1;
							break;
						}
					}
			    }
				else
				{
				    flag=1;
				}

				if(!flag)
				{
					printf("set power=%d not in1,5,10,16,20\n",data.power);
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				}
				else
				{
				    flag=0;
                    if((data.neighbor_period!=0xFFFF)&&((data.neighbor_period<MIN_PERIOD)||(data.neighbor_period>MAX_PERIOD)||(data.neighbor_period % 2)))
				    {
						printf("set neighborperiod=%d not in 2,4,6...20\n",data.neighbor_period);
						netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
					}
					else
					{
						sem_nm_p();
						shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
						sem_nm_v();
							
						if (is_local_dev(this_id))
						{
							send_local_nm_set_cmd(CMD_CODE_COMBINED_DATA, (unsigned char *)&data);
						}
						else
						{
							send_remote_nm_set_cmd(CMD_CODE_COMBINED_DATA, this_id, (unsigned char *)&data);
						}
							
						for (i = 0; i < timeout_cnt; i++)
						{
							delay.tv_sec = 0;
							delay.tv_usec = POLLING_INTERVA;
							select(0, NULL, NULL, NULL, &delay);
							if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
							{
								break;
							}
						}
						if (i == timeout_cnt)
						{
							netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
						}
					}
					
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id5CombinedDataPacket\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id6CombinedDataPacket(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_6;
	NM_COMBINED_DATA data;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_COMBINED_DATA);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_COMBINED_DATA, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->combined_data.data,sizeof(NM_COMBINED_DATA));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, \
							   "\n |%s||%s||%d|\n"
							   "\r MODE_GET freq                : 0x%X\n"
							   "\r MODE_GET power               : 0x%X\n"
							   "\r MODE_GET start_neighbor      : 0x%X\n"
							   "\r MODE_GET start_alarm_report  : 0x%X\n"
							   "\r MODE_GET neighbor_period     : 0x%X\n",\
							   __FILE__, __FUNCTION__, __LINE__,\
							   data.freq, data.power, data.start_neighbor,data.start_alarm_report, data.neighbor_period);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(NM_COMBINED_DATA));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy((unsigned char *)&data, requests->requestvb->val.string, sizeof(NM_COMBINED_DATA));
			if((data.freq!=0xFFFFFFFF)&&((data.freq<MIN_FREQ)||(data.freq>MAX_FREQ)))
			{
			    printf("set freq=%d not in 350000000~400000000 or 0xffffffff\n",data.freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
			    if(data.power!=0xff)
			    {
					for(i=0;i<5;i++)
					{
						if(data.power==power_range[i])
						{
							flag=1;
							break;
						}
					}
			    }
				else
				{
				    flag=1;
				}

				if(!flag)
				{
					printf("set power=%d not in1,5,10,16,20\n",data.power);
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				}
				else
				{
				    flag=0;
                    if((data.neighbor_period!=0xFFFF)&&((data.neighbor_period<MIN_PERIOD)||(data.neighbor_period>MAX_PERIOD)||(data.neighbor_period % 2)))
				    {
						printf("set neighborperiod=%d not in 2,4,6...20\n",data.neighbor_period);
						netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
					}
					else
					{
						sem_nm_p();
						shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
						sem_nm_v();
							
						if (is_local_dev(this_id))
						{
							send_local_nm_set_cmd(CMD_CODE_COMBINED_DATA, (unsigned char *)&data);
						}
						else
						{
							send_remote_nm_set_cmd(CMD_CODE_COMBINED_DATA, this_id, (unsigned char *)&data);
						}
							
						for (i = 0; i < timeout_cnt; i++)
						{
							delay.tv_sec = 0;
							delay.tv_usec = POLLING_INTERVA;
							select(0, NULL, NULL, NULL, &delay);
							if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
							{
								break;
							}
						}
						if (i == timeout_cnt)
						{
							netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
						}
					}
					
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id6CombinedDataPacket\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id7CombinedDataPacket(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_7;
	NM_COMBINED_DATA data;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_COMBINED_DATA);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_COMBINED_DATA, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->combined_data.data,sizeof(NM_COMBINED_DATA));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, \
							   "\n |%s||%s||%d|\n"
							   "\r MODE_GET freq                : 0x%X\n"
							   "\r MODE_GET power               : 0x%X\n"
							   "\r MODE_GET start_neighbor      : 0x%X\n"
							   "\r MODE_GET start_alarm_report  : 0x%X\n"
							   "\r MODE_GET neighbor_period     : 0x%X\n",\
							   __FILE__, __FUNCTION__, __LINE__,\
							   data.freq, data.power, data.start_neighbor,data.start_alarm_report, data.neighbor_period);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(NM_COMBINED_DATA));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy((unsigned char *)&data, requests->requestvb->val.string, sizeof(NM_COMBINED_DATA));
			if((data.freq!=0xFFFFFFFF)&&((data.freq<MIN_FREQ)||(data.freq>MAX_FREQ)))
			{
			    printf("set freq=%d not in 350000000~400000000 or 0xffffffff\n",data.freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
			    if(data.power!=0xff)
			    {
					for(i=0;i<5;i++)
					{
						if(data.power==power_range[i])
						{
							flag=1;
							break;
						}
					}
			    }
				else
				{
				    flag=1;
				}

				if(!flag)
				{
					printf("set power=%d not in1,5,10,16,20\n",data.power);
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				}
				else
				{
				    flag=0;
                    if((data.neighbor_period!=0xFFFF)&&((data.neighbor_period<MIN_PERIOD)||(data.neighbor_period>MAX_PERIOD)||(data.neighbor_period % 2)))
				    {
						printf("set neighborperiod=%d not in 2,4,6...20\n",data.neighbor_period);
						netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
					}
					else
					{
						sem_nm_p();
						shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
						sem_nm_v();
							
						if (is_local_dev(this_id))
						{
							send_local_nm_set_cmd(CMD_CODE_COMBINED_DATA, (unsigned char *)&data);
						}
						else
						{
							send_remote_nm_set_cmd(CMD_CODE_COMBINED_DATA, this_id, (unsigned char *)&data);
						}
							
						for (i = 0; i < timeout_cnt; i++)
						{
							delay.tv_sec = 0;
							delay.tv_usec = POLLING_INTERVA;
							select(0, NULL, NULL, NULL, &delay);
							if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
							{
								break;
							}
						}
						if (i == timeout_cnt)
						{
							netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
						}
					}
					
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id7CombinedDataPacket\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id8CombinedDataPacket(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_8;
	NM_COMBINED_DATA data;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_COMBINED_DATA);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_COMBINED_DATA, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->combined_data.data,sizeof(NM_COMBINED_DATA));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, \
							   "\n |%s||%s||%d|\n"
							   "\r MODE_GET freq                : 0x%X\n"
							   "\r MODE_GET power               : 0x%X\n"
							   "\r MODE_GET start_neighbor      : 0x%X\n"
							   "\r MODE_GET start_alarm_report  : 0x%X\n"
							   "\r MODE_GET neighbor_period     : 0x%X\n",\
							   __FILE__, __FUNCTION__, __LINE__,\
							   data.freq, data.power, data.start_neighbor,data.start_alarm_report, data.neighbor_period);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(NM_COMBINED_DATA));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy((unsigned char *)&data, requests->requestvb->val.string, sizeof(NM_COMBINED_DATA));
			if((data.freq!=0xFFFFFFFF)&&((data.freq<MIN_FREQ)||(data.freq>MAX_FREQ)))
			{
			    printf("set freq=%d not in 350000000~400000000 or 0xffffffff\n",data.freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
			    if(data.power!=0xff)
			    {
					for(i=0;i<5;i++)
					{
						if(data.power==power_range[i])
						{
							flag=1;
							break;
						}
					}
			    }
				else
				{
				    flag=1;
				}

				if(!flag)
				{
					printf("set power=%d not in1,5,10,16,20\n",data.power);
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				}
				else
				{
				    flag=0;
                    if((data.neighbor_period!=0xFFFF)&&((data.neighbor_period<MIN_PERIOD)||(data.neighbor_period>MAX_PERIOD)||(data.neighbor_period % 2)))
				    {
						printf("set neighborperiod=%d not in 2,4,6...20\n",data.neighbor_period);
						netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
					}
					else
					{
						sem_nm_p();
						shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
						sem_nm_v();
							
						if (is_local_dev(this_id))
						{
							send_local_nm_set_cmd(CMD_CODE_COMBINED_DATA, (unsigned char *)&data);
						}
						else
						{
							send_remote_nm_set_cmd(CMD_CODE_COMBINED_DATA, this_id, (unsigned char *)&data);
						}
							
						for (i = 0; i < timeout_cnt; i++)
						{
							delay.tv_sec = 0;
							delay.tv_usec = POLLING_INTERVA;
							select(0, NULL, NULL, NULL, &delay);
							if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
							{
								break;
							}
						}
						if (i == timeout_cnt)
						{
							netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
						}
					}
					
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id8CombinedDataPacket\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id9CombinedDataPacket(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_9;
	NM_COMBINED_DATA data;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_COMBINED_DATA);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_COMBINED_DATA, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->combined_data.data,sizeof(NM_COMBINED_DATA));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, \
							   "\n |%s||%s||%d|\n"
							   "\r MODE_GET freq                : 0x%X\n"
							   "\r MODE_GET power               : 0x%X\n"
							   "\r MODE_GET start_neighbor      : 0x%X\n"
							   "\r MODE_GET start_alarm_report  : 0x%X\n"
							   "\r MODE_GET neighbor_period     : 0x%X\n",\
							   __FILE__, __FUNCTION__, __LINE__,\
							   data.freq, data.power, data.start_neighbor,data.start_alarm_report, data.neighbor_period);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(NM_COMBINED_DATA));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy((unsigned char *)&data, requests->requestvb->val.string, sizeof(NM_COMBINED_DATA));
			if((data.freq!=0xFFFFFFFF)&&((data.freq<MIN_FREQ)||(data.freq>MAX_FREQ)))
			{
			    printf("set freq=%d not in 350000000~400000000 or 0xffffffff\n",data.freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
			    if(data.power!=0xff)
			    {
					for(i=0;i<5;i++)
					{
						if(data.power==power_range[i])
						{
							flag=1;
							break;
						}
					}
			    }
				else
				{
				    flag=1;
				}

				if(!flag)
				{
					printf("set power=%d not in1,5,10,16,20\n",data.power);
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				}
				else
				{
				    flag=0;
                    if((data.neighbor_period!=0xFFFF)&&((data.neighbor_period<MIN_PERIOD)||(data.neighbor_period>MAX_PERIOD)||(data.neighbor_period % 2)))
				    {
						printf("set neighborperiod=%d not in 2,4,6...20\n",data.neighbor_period);
						netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
					}
					else
					{
						sem_nm_p();
						shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
						sem_nm_v();
							
						if (is_local_dev(this_id))
						{
							send_local_nm_set_cmd(CMD_CODE_COMBINED_DATA, (unsigned char *)&data);
						}
						else
						{
							send_remote_nm_set_cmd(CMD_CODE_COMBINED_DATA, this_id, (unsigned char *)&data);
						}
							
						for (i = 0; i < timeout_cnt; i++)
						{
							delay.tv_sec = 0;
							delay.tv_usec = POLLING_INTERVA;
							select(0, NULL, NULL, NULL, &delay);
							if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
							{
								break;
							}
						}
						if (i == timeout_cnt)
						{
							netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
						}
					}
					
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id9CombinedDataPacket\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_id10CombinedDataPacket(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_10;
	NM_COMBINED_DATA data;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_COMBINED_DATA);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_COMBINED_DATA, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->combined_data.data,sizeof(NM_COMBINED_DATA));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, \
							   "\n |%s||%s||%d|\n"
							   "\r MODE_GET freq                : 0x%X\n"
							   "\r MODE_GET power               : 0x%X\n"
							   "\r MODE_GET start_neighbor      : 0x%X\n"
							   "\r MODE_GET start_alarm_report  : 0x%X\n"
							   "\r MODE_GET neighbor_period     : 0x%X\n",\
							   __FILE__, __FUNCTION__, __LINE__,\
							   data.freq, data.power, data.start_neighbor,data.start_alarm_report, data.neighbor_period);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(NM_COMBINED_DATA));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy((unsigned char *)&data, requests->requestvb->val.string, sizeof(NM_COMBINED_DATA));
			if((data.freq!=0xFFFFFFFF)&&((data.freq<MIN_FREQ)||(data.freq>MAX_FREQ)))
			{
			    printf("set freq=%d not in 350000000~400000000 or 0xffffffff\n",data.freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
			    if(data.power!=0xff)
			    {
					for(i=0;i<5;i++)
					{
						if(data.power==power_range[i])
						{
							flag=1;
							break;
						}
					}
			    }
				else
				{
				    flag=1;
				}

				if(!flag)
				{
					printf("set power=%d not in1,5,10,16,20\n",data.power);
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				}
				else
				{
				    flag=0;
                    if((data.neighbor_period!=0xFFFF)&&((data.neighbor_period<MIN_PERIOD)||(data.neighbor_period>MAX_PERIOD)||(data.neighbor_period % 2)))
				    {
						printf("set neighborperiod=%d not in 2,4,6...20\n",data.neighbor_period);
						netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
					}
					else
					{
						sem_nm_p();
						shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
						sem_nm_v();
							
						if (is_local_dev(this_id))
						{
							send_local_nm_set_cmd(CMD_CODE_COMBINED_DATA, (unsigned char *)&data);
						}
						else
						{
							send_remote_nm_set_cmd(CMD_CODE_COMBINED_DATA, this_id, (unsigned char *)&data);
						}
							
						for (i = 0; i < timeout_cnt; i++)
						{
							delay.tv_sec = 0;
							delay.tv_usec = POLLING_INTERVA;
							select(0, NULL, NULL, NULL, &delay);
							if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
							{
								break;
							}
						}
						if (i == timeout_cnt)
						{
							netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
						}
					}
					
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id10CombinedDataPacket\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id11CombinedDataPacket(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_11;
	NM_COMBINED_DATA data;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_COMBINED_DATA);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_COMBINED_DATA, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->combined_data.data,sizeof(NM_COMBINED_DATA));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, \
							   "\n |%s||%s||%d|\n"
							   "\r MODE_GET freq                : 0x%X\n"
							   "\r MODE_GET power               : 0x%X\n"
							   "\r MODE_GET start_neighbor      : 0x%X\n"
							   "\r MODE_GET start_alarm_report  : 0x%X\n"
							   "\r MODE_GET neighbor_period     : 0x%X\n",\
							   __FILE__, __FUNCTION__, __LINE__,\
							   data.freq, data.power, data.start_neighbor,data.start_alarm_report, data.neighbor_period);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(NM_COMBINED_DATA));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy((unsigned char *)&data, requests->requestvb->val.string, sizeof(NM_COMBINED_DATA));
			if((data.freq!=0xFFFFFFFF)&&((data.freq<MIN_FREQ)||(data.freq>MAX_FREQ)))
			{
			    printf("set freq=%d not in 350000000~400000000 or 0xffffffff\n",data.freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
			    if(data.power!=0xff)
			    {
					for(i=0;i<5;i++)
					{
						if(data.power==power_range[i])
						{
							flag=1;
							break;
						}
					}
			    }
				else
				{
				    flag=1;
				}

				if(!flag)
				{
					printf("set power=%d not in1,5,10,16,20\n",data.power);
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				}
				else
				{
				    flag=0;
                    if((data.neighbor_period!=0xFFFF)&&((data.neighbor_period<MIN_PERIOD)||(data.neighbor_period>MAX_PERIOD)||(data.neighbor_period % 2)))
				    {
						printf("set neighborperiod=%d not in 2,4,6...20\n",data.neighbor_period);
						netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
					}
					else
					{
						sem_nm_p();
						shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
						sem_nm_v();
							
						if (is_local_dev(this_id))
						{
							send_local_nm_set_cmd(CMD_CODE_COMBINED_DATA, (unsigned char *)&data);
						}
						else
						{
							send_remote_nm_set_cmd(CMD_CODE_COMBINED_DATA, this_id, (unsigned char *)&data);
						}
							
						for (i = 0; i < timeout_cnt; i++)
						{
							delay.tv_sec = 0;
							delay.tv_usec = POLLING_INTERVA;
							select(0, NULL, NULL, NULL, &delay);
							if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
							{
								break;
							}
						}
						if (i == timeout_cnt)
						{
							netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
						}
					}
					
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id11CombinedDataPacket\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id12CombinedDataPacket(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_12;
	NM_COMBINED_DATA data;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_COMBINED_DATA);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_COMBINED_DATA, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->combined_data.data,sizeof(NM_COMBINED_DATA));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, \
							   "\n |%s||%s||%d|\n"
							   "\r MODE_GET freq                : 0x%X\n"
							   "\r MODE_GET power               : 0x%X\n"
							   "\r MODE_GET start_neighbor      : 0x%X\n"
							   "\r MODE_GET start_alarm_report  : 0x%X\n"
							   "\r MODE_GET neighbor_period     : 0x%X\n",\
							   __FILE__, __FUNCTION__, __LINE__,\
							   data.freq, data.power, data.start_neighbor,data.start_alarm_report, data.neighbor_period);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(NM_COMBINED_DATA));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy((unsigned char *)&data, requests->requestvb->val.string, sizeof(NM_COMBINED_DATA));
			if((data.freq!=0xFFFFFFFF)&&((data.freq<MIN_FREQ)||(data.freq>MAX_FREQ)))
			{
			    printf("set freq=%d not in 350000000~400000000 or 0xffffffff\n",data.freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
			    if(data.power!=0xff)
			    {
					for(i=0;i<5;i++)
					{
						if(data.power==power_range[i])
						{
							flag=1;
							break;
						}
					}
			    }
				else
				{
				    flag=1;
				}

				if(!flag)
				{
					printf("set power=%d not in1,5,10,16,20\n",data.power);
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				}
				else
				{
				    flag=0;
                    if((data.neighbor_period!=0xFFFF)&&((data.neighbor_period<MIN_PERIOD)||(data.neighbor_period>MAX_PERIOD)||(data.neighbor_period % 2)))
				    {
						printf("set neighborperiod=%d not in 2,4,6...20\n",data.neighbor_period);
						netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
					}
					else
					{
						sem_nm_p();
						shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
						sem_nm_v();
							
						if (is_local_dev(this_id))
						{
							send_local_nm_set_cmd(CMD_CODE_COMBINED_DATA, (unsigned char *)&data);
						}
						else
						{
							send_remote_nm_set_cmd(CMD_CODE_COMBINED_DATA, this_id, (unsigned char *)&data);
						}
							
						for (i = 0; i < timeout_cnt; i++)
						{
							delay.tv_sec = 0;
							delay.tv_usec = POLLING_INTERVA;
							select(0, NULL, NULL, NULL, &delay);
							if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
							{
								break;
							}
						}
						if (i == timeout_cnt)
						{
							netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
						}
					}
					
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id12CombinedDataPacket\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



int
handle_id13CombinedDataPacket(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_13;
	NM_COMBINED_DATA data;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_COMBINED_DATA);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_COMBINED_DATA, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->combined_data.data,sizeof(NM_COMBINED_DATA));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, \
							   "\n |%s||%s||%d|\n"
							   "\r MODE_GET freq                : 0x%X\n"
							   "\r MODE_GET power               : 0x%X\n"
							   "\r MODE_GET start_neighbor      : 0x%X\n"
							   "\r MODE_GET start_alarm_report  : 0x%X\n"
							   "\r MODE_GET neighbor_period     : 0x%X\n",\
							   __FILE__, __FUNCTION__, __LINE__,\
							   data.freq, data.power, data.start_neighbor,data.start_alarm_report, data.neighbor_period);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(NM_COMBINED_DATA));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy((unsigned char *)&data, requests->requestvb->val.string, sizeof(NM_COMBINED_DATA));
			if((data.freq!=0xFFFFFFFF)&&((data.freq<MIN_FREQ)||(data.freq>MAX_FREQ)))
			{
			    printf("set freq=%d not in 350000000~400000000 or 0xffffffff\n",data.freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
			    if(data.power!=0xff)
			    {
					for(i=0;i<5;i++)
					{
						if(data.power==power_range[i])
						{
							flag=1;
							break;
						}
					}
			    }
				else
				{
				    flag=1;
				}

				if(!flag)
				{
					printf("set power=%d not in1,5,10,16,20\n",data.power);
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				}
				else
				{
				    flag=0;
                    if((data.neighbor_period!=0xFFFF)&&((data.neighbor_period<MIN_PERIOD)||(data.neighbor_period>MAX_PERIOD)||(data.neighbor_period % 2)))
				    {
						printf("set neighborperiod=%d not in 2,4,6...20\n",data.neighbor_period);
						netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
					}
					else
					{
						sem_nm_p();
						shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
						sem_nm_v();
							
						if (is_local_dev(this_id))
						{
							send_local_nm_set_cmd(CMD_CODE_COMBINED_DATA, (unsigned char *)&data);
						}
						else
						{
							send_remote_nm_set_cmd(CMD_CODE_COMBINED_DATA, this_id, (unsigned char *)&data);
						}
							
						for (i = 0; i < timeout_cnt; i++)
						{
							delay.tv_sec = 0;
							delay.tv_usec = POLLING_INTERVA;
							select(0, NULL, NULL, NULL, &delay);
							if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
							{
								break;
							}
						}
						if (i == timeout_cnt)
						{
							netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
						}
					}
					
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id13CombinedDataPacket\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id14CombinedDataPacket(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_14;
	NM_COMBINED_DATA data;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_COMBINED_DATA);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_COMBINED_DATA, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->combined_data.data,sizeof(NM_COMBINED_DATA));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, \
							   "\n |%s||%s||%d|\n"
							   "\r MODE_GET freq                : 0x%X\n"
							   "\r MODE_GET power               : 0x%X\n"
							   "\r MODE_GET start_neighbor      : 0x%X\n"
							   "\r MODE_GET start_alarm_report  : 0x%X\n"
							   "\r MODE_GET neighbor_period     : 0x%X\n",\
							   __FILE__, __FUNCTION__, __LINE__,\
							   data.freq, data.power, data.start_neighbor,data.start_alarm_report, data.neighbor_period);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(NM_COMBINED_DATA));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy((unsigned char *)&data, requests->requestvb->val.string, sizeof(NM_COMBINED_DATA));
			if((data.freq!=0xFFFFFFFF)&&((data.freq<MIN_FREQ)||(data.freq>MAX_FREQ)))
			{
			    printf("set freq=%d not in 350000000~400000000 or 0xffffffff\n",data.freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
			    if(data.power!=0xff)
			    {
					for(i=0;i<5;i++)
					{
						if(data.power==power_range[i])
						{
							flag=1;
							break;
						}
					}
			    }
				else
				{
				    flag=1;
				}

				if(!flag)
				{
					printf("set power=%d not in1,5,10,16,20\n",data.power);
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				}
				else
				{
				    flag=0;
                    if((data.neighbor_period!=0xFFFF)&&((data.neighbor_period<MIN_PERIOD)||(data.neighbor_period>MAX_PERIOD)||(data.neighbor_period % 2)))
				    {
						printf("set neighborperiod=%d not in 2,4,6...20\n",data.neighbor_period);
						netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
					}
					else
					{
						sem_nm_p();
						shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
						sem_nm_v();
							
						if (is_local_dev(this_id))
						{
							send_local_nm_set_cmd(CMD_CODE_COMBINED_DATA, (unsigned char *)&data);
						}
						else
						{
							send_remote_nm_set_cmd(CMD_CODE_COMBINED_DATA, this_id, (unsigned char *)&data);
						}
							
						for (i = 0; i < timeout_cnt; i++)
						{
							delay.tv_sec = 0;
							delay.tv_usec = POLLING_INTERVA;
							select(0, NULL, NULL, NULL, &delay);
							if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
							{
								break;
							}
						}
						if (i == timeout_cnt)
						{
							netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
						}
					}
					
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id14CombinedDataPacket\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id15CombinedDataPacket(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_15;
	NM_COMBINED_DATA data;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_COMBINED_DATA);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_COMBINED_DATA, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->combined_data.data,sizeof(NM_COMBINED_DATA));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, \
							   "\n |%s||%s||%d|\n"
							   "\r MODE_GET freq                : 0x%X\n"
							   "\r MODE_GET power               : 0x%X\n"
							   "\r MODE_GET start_neighbor      : 0x%X\n"
							   "\r MODE_GET start_alarm_report  : 0x%X\n"
							   "\r MODE_GET neighbor_period     : 0x%X\n",\
							   __FILE__, __FUNCTION__, __LINE__,\
							   data.freq, data.power, data.start_neighbor,data.start_alarm_report, data.neighbor_period);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(NM_COMBINED_DATA));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy((unsigned char *)&data, requests->requestvb->val.string, sizeof(NM_COMBINED_DATA));
			if((data.freq!=0xFFFFFFFF)&&((data.freq<MIN_FREQ)||(data.freq>MAX_FREQ)))
			{
			    printf("set freq=%d not in 350000000~400000000 or 0xffffffff\n",data.freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
			    if(data.power!=0xff)
			    {
					for(i=0;i<5;i++)
					{
						if(data.power==power_range[i])
						{
							flag=1;
							break;
						}
					}
			    }
				else
				{
				    flag=1;
				}

				if(!flag)
				{
					printf("set power=%d not in1,5,10,16,20\n",data.power);
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				}
				else
				{
				    flag=0;
                    if((data.neighbor_period!=0xFFFF)&&((data.neighbor_period<MIN_PERIOD)||(data.neighbor_period>MAX_PERIOD)||(data.neighbor_period % 2)))
				    {
						printf("set neighborperiod=%d not in 2,4,6...20\n",data.neighbor_period);
						netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
					}
					else
					{
						sem_nm_p();
						shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
						sem_nm_v();
							
						if (is_local_dev(this_id))
						{
							send_local_nm_set_cmd(CMD_CODE_COMBINED_DATA, (unsigned char *)&data);
						}
						else
						{
							send_remote_nm_set_cmd(CMD_CODE_COMBINED_DATA, this_id, (unsigned char *)&data);
						}
							
						for (i = 0; i < timeout_cnt; i++)
						{
							delay.tv_sec = 0;
							delay.tv_usec = POLLING_INTERVA;
							select(0, NULL, NULL, NULL, &delay);
							if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
							{
								break;
							}
						}
						if (i == timeout_cnt)
						{
							netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
						}
					}
					
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id15CombinedDataPacket\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



int
handle_id16CombinedDataPacket(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_1;
	NM_COMBINED_DATA data;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_COMBINED_DATA);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_COMBINED_DATA, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->combined_data.data,sizeof(NM_COMBINED_DATA));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, \
							   "\n |%s||%s||%d|\n"
							   "\r MODE_GET freq                : 0x%X\n"
							   "\r MODE_GET power               : 0x%X\n"
							   "\r MODE_GET start_neighbor      : 0x%X\n"
							   "\r MODE_GET start_alarm_report  : 0x%X\n"
							   "\r MODE_GET neighbor_period     : 0x%X\n",\
							   __FILE__, __FUNCTION__, __LINE__,\
							   data.freq, data.power, data.start_neighbor,data.start_alarm_report, data.neighbor_period);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(NM_COMBINED_DATA));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy((unsigned char *)&data, requests->requestvb->val.string, sizeof(NM_COMBINED_DATA));
			if((data.freq!=0xFFFFFFFF)&&((data.freq<MIN_FREQ)||(data.freq>MAX_FREQ)))
			{
			    printf("set freq=%d not in 350000000~400000000 or 0xffffffff\n",data.freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
			    if(data.power!=0xff)
			    {
					for(i=0;i<5;i++)
					{
						if(data.power==power_range[i])
						{
							flag=1;
							break;
						}
					}
			    }
				else
				{
				    flag=1;
				}

				if(!flag)
				{
					printf("set power=%d not in1,5,10,16,20\n",data.power);
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				}
				else
				{
				    flag=0;
                    if((data.neighbor_period!=0xFFFF)&&((data.neighbor_period<MIN_PERIOD)||(data.neighbor_period>MAX_PERIOD)||(data.neighbor_period % 2)))
				    {
						printf("set neighborperiod=%d not in 2,4,6...20\n",data.neighbor_period);
						netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
					}
					else
					{
						sem_nm_p();
						shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
						sem_nm_v();
							
						if (is_local_dev(this_id))
						{
							send_local_nm_set_cmd(CMD_CODE_COMBINED_DATA, (unsigned char *)&data);
						}
						else
						{
							send_remote_nm_set_cmd(CMD_CODE_COMBINED_DATA, this_id, (unsigned char *)&data);
						}
							
						for (i = 0; i < timeout_cnt; i++)
						{
							delay.tv_sec = 0;
							delay.tv_usec = POLLING_INTERVA;
							select(0, NULL, NULL, NULL, &delay);
							if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
							{
								break;
							}
						}
						if (i == timeout_cnt)
						{
							netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
						}
					}
					
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id16CombinedDataPacket\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id17CombinedDataPacket(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_17;
	NM_COMBINED_DATA data;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_COMBINED_DATA);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_COMBINED_DATA, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->combined_data.data,sizeof(NM_COMBINED_DATA));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, \
							   "\n |%s||%s||%d|\n"
							   "\r MODE_GET freq                : 0x%X\n"
							   "\r MODE_GET power               : 0x%X\n"
							   "\r MODE_GET start_neighbor      : 0x%X\n"
							   "\r MODE_GET start_alarm_report  : 0x%X\n"
							   "\r MODE_GET neighbor_period     : 0x%X\n",\
							   __FILE__, __FUNCTION__, __LINE__,\
							   data.freq, data.power, data.start_neighbor,data.start_alarm_report, data.neighbor_period);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(NM_COMBINED_DATA));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy((unsigned char *)&data, requests->requestvb->val.string, sizeof(NM_COMBINED_DATA));
			if((data.freq!=0xFFFFFFFF)&&((data.freq<MIN_FREQ)||(data.freq>MAX_FREQ)))
			{
			    printf("set freq=%d not in 350000000~400000000 or 0xffffffff\n",data.freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
			    if(data.power!=0xff)
			    {
					for(i=0;i<5;i++)
					{
						if(data.power==power_range[i])
						{
							flag=1;
							break;
						}
					}
			    }
				else
				{
				    flag=1;
				}

				if(!flag)
				{
					printf("set power=%d not in1,5,10,16,20\n",data.power);
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				}
				else
				{
				    flag=0;
                    if((data.neighbor_period!=0xFFFF)&&((data.neighbor_period<MIN_PERIOD)||(data.neighbor_period>MAX_PERIOD)||(data.neighbor_period % 2)))
				    {
						printf("set neighborperiod=%d not in 2,4,6...20\n",data.neighbor_period);
						netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
					}
					else
					{
						sem_nm_p();
						shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
						sem_nm_v();
							
						if (is_local_dev(this_id))
						{
							send_local_nm_set_cmd(CMD_CODE_COMBINED_DATA, (unsigned char *)&data);
						}
						else
						{
							send_remote_nm_set_cmd(CMD_CODE_COMBINED_DATA, this_id, (unsigned char *)&data);
						}
							
						for (i = 0; i < timeout_cnt; i++)
						{
							delay.tv_sec = 0;
							delay.tv_usec = POLLING_INTERVA;
							select(0, NULL, NULL, NULL, &delay);
							if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
							{
								break;
							}
						}
						if (i == timeout_cnt)
						{
							netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
						}
					}
					
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id17CombinedDataPacket\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id18CombinedDataPacket(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_18;
	NM_COMBINED_DATA data;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_COMBINED_DATA);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_COMBINED_DATA, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->combined_data.data,sizeof(NM_COMBINED_DATA));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, \
							   "\n |%s||%s||%d|\n"
							   "\r MODE_GET freq                : 0x%X\n"
							   "\r MODE_GET power               : 0x%X\n"
							   "\r MODE_GET start_neighbor      : 0x%X\n"
							   "\r MODE_GET start_alarm_report  : 0x%X\n"
							   "\r MODE_GET neighbor_period     : 0x%X\n",\
							   __FILE__, __FUNCTION__, __LINE__,\
							   data.freq, data.power, data.start_neighbor,data.start_alarm_report, data.neighbor_period);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(NM_COMBINED_DATA));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy((unsigned char *)&data, requests->requestvb->val.string, sizeof(NM_COMBINED_DATA));
			if((data.freq!=0xFFFFFFFF)&&((data.freq<MIN_FREQ)||(data.freq>MAX_FREQ)))
			{
			    printf("set freq=%d not in 350000000~400000000 or 0xffffffff\n",data.freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
			    if(data.power!=0xff)
			    {
					for(i=0;i<5;i++)
					{
						if(data.power==power_range[i])
						{
							flag=1;
							break;
						}
					}
			    }
				else
				{
				    flag=1;
				}

				if(!flag)
				{
					printf("set power=%d not in1,5,10,16,20\n",data.power);
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				}
				else
				{
				    flag=0;
                    if((data.neighbor_period!=0xFFFF)&&((data.neighbor_period<MIN_PERIOD)||(data.neighbor_period>MAX_PERIOD)||(data.neighbor_period % 2)))
				    {
						printf("set neighborperiod=%d not in 2,4,6...20\n",data.neighbor_period);
						netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
					}
					else
					{
						sem_nm_p();
						shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
						sem_nm_v();
							
						if (is_local_dev(this_id))
						{
							send_local_nm_set_cmd(CMD_CODE_COMBINED_DATA, (unsigned char *)&data);
						}
						else
						{
							send_remote_nm_set_cmd(CMD_CODE_COMBINED_DATA, this_id, (unsigned char *)&data);
						}
							
						for (i = 0; i < timeout_cnt; i++)
						{
							delay.tv_sec = 0;
							delay.tv_usec = POLLING_INTERVA;
							select(0, NULL, NULL, NULL, &delay);
							if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
							{
								break;
							}
						}
						if (i == timeout_cnt)
						{
							netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
						}
					}
					
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id18CombinedDataPacket\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id19CombinedDataPacket(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_19;
	NM_COMBINED_DATA data;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_COMBINED_DATA);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_COMBINED_DATA, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->combined_data.data,sizeof(NM_COMBINED_DATA));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, \
							   "\n |%s||%s||%d|\n"
							   "\r MODE_GET freq                : 0x%X\n"
							   "\r MODE_GET power               : 0x%X\n"
							   "\r MODE_GET start_neighbor      : 0x%X\n"
							   "\r MODE_GET start_alarm_report  : 0x%X\n"
							   "\r MODE_GET neighbor_period     : 0x%X\n",\
							   __FILE__, __FUNCTION__, __LINE__,\
							   data.freq, data.power, data.start_neighbor,data.start_alarm_report, data.neighbor_period);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(NM_COMBINED_DATA));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy((unsigned char *)&data, requests->requestvb->val.string, sizeof(NM_COMBINED_DATA));
			if((data.freq!=0xFFFFFFFF)&&((data.freq<MIN_FREQ)||(data.freq>MAX_FREQ)))
			{
			    printf("set freq=%d not in 350000000~400000000 or 0xffffffff\n",data.freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
			    if(data.power!=0xff)
			    {
					for(i=0;i<5;i++)
					{
						if(data.power==power_range[i])
						{
							flag=1;
							break;
						}
					}
			    }
				else
				{
				    flag=1;
				}

				if(!flag)
				{
					printf("set power=%d not in1,5,10,16,20\n",data.power);
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				}
				else
				{
				    flag=0;
                    if((data.neighbor_period!=0xFFFF)&&((data.neighbor_period<MIN_PERIOD)||(data.neighbor_period>MAX_PERIOD)||(data.neighbor_period % 2)))
				    {
						printf("set neighborperiod=%d not in 2,4,6...20\n",data.neighbor_period);
						netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
					}
					else
					{
						sem_nm_p();
						shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
						sem_nm_v();
							
						if (is_local_dev(this_id))
						{
							send_local_nm_set_cmd(CMD_CODE_COMBINED_DATA, (unsigned char *)&data);
						}
						else
						{
							send_remote_nm_set_cmd(CMD_CODE_COMBINED_DATA, this_id, (unsigned char *)&data);
						}
							
						for (i = 0; i < timeout_cnt; i++)
						{
							delay.tv_sec = 0;
							delay.tv_usec = POLLING_INTERVA;
							select(0, NULL, NULL, NULL, &delay);
							if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
							{
								break;
							}
						}
						if (i == timeout_cnt)
						{
							netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
						}
					}
					
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id19CombinedDataPacket\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



int
handle_id20CombinedDataPacket(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_20;
	NM_COMBINED_DATA data;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_COMBINED_DATA);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_COMBINED_DATA, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->combined_data.data,sizeof(NM_COMBINED_DATA));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, \
							   "\n |%s||%s||%d|\n"
							   "\r MODE_GET freq                : 0x%X\n"
							   "\r MODE_GET power               : 0x%X\n"
							   "\r MODE_GET start_neighbor      : 0x%X\n"
							   "\r MODE_GET start_alarm_report  : 0x%X\n"
							   "\r MODE_GET neighbor_period     : 0x%X\n",\
							   __FILE__, __FUNCTION__, __LINE__,\
							   data.freq, data.power, data.start_neighbor,data.start_alarm_report, data.neighbor_period);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(NM_COMBINED_DATA));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy((unsigned char *)&data, requests->requestvb->val.string, sizeof(NM_COMBINED_DATA));
			if((data.freq!=0xFFFFFFFF)&&((data.freq<MIN_FREQ)||(data.freq>MAX_FREQ)))
			{
			    printf("set freq=%d not in 350000000~400000000 or 0xffffffff\n",data.freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
			    if(data.power!=0xff)
			    {
					for(i=0;i<5;i++)
					{
						if(data.power==power_range[i])
						{
							flag=1;
							break;
						}
					}
			    }
				else
				{
				    flag=1;
				}

				if(!flag)
				{
					printf("set power=%d not in1,5,10,16,20\n",data.power);
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				}
				else
				{
				    flag=0;
                    if((data.neighbor_period!=0xFFFF)&&((data.neighbor_period<MIN_PERIOD)||(data.neighbor_period>MAX_PERIOD)||(data.neighbor_period % 2)))
				    {
						printf("set neighborperiod=%d not in 2,4,6...20\n",data.neighbor_period);
						netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
					}
					else
					{
						sem_nm_p();
						shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
						sem_nm_v();
							
						if (is_local_dev(this_id))
						{
							send_local_nm_set_cmd(CMD_CODE_COMBINED_DATA, (unsigned char *)&data);
						}
						else
						{
							send_remote_nm_set_cmd(CMD_CODE_COMBINED_DATA, this_id, (unsigned char *)&data);
						}
							
						for (i = 0; i < timeout_cnt; i++)
						{
							delay.tv_sec = 0;
							delay.tv_usec = POLLING_INTERVA;
							select(0, NULL, NULL, NULL, &delay);
							if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
							{
								break;
							}
						}
						if (i == timeout_cnt)
						{
							netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
						}
					}
					
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id20CombinedDataPacket\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_id21CombinedDataPacket(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_21;
	NM_COMBINED_DATA data;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_COMBINED_DATA);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_COMBINED_DATA, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->combined_data.data,sizeof(NM_COMBINED_DATA));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, \
							   "\n |%s||%s||%d|\n"
							   "\r MODE_GET freq                : 0x%X\n"
							   "\r MODE_GET power               : 0x%X\n"
							   "\r MODE_GET start_neighbor      : 0x%X\n"
							   "\r MODE_GET start_alarm_report  : 0x%X\n"
							   "\r MODE_GET neighbor_period     : 0x%X\n",\
							   __FILE__, __FUNCTION__, __LINE__,\
							   data.freq, data.power, data.start_neighbor,data.start_alarm_report, data.neighbor_period);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(NM_COMBINED_DATA));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy((unsigned char *)&data, requests->requestvb->val.string, sizeof(NM_COMBINED_DATA));
			if((data.freq!=0xFFFFFFFF)&&((data.freq<MIN_FREQ)||(data.freq>MAX_FREQ)))
			{
			    printf("set freq=%d not in 350000000~400000000 or 0xffffffff\n",data.freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
			    if(data.power!=0xff)
			    {
					for(i=0;i<5;i++)
					{
						if(data.power==power_range[i])
						{
							flag=1;
							break;
						}
					}
			    }
				else
				{
				    flag=1;
				}

				if(!flag)
				{
					printf("set power=%d not in1,5,10,16,20\n",data.power);
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				}
				else
				{
				    flag=0;
                    if((data.neighbor_period!=0xFFFF)&&((data.neighbor_period<MIN_PERIOD)||(data.neighbor_period>MAX_PERIOD)||(data.neighbor_period % 2)))
				    {
						printf("set neighborperiod=%d not in 2,4,6...20\n",data.neighbor_period);
						netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
					}
					else
					{
						sem_nm_p();
						shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
						sem_nm_v();
							
						if (is_local_dev(this_id))
						{
							send_local_nm_set_cmd(CMD_CODE_COMBINED_DATA, (unsigned char *)&data);
						}
						else
						{
							send_remote_nm_set_cmd(CMD_CODE_COMBINED_DATA, this_id, (unsigned char *)&data);
						}
							
						for (i = 0; i < timeout_cnt; i++)
						{
							delay.tv_sec = 0;
							delay.tv_usec = POLLING_INTERVA;
							select(0, NULL, NULL, NULL, &delay);
							if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
							{
								break;
							}
						}
						if (i == timeout_cnt)
						{
							netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
						}
					}
					
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id21CombinedDataPacket\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id22CombinedDataPacket(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_22;
	NM_COMBINED_DATA data;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_COMBINED_DATA);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_COMBINED_DATA, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->combined_data.data,sizeof(NM_COMBINED_DATA));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, \
							   "\n |%s||%s||%d|\n"
							   "\r MODE_GET freq                : 0x%X\n"
							   "\r MODE_GET power               : 0x%X\n"
							   "\r MODE_GET start_neighbor      : 0x%X\n"
							   "\r MODE_GET start_alarm_report  : 0x%X\n"
							   "\r MODE_GET neighbor_period     : 0x%X\n",\
							   __FILE__, __FUNCTION__, __LINE__,\
							   data.freq, data.power, data.start_neighbor,data.start_alarm_report, data.neighbor_period);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(NM_COMBINED_DATA));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy((unsigned char *)&data, requests->requestvb->val.string, sizeof(NM_COMBINED_DATA));
			if((data.freq!=0xFFFFFFFF)&&((data.freq<MIN_FREQ)||(data.freq>MAX_FREQ)))
			{
			    printf("set freq=%d not in 350000000~400000000 or 0xffffffff\n",data.freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
			    if(data.power!=0xff)
			    {
					for(i=0;i<5;i++)
					{
						if(data.power==power_range[i])
						{
							flag=1;
							break;
						}
					}
			    }
				else
				{
				    flag=1;
				}

				if(!flag)
				{
					printf("set power=%d not in1,5,10,16,20\n",data.power);
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				}
				else
				{
				    flag=0;
                    if((data.neighbor_period!=0xFFFF)&&((data.neighbor_period<MIN_PERIOD)||(data.neighbor_period>MAX_PERIOD)||(data.neighbor_period % 2)))
				    {
						printf("set neighborperiod=%d not in 2,4,6...20\n",data.neighbor_period);
						netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
					}
					else
					{
						sem_nm_p();
						shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
						sem_nm_v();
							
						if (is_local_dev(this_id))
						{
							send_local_nm_set_cmd(CMD_CODE_COMBINED_DATA, (unsigned char *)&data);
						}
						else
						{
							send_remote_nm_set_cmd(CMD_CODE_COMBINED_DATA, this_id, (unsigned char *)&data);
						}
							
						for (i = 0; i < timeout_cnt; i++)
						{
							delay.tv_sec = 0;
							delay.tv_usec = POLLING_INTERVA;
							select(0, NULL, NULL, NULL, &delay);
							if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
							{
								break;
							}
						}
						if (i == timeout_cnt)
						{
							netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
						}
					}
					
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id22CombinedDataPacket\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



int
handle_id23CombinedDataPacket(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_23;
	NM_COMBINED_DATA data;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_COMBINED_DATA);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_COMBINED_DATA, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->combined_data.data,sizeof(NM_COMBINED_DATA));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, \
							   "\n |%s||%s||%d|\n"
							   "\r MODE_GET freq                : 0x%X\n"
							   "\r MODE_GET power               : 0x%X\n"
							   "\r MODE_GET start_neighbor      : 0x%X\n"
							   "\r MODE_GET start_alarm_report  : 0x%X\n"
							   "\r MODE_GET neighbor_period     : 0x%X\n",\
							   __FILE__, __FUNCTION__, __LINE__,\
							   data.freq, data.power, data.start_neighbor,data.start_alarm_report, data.neighbor_period);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(NM_COMBINED_DATA));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy((unsigned char *)&data, requests->requestvb->val.string, sizeof(NM_COMBINED_DATA));
			if((data.freq!=0xFFFFFFFF)&&((data.freq<MIN_FREQ)||(data.freq>MAX_FREQ)))
			{
			    printf("set freq=%d not in 350000000~400000000 or 0xffffffff\n",data.freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
			    if(data.power!=0xff)
			    {
					for(i=0;i<5;i++)
					{
						if(data.power==power_range[i])
						{
							flag=1;
							break;
						}
					}
			    }
				else
				{
				    flag=1;
				}

				if(!flag)
				{
					printf("set power=%d not in1,5,10,16,20\n",data.power);
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				}
				else
				{
				    flag=0;
                    if((data.neighbor_period!=0xFFFF)&&((data.neighbor_period<MIN_PERIOD)||(data.neighbor_period>MAX_PERIOD)||(data.neighbor_period % 2)))
				    {
						printf("set neighborperiod=%d not in 2,4,6...20\n",data.neighbor_period);
						netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
					}
					else
					{
						sem_nm_p();
						shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
						sem_nm_v();
							
						if (is_local_dev(this_id))
						{
							send_local_nm_set_cmd(CMD_CODE_COMBINED_DATA, (unsigned char *)&data);
						}
						else
						{
							send_remote_nm_set_cmd(CMD_CODE_COMBINED_DATA, this_id, (unsigned char *)&data);
						}
							
						for (i = 0; i < timeout_cnt; i++)
						{
							delay.tv_sec = 0;
							delay.tv_usec = POLLING_INTERVA;
							select(0, NULL, NULL, NULL, &delay);
							if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
							{
								break;
							}
						}
						if (i == timeout_cnt)
						{
							netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
						}
					}
					
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id23CombinedDataPacket\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



int
handle_id24CombinedDataPacket(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_24;
	NM_COMBINED_DATA data;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_COMBINED_DATA);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_COMBINED_DATA, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->combined_data.data,sizeof(NM_COMBINED_DATA));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, \
							   "\n |%s||%s||%d|\n"
							   "\r MODE_GET freq                : 0x%X\n"
							   "\r MODE_GET power               : 0x%X\n"
							   "\r MODE_GET start_neighbor      : 0x%X\n"
							   "\r MODE_GET start_alarm_report  : 0x%X\n"
							   "\r MODE_GET neighbor_period     : 0x%X\n",\
							   __FILE__, __FUNCTION__, __LINE__,\
							   data.freq, data.power, data.start_neighbor,data.start_alarm_report, data.neighbor_period);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(NM_COMBINED_DATA));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy((unsigned char *)&data, requests->requestvb->val.string, sizeof(NM_COMBINED_DATA));
			if((data.freq!=0xFFFFFFFF)&&((data.freq<MIN_FREQ)||(data.freq>MAX_FREQ)))
			{
			    printf("set freq=%d not in 350000000~400000000 or 0xffffffff\n",data.freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
			    if(data.power!=0xff)
			    {
					for(i=0;i<5;i++)
					{
						if(data.power==power_range[i])
						{
							flag=1;
							break;
						}
					}
			    }
				else
				{
				    flag=1;
				}

				if(!flag)
				{
					printf("set power=%d not in1,5,10,16,20\n",data.power);
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				}
				else
				{
				    flag=0;
                    if((data.neighbor_period!=0xFFFF)&&((data.neighbor_period<MIN_PERIOD)||(data.neighbor_period>MAX_PERIOD)||(data.neighbor_period % 2)))
				    {
						printf("set neighborperiod=%d not in 2,4,6...20\n",data.neighbor_period);
						netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
					}
					else
					{
						sem_nm_p();
						shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
						sem_nm_v();
							
						if (is_local_dev(this_id))
						{
							send_local_nm_set_cmd(CMD_CODE_COMBINED_DATA, (unsigned char *)&data);
						}
						else
						{
							send_remote_nm_set_cmd(CMD_CODE_COMBINED_DATA, this_id, (unsigned char *)&data);
						}
							
						for (i = 0; i < timeout_cnt; i++)
						{
							delay.tv_sec = 0;
							delay.tv_usec = POLLING_INTERVA;
							select(0, NULL, NULL, NULL, &delay);
							if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
							{
								break;
							}
						}
						if (i == timeout_cnt)
						{
							netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
						}
					}
					
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id24CombinedDataPacket\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



int
handle_id25CombinedDataPacket(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_25;
	NM_COMBINED_DATA data;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_COMBINED_DATA);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_COMBINED_DATA, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->combined_data.data,sizeof(NM_COMBINED_DATA));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, \
							   "\n |%s||%s||%d|\n"
							   "\r MODE_GET freq                : 0x%X\n"
							   "\r MODE_GET power               : 0x%X\n"
							   "\r MODE_GET start_neighbor      : 0x%X\n"
							   "\r MODE_GET start_alarm_report  : 0x%X\n"
							   "\r MODE_GET neighbor_period     : 0x%X\n",\
							   __FILE__, __FUNCTION__, __LINE__,\
							   data.freq, data.power, data.start_neighbor,data.start_alarm_report, data.neighbor_period);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(NM_COMBINED_DATA));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy((unsigned char *)&data, requests->requestvb->val.string, sizeof(NM_COMBINED_DATA));
			if((data.freq!=0xFFFFFFFF)&&((data.freq<MIN_FREQ)||(data.freq>MAX_FREQ)))
			{
			    printf("set freq=%d not in 350000000~400000000 or 0xffffffff\n",data.freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
			    if(data.power!=0xff)
			    {
					for(i=0;i<5;i++)
					{
						if(data.power==power_range[i])
						{
							flag=1;
							break;
						}
					}
			    }
				else
				{
				    flag=1;
				}

				if(!flag)
				{
					printf("set power=%d not in1,5,10,16,20\n",data.power);
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				}
				else
				{
				    flag=0;
                    if((data.neighbor_period!=0xFFFF)&&((data.neighbor_period<MIN_PERIOD)||(data.neighbor_period>MAX_PERIOD)||(data.neighbor_period % 2)))
				    {
						printf("set neighborperiod=%d not in 2,4,6...20\n",data.neighbor_period);
						netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
					}
					else
					{
						sem_nm_p();
						shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
						sem_nm_v();
							
						if (is_local_dev(this_id))
						{
							send_local_nm_set_cmd(CMD_CODE_COMBINED_DATA, (unsigned char *)&data);
						}
						else
						{
							send_remote_nm_set_cmd(CMD_CODE_COMBINED_DATA, this_id, (unsigned char *)&data);
						}
							
						for (i = 0; i < timeout_cnt; i++)
						{
							delay.tv_sec = 0;
							delay.tv_usec = POLLING_INTERVA;
							select(0, NULL, NULL, NULL, &delay);
							if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
							{
								break;
							}
						}
						if (i == timeout_cnt)
						{
							netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
						}
					}
					
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id25CombinedDataPacket\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



int
handle_id26CombinedDataPacket(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_26;
	NM_COMBINED_DATA data;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_COMBINED_DATA);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_COMBINED_DATA, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->combined_data.data,sizeof(NM_COMBINED_DATA));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, \
							   "\n |%s||%s||%d|\n"
							   "\r MODE_GET freq                : 0x%X\n"
							   "\r MODE_GET power               : 0x%X\n"
							   "\r MODE_GET start_neighbor      : 0x%X\n"
							   "\r MODE_GET start_alarm_report  : 0x%X\n"
							   "\r MODE_GET neighbor_period     : 0x%X\n",\
							   __FILE__, __FUNCTION__, __LINE__,\
							   data.freq, data.power, data.start_neighbor,data.start_alarm_report, data.neighbor_period);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(NM_COMBINED_DATA));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy((unsigned char *)&data, requests->requestvb->val.string, sizeof(NM_COMBINED_DATA));
			if((data.freq!=0xFFFFFFFF)&&((data.freq<MIN_FREQ)||(data.freq>MAX_FREQ)))
			{
			    printf("set freq=%d not in 350000000~400000000 or 0xffffffff\n",data.freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
			    if(data.power!=0xff)
			    {
					for(i=0;i<5;i++)
					{
						if(data.power==power_range[i])
						{
							flag=1;
							break;
						}
					}
			    }
				else
				{
				    flag=1;
				}

				if(!flag)
				{
					printf("set power=%d not in1,5,10,16,20\n",data.power);
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				}
				else
				{
				    flag=0;
                    if((data.neighbor_period!=0xFFFF)&&((data.neighbor_period<MIN_PERIOD)||(data.neighbor_period>MAX_PERIOD)||(data.neighbor_period % 2)))
				    {
						printf("set neighborperiod=%d not in 2,4,6...20\n",data.neighbor_period);
						netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
					}
					else
					{
						sem_nm_p();
						shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
						sem_nm_v();
							
						if (is_local_dev(this_id))
						{
							send_local_nm_set_cmd(CMD_CODE_COMBINED_DATA, (unsigned char *)&data);
						}
						else
						{
							send_remote_nm_set_cmd(CMD_CODE_COMBINED_DATA, this_id, (unsigned char *)&data);
						}
							
						for (i = 0; i < timeout_cnt; i++)
						{
							delay.tv_sec = 0;
							delay.tv_usec = POLLING_INTERVA;
							select(0, NULL, NULL, NULL, &delay);
							if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
							{
								break;
							}
						}
						if (i == timeout_cnt)
						{
							netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
						}
					}
					
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id26CombinedDataPacket\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



int
handle_id27CombinedDataPacket(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_27;
	NM_COMBINED_DATA data;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_COMBINED_DATA);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_COMBINED_DATA, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->combined_data.data,sizeof(NM_COMBINED_DATA));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, \
							   "\n |%s||%s||%d|\n"
							   "\r MODE_GET freq                : 0x%X\n"
							   "\r MODE_GET power               : 0x%X\n"
							   "\r MODE_GET start_neighbor      : 0x%X\n"
							   "\r MODE_GET start_alarm_report  : 0x%X\n"
							   "\r MODE_GET neighbor_period     : 0x%X\n",\
							   __FILE__, __FUNCTION__, __LINE__,\
							   data.freq, data.power, data.start_neighbor,data.start_alarm_report, data.neighbor_period);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(NM_COMBINED_DATA));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy((unsigned char *)&data, requests->requestvb->val.string, sizeof(NM_COMBINED_DATA));
			if((data.freq!=0xFFFFFFFF)&&((data.freq<MIN_FREQ)||(data.freq>MAX_FREQ)))
			{
			    printf("set freq=%d not in 350000000~400000000 or 0xffffffff\n",data.freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
			    if(data.power!=0xff)
			    {
					for(i=0;i<5;i++)
					{
						if(data.power==power_range[i])
						{
							flag=1;
							break;
						}
					}
			    }
				else
				{
				    flag=1;
				}

				if(!flag)
				{
					printf("set power=%d not in1,5,10,16,20\n",data.power);
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				}
				else
				{
				    flag=0;
                    if((data.neighbor_period!=0xFFFF)&&((data.neighbor_period<MIN_PERIOD)||(data.neighbor_period>MAX_PERIOD)||(data.neighbor_period % 2)))
				    {
						printf("set neighborperiod=%d not in 2,4,6...20\n",data.neighbor_period);
						netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
					}
					else
					{
						sem_nm_p();
						shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
						sem_nm_v();
							
						if (is_local_dev(this_id))
						{
							send_local_nm_set_cmd(CMD_CODE_COMBINED_DATA, (unsigned char *)&data);
						}
						else
						{
							send_remote_nm_set_cmd(CMD_CODE_COMBINED_DATA, this_id, (unsigned char *)&data);
						}
							
						for (i = 0; i < timeout_cnt; i++)
						{
							delay.tv_sec = 0;
							delay.tv_usec = POLLING_INTERVA;
							select(0, NULL, NULL, NULL, &delay);
							if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
							{
								break;
							}
						}
						if (i == timeout_cnt)
						{
							netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
						}
					}
					
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id27CombinedDataPacket\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_id28CombinedDataPacket(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_28;
	NM_COMBINED_DATA data;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_COMBINED_DATA);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_COMBINED_DATA, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->combined_data.data,sizeof(NM_COMBINED_DATA));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, \
							   "\n |%s||%s||%d|\n"
							   "\r MODE_GET freq                : 0x%X\n"
							   "\r MODE_GET power               : 0x%X\n"
							   "\r MODE_GET start_neighbor      : 0x%X\n"
							   "\r MODE_GET start_alarm_report  : 0x%X\n"
							   "\r MODE_GET neighbor_period     : 0x%X\n",\
							   __FILE__, __FUNCTION__, __LINE__,\
							   data.freq, data.power, data.start_neighbor,data.start_alarm_report, data.neighbor_period);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(NM_COMBINED_DATA));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy((unsigned char *)&data, requests->requestvb->val.string, sizeof(NM_COMBINED_DATA));
			if((data.freq!=0xFFFFFFFF)&&((data.freq<MIN_FREQ)||(data.freq>MAX_FREQ)))
			{
			    printf("set freq=%d not in 350000000~400000000 or 0xffffffff\n",data.freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
			    if(data.power!=0xff)
			    {
					for(i=0;i<5;i++)
					{
						if(data.power==power_range[i])
						{
							flag=1;
							break;
						}
					}
			    }
				else
				{
				    flag=1;
				}

				if(!flag)
				{
					printf("set power=%d not in1,5,10,16,20\n",data.power);
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				}
				else
				{
				    flag=0;
                    if((data.neighbor_period!=0xFFFF)&&((data.neighbor_period<MIN_PERIOD)||(data.neighbor_period>MAX_PERIOD)||(data.neighbor_period % 2)))
				    {
						printf("set neighborperiod=%d not in 2,4,6...20\n",data.neighbor_period);
						netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
					}
					else
					{
						sem_nm_p();
						shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
						sem_nm_v();
							
						if (is_local_dev(this_id))
						{
							send_local_nm_set_cmd(CMD_CODE_COMBINED_DATA, (unsigned char *)&data);
						}
						else
						{
							send_remote_nm_set_cmd(CMD_CODE_COMBINED_DATA, this_id, (unsigned char *)&data);
						}
							
						for (i = 0; i < timeout_cnt; i++)
						{
							delay.tv_sec = 0;
							delay.tv_usec = POLLING_INTERVA;
							select(0, NULL, NULL, NULL, &delay);
							if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
							{
								break;
							}
						}
						if (i == timeout_cnt)
						{
							netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
						}
					}
					
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id28CombinedDataPacket\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id29CombinedDataPacket(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_29;
	NM_COMBINED_DATA data;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_COMBINED_DATA);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_COMBINED_DATA, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->combined_data.data,sizeof(NM_COMBINED_DATA));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, \
							   "\n |%s||%s||%d|\n"
							   "\r MODE_GET freq                : 0x%X\n"
							   "\r MODE_GET power               : 0x%X\n"
							   "\r MODE_GET start_neighbor      : 0x%X\n"
							   "\r MODE_GET start_alarm_report  : 0x%X\n"
							   "\r MODE_GET neighbor_period     : 0x%X\n",\
							   __FILE__, __FUNCTION__, __LINE__,\
							   data.freq, data.power, data.start_neighbor,data.start_alarm_report, data.neighbor_period);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(NM_COMBINED_DATA));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy((unsigned char *)&data, requests->requestvb->val.string, sizeof(NM_COMBINED_DATA));
			if((data.freq!=0xFFFFFFFF)&&((data.freq<MIN_FREQ)||(data.freq>MAX_FREQ)))
			{
			    printf("set freq=%d not in 350000000~400000000 or 0xffffffff\n",data.freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
			    if(data.power!=0xff)
			    {
					for(i=0;i<5;i++)
					{
						if(data.power==power_range[i])
						{
							flag=1;
							break;
						}
					}
			    }
				else
				{
				    flag=1;
				}

				if(!flag)
				{
					printf("set power=%d not in1,5,10,16,20\n",data.power);
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				}
				else
				{
				    flag=0;
                    if((data.neighbor_period!=0xFFFF)&&((data.neighbor_period<MIN_PERIOD)||(data.neighbor_period>MAX_PERIOD)||(data.neighbor_period % 2)))
				    {
						printf("set neighborperiod=%d not in 2,4,6...20\n",data.neighbor_period);
						netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
					}
					else
					{
						sem_nm_p();
						shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
						sem_nm_v();
							
						if (is_local_dev(this_id))
						{
							send_local_nm_set_cmd(CMD_CODE_COMBINED_DATA, (unsigned char *)&data);
						}
						else
						{
							send_remote_nm_set_cmd(CMD_CODE_COMBINED_DATA, this_id, (unsigned char *)&data);
						}
							
						for (i = 0; i < timeout_cnt; i++)
						{
							delay.tv_sec = 0;
							delay.tv_usec = POLLING_INTERVA;
							select(0, NULL, NULL, NULL, &delay);
							if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
							{
								break;
							}
						}
						if (i == timeout_cnt)
						{
							netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
						}
					}
					
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id29CombinedDataPacket\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



int
handle_id30CombinedDataPacket(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_30;
	NM_COMBINED_DATA data;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_COMBINED_DATA);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_COMBINED_DATA, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->combined_data.data,sizeof(NM_COMBINED_DATA));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, \
							   "\n |%s||%s||%d|\n"
							   "\r MODE_GET freq                : 0x%X\n"
							   "\r MODE_GET power               : 0x%X\n"
							   "\r MODE_GET start_neighbor      : 0x%X\n"
							   "\r MODE_GET start_alarm_report  : 0x%X\n"
							   "\r MODE_GET neighbor_period     : 0x%X\n",\
							   __FILE__, __FUNCTION__, __LINE__,\
							   data.freq, data.power, data.start_neighbor,data.start_alarm_report, data.neighbor_period);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(NM_COMBINED_DATA));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy((unsigned char *)&data, requests->requestvb->val.string, sizeof(NM_COMBINED_DATA));
			if((data.freq!=0xFFFFFFFF)&&((data.freq<MIN_FREQ)||(data.freq>MAX_FREQ)))
			{
			    printf("set freq=%d not in 350000000~400000000 or 0xffffffff\n",data.freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
			    if(data.power!=0xff)
			    {
					for(i=0;i<5;i++)
					{
						if(data.power==power_range[i])
						{
							flag=1;
							break;
						}
					}
			    }
				else
				{
				    flag=1;
				}

				if(!flag)
				{
					printf("set power=%d not in1,5,10,16,20\n",data.power);
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				}
				else
				{
				    flag=0;
                    if((data.neighbor_period!=0xFFFF)&&((data.neighbor_period<MIN_PERIOD)||(data.neighbor_period>MAX_PERIOD)||(data.neighbor_period % 2)))
				    {
						printf("set neighborperiod=%d not in 2,4,6...20\n",data.neighbor_period);
						netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
					}
					else
					{
						sem_nm_p();
						shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
						sem_nm_v();
							
						if (is_local_dev(this_id))
						{
							send_local_nm_set_cmd(CMD_CODE_COMBINED_DATA, (unsigned char *)&data);
						}
						else
						{
							send_remote_nm_set_cmd(CMD_CODE_COMBINED_DATA, this_id, (unsigned char *)&data);
						}
							
						for (i = 0; i < timeout_cnt; i++)
						{
							delay.tv_sec = 0;
							delay.tv_usec = POLLING_INTERVA;
							select(0, NULL, NULL, NULL, &delay);
							if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
							{
								break;
							}
						}
						if (i == timeout_cnt)
						{
							netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
						}
					}
					
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id30CombinedDataPacket\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



int
handle_id31CombinedDataPacket(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_31;
	NM_COMBINED_DATA data;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_COMBINED_DATA);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_COMBINED_DATA, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->combined_data.data,sizeof(NM_COMBINED_DATA));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, \
							   "\n |%s||%s||%d|\n"
							   "\r MODE_GET freq                : 0x%X\n"
							   "\r MODE_GET power               : 0x%X\n"
							   "\r MODE_GET start_neighbor      : 0x%X\n"
							   "\r MODE_GET start_alarm_report  : 0x%X\n"
							   "\r MODE_GET neighbor_period     : 0x%X\n",\
							   __FILE__, __FUNCTION__, __LINE__,\
							   data.freq, data.power, data.start_neighbor,data.start_alarm_report, data.neighbor_period);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(NM_COMBINED_DATA));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy((unsigned char *)&data, requests->requestvb->val.string, sizeof(NM_COMBINED_DATA));
			if((data.freq!=0xFFFFFFFF)&&((data.freq<MIN_FREQ)||(data.freq>MAX_FREQ)))
			{
			    printf("set freq=%d not in 350000000~400000000 or 0xffffffff\n",data.freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
			    if(data.power!=0xff)
			    {
					for(i=0;i<5;i++)
					{
						if(data.power==power_range[i])
						{
							flag=1;
							break;
						}
					}
			    }
				else
				{
				    flag=1;
				}

				if(!flag)
				{
					printf("set power=%d not in1,5,10,16,20\n",data.power);
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				}
				else
				{
				    flag=0;
                    if((data.neighbor_period!=0xFFFF)&&((data.neighbor_period<MIN_PERIOD)||(data.neighbor_period>MAX_PERIOD)||(data.neighbor_period % 2)))
				    {
						printf("set neighborperiod=%d not in 2,4,6...20\n",data.neighbor_period);
						netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
					}
					else
					{
						sem_nm_p();
						shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
						sem_nm_v();
							
						if (is_local_dev(this_id))
						{
							send_local_nm_set_cmd(CMD_CODE_COMBINED_DATA, (unsigned char *)&data);
						}
						else
						{
							send_remote_nm_set_cmd(CMD_CODE_COMBINED_DATA, this_id, (unsigned char *)&data);
						}
							
						for (i = 0; i < timeout_cnt; i++)
						{
							delay.tv_sec = 0;
							delay.tv_usec = POLLING_INTERVA;
							select(0, NULL, NULL, NULL, &delay);
							if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
							{
								break;
							}
						}
						if (i == timeout_cnt)
						{
							netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
						}
					}
					
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id31CombinedDataPacket\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id32CombinedDataPacket(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_32;
	NM_COMBINED_DATA data;
	int flag=0;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_COMBINED_DATA);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_COMBINED_DATA, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
				{
					memcpy((unsigned char *)&data,shm_nm_addr->combined_data.data,sizeof(NM_COMBINED_DATA));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, \
							   "\n |%s||%s||%d|\n"
							   "\r MODE_GET freq                : 0x%X\n"
							   "\r MODE_GET power               : 0x%X\n"
							   "\r MODE_GET start_neighbor      : 0x%X\n"
							   "\r MODE_GET start_alarm_report  : 0x%X\n"
							   "\r MODE_GET neighbor_period     : 0x%X\n",\
							   __FILE__, __FUNCTION__, __LINE__,\
							   data.freq, data.power, data.start_neighbor,data.start_alarm_report, data.neighbor_period);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, (unsigned char *)&data, sizeof(NM_COMBINED_DATA));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy((unsigned char *)&data, requests->requestvb->val.string, sizeof(NM_COMBINED_DATA));
			if((data.freq!=0xFFFFFFFF)&&((data.freq<MIN_FREQ)||(data.freq>MAX_FREQ)))
			{
			    printf("set freq=%d not in 350000000~400000000 or 0xffffffff\n",data.freq);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
			}
			else
			{
			    if(data.power!=0xff)
			    {
					for(i=0;i<5;i++)
					{
						if(data.power==power_range[i])
						{
							flag=1;
							break;
						}
					}
			    }
				else
				{
				    flag=1;
				}

				if(!flag)
				{
					printf("set power=%d not in1,5,10,16,20\n",data.power);
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				}
				else
				{
				    flag=0;
                    if((data.neighbor_period!=0xFFFF)&&((data.neighbor_period<MIN_PERIOD)||(data.neighbor_period>MAX_PERIOD)||(data.neighbor_period % 2)))
				    {
						printf("set neighborperiod=%d not in 2,4,6...20\n",data.neighbor_period);
						netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
					}
					else
					{
						sem_nm_p();
						shm_nm_addr->combined_data.ack_flag = ACK_FLAG_CLR;
						sem_nm_v();
							
						if (is_local_dev(this_id))
						{
							send_local_nm_set_cmd(CMD_CODE_COMBINED_DATA, (unsigned char *)&data);
						}
						else
						{
							send_remote_nm_set_cmd(CMD_CODE_COMBINED_DATA, this_id, (unsigned char *)&data);
						}
							
						for (i = 0; i < timeout_cnt; i++)
						{
							delay.tv_sec = 0;
							delay.tv_usec = POLLING_INTERVA;
							select(0, NULL, NULL, NULL, &delay);
							if (ACK_FLAG_OK == shm_nm_addr->combined_data.ack_flag)
							{
								break;
							}
						}
						if (i == timeout_cnt)
						{
							netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
						}
					}
					
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id32CombinedDataPacket\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



int
handle_id1NeighborPeriod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int neighborperiod = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_1;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->neighbor_period.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
				{
					neighborperiod= shm_nm_addr->neighbor_period.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &neighborperiod, sizeof(neighborperiod));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			neighborperiod = *((unsigned int *)requests->requestvb->val.integer);
			if((neighborperiod<MIN_PERIOD)||(neighborperiod>MAX_PERIOD)||(neighborperiod % 2))
			{
			    printf("set neighborperiod=%d not in 2,4,6...20\n",neighborperiod);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
				}
				sem_nm_p();
				shm_nm_addr->neighbor_period.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, (unsigned char *)&neighborperiod);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id, (unsigned char *)&neighborperiod);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}

            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id1NeighborPeriod\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id2NeighborPeriod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int neighborperiod = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_2;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->neighbor_period.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
				{
					neighborperiod= shm_nm_addr->neighbor_period.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &neighborperiod, sizeof(neighborperiod));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			neighborperiod = *((unsigned int *)requests->requestvb->val.integer);
			if((neighborperiod<MIN_PERIOD)||(neighborperiod>MAX_PERIOD)||(neighborperiod % 2))
			{
			    printf("set neighborperiod=%d not in 2,4,6...20\n",neighborperiod);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
				}
				sem_nm_p();
				shm_nm_addr->neighbor_period.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, (unsigned char *)&neighborperiod);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id, (unsigned char *)&neighborperiod);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id2NeighborPeriod\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id3NeighborPeriod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int neighborperiod = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_3;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->neighbor_period.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
				{
					neighborperiod= shm_nm_addr->neighbor_period.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &neighborperiod, sizeof(neighborperiod));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			neighborperiod = *((unsigned int *)requests->requestvb->val.integer);
			if((neighborperiod<MIN_PERIOD)||(neighborperiod>MAX_PERIOD)||(neighborperiod % 2))
			{
			    printf("set neighborperiod=%d not in 2,4,6...20\n",neighborperiod);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
				}
				sem_nm_p();
				shm_nm_addr->neighbor_period.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, (unsigned char *)&neighborperiod);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id, (unsigned char *)&neighborperiod);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id3NeighborPeriod\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id4NeighborPeriod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int neighborperiod = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_4;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->neighbor_period.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
				{
					neighborperiod= shm_nm_addr->neighbor_period.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &neighborperiod, sizeof(neighborperiod));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			neighborperiod = *((unsigned int *)requests->requestvb->val.integer);
			if((neighborperiod<MIN_PERIOD)||(neighborperiod>MAX_PERIOD)||(neighborperiod % 2))
			{
			    printf("set neighborperiod=%d not in 2,4,6...20\n",neighborperiod);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
				}
				sem_nm_p();
				shm_nm_addr->neighbor_period.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, (unsigned char *)&neighborperiod);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id, (unsigned char *)&neighborperiod);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id4NeighborPeriod\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id5NeighborPeriod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int neighborperiod = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_5;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->neighbor_period.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
				{
					neighborperiod= shm_nm_addr->neighbor_period.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &neighborperiod, sizeof(neighborperiod));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			neighborperiod = *((unsigned int *)requests->requestvb->val.integer);
			if((neighborperiod<MIN_PERIOD)||(neighborperiod>MAX_PERIOD)||(neighborperiod % 2))
			{
			    printf("set neighborperiod=%d not in 2,4,6...20\n",neighborperiod);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
				}
				sem_nm_p();
				shm_nm_addr->neighbor_period.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, (unsigned char *)&neighborperiod);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id, (unsigned char *)&neighborperiod);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id5NeighborPeriod\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id6NeighborPeriod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int neighborperiod = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_6;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->neighbor_period.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
				{
					neighborperiod= shm_nm_addr->neighbor_period.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &neighborperiod, sizeof(neighborperiod));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			neighborperiod = *((unsigned int *)requests->requestvb->val.integer);
			if((neighborperiod<MIN_PERIOD)||(neighborperiod>MAX_PERIOD)||(neighborperiod % 2))
			{
			    printf("set neighborperiod=%d not in 2,4,6...20\n",neighborperiod);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
				}
				sem_nm_p();
				shm_nm_addr->neighbor_period.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, (unsigned char *)&neighborperiod);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id, (unsigned char *)&neighborperiod);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id6NeighborPeriod\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id7NeighborPeriod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int neighborperiod = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_7;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->neighbor_period.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
				{
					neighborperiod= shm_nm_addr->neighbor_period.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &neighborperiod, sizeof(neighborperiod));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			neighborperiod = *((unsigned int *)requests->requestvb->val.integer);
			if((neighborperiod<MIN_PERIOD)||(neighborperiod>MAX_PERIOD)||(neighborperiod % 2))
			{
			    printf("set neighborperiod=%d not in 2,4,6...20\n",neighborperiod);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
				}
				sem_nm_p();
				shm_nm_addr->neighbor_period.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, (unsigned char *)&neighborperiod);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id, (unsigned char *)&neighborperiod);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id7NeighborPeriod\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id8NeighborPeriod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int neighborperiod = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_8;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->neighbor_period.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
				{
					neighborperiod= shm_nm_addr->neighbor_period.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &neighborperiod, sizeof(neighborperiod));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			neighborperiod = *((unsigned int *)requests->requestvb->val.integer);
			if((neighborperiod<MIN_PERIOD)||(neighborperiod>MAX_PERIOD)||(neighborperiod % 2))
			{
			    printf("set neighborperiod=%d not in 2,4,6...20\n",neighborperiod);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
				}
				sem_nm_p();
				shm_nm_addr->neighbor_period.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, (unsigned char *)&neighborperiod);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id, (unsigned char *)&neighborperiod);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id8NeighborPeriod\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id9NeighborPeriod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int neighborperiod = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_9;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->neighbor_period.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
				{
					neighborperiod= shm_nm_addr->neighbor_period.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &neighborperiod, sizeof(neighborperiod));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			neighborperiod = *((unsigned int *)requests->requestvb->val.integer);
			if((neighborperiod<MIN_PERIOD)||(neighborperiod>MAX_PERIOD)||(neighborperiod % 2))
			{
			    printf("set neighborperiod=%d not in 2,4,6...20\n",neighborperiod);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
				}
				sem_nm_p();
				shm_nm_addr->neighbor_period.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, (unsigned char *)&neighborperiod);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id, (unsigned char *)&neighborperiod);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id9NeighborPeriod\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id10NeighborPeriod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int neighborperiod = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_10;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->neighbor_period.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
				{
					neighborperiod= shm_nm_addr->neighbor_period.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &neighborperiod, sizeof(neighborperiod));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			neighborperiod = *((unsigned int *)requests->requestvb->val.integer);
			if((neighborperiod<MIN_PERIOD)||(neighborperiod>MAX_PERIOD)||(neighborperiod % 2))
			{
			    printf("set neighborperiod=%d not in 2,4,6...20\n",neighborperiod);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
				}
				sem_nm_p();
				shm_nm_addr->neighbor_period.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, (unsigned char *)&neighborperiod);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id, (unsigned char *)&neighborperiod);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id10NeighborPeriod\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id11NeighborPeriod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int neighborperiod = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_11;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->neighbor_period.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
				{
					neighborperiod= shm_nm_addr->neighbor_period.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &neighborperiod, sizeof(neighborperiod));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			neighborperiod = *((unsigned int *)requests->requestvb->val.integer);
			if((neighborperiod<MIN_PERIOD)||(neighborperiod>MAX_PERIOD)||(neighborperiod % 2))
			{
			    printf("set neighborperiod=%d not in 2,4,6...20\n",neighborperiod);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
				}
				sem_nm_p();
				shm_nm_addr->neighbor_period.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, (unsigned char *)&neighborperiod);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id, (unsigned char *)&neighborperiod);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id11NeighborPeriod\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id12NeighborPeriod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int neighborperiod = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_12;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->neighbor_period.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
				{
					neighborperiod= shm_nm_addr->neighbor_period.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &neighborperiod, sizeof(neighborperiod));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			neighborperiod = *((unsigned int *)requests->requestvb->val.integer);
			if((neighborperiod<MIN_PERIOD)||(neighborperiod>MAX_PERIOD)||(neighborperiod % 2))
			{
			    printf("set neighborperiod=%d not in 2,4,6...20\n",neighborperiod);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
				}
				sem_nm_p();
				shm_nm_addr->neighbor_period.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, (unsigned char *)&neighborperiod);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id, (unsigned char *)&neighborperiod);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id12NeighborPeriod\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id13NeighborPeriod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int neighborperiod = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_13;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->neighbor_period.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
				{
					neighborperiod= shm_nm_addr->neighbor_period.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &neighborperiod, sizeof(neighborperiod));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			neighborperiod = *((unsigned int *)requests->requestvb->val.integer);
			if((neighborperiod<MIN_PERIOD)||(neighborperiod>MAX_PERIOD)||(neighborperiod % 2))
			{
			    printf("set neighborperiod=%d not in 2,4,6...20\n",neighborperiod);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
				}
				sem_nm_p();
				shm_nm_addr->neighbor_period.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, (unsigned char *)&neighborperiod);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id, (unsigned char *)&neighborperiod);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id13NeighborPeriod\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id14NeighborPeriod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int neighborperiod = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_14;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->neighbor_period.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
				{
					neighborperiod= shm_nm_addr->neighbor_period.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &neighborperiod, sizeof(neighborperiod));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			neighborperiod = *((unsigned int *)requests->requestvb->val.integer);
			if((neighborperiod<MIN_PERIOD)||(neighborperiod>MAX_PERIOD)||(neighborperiod % 2))
			{
			    printf("set neighborperiod=%d not in 2,4,6...20\n",neighborperiod);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
				}
				sem_nm_p();
				shm_nm_addr->neighbor_period.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, (unsigned char *)&neighborperiod);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id, (unsigned char *)&neighborperiod);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id14NeighborPeriod\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id15NeighborPeriod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int neighborperiod = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_15;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->neighbor_period.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
				{
					neighborperiod= shm_nm_addr->neighbor_period.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &neighborperiod, sizeof(neighborperiod));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			neighborperiod = *((unsigned int *)requests->requestvb->val.integer);
			if((neighborperiod<MIN_PERIOD)||(neighborperiod>MAX_PERIOD)||(neighborperiod % 2))
			{
			    printf("set neighborperiod=%d not in 2,4,6...20\n",neighborperiod);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
				}
				sem_nm_p();
				shm_nm_addr->neighbor_period.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, (unsigned char *)&neighborperiod);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id, (unsigned char *)&neighborperiod);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id15NeighborPeriod\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id16NeighborPeriod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int neighborperiod = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_16;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->neighbor_period.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
				{
					neighborperiod= shm_nm_addr->neighbor_period.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &neighborperiod, sizeof(neighborperiod));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			neighborperiod = *((unsigned int *)requests->requestvb->val.integer);
			if((neighborperiod<MIN_PERIOD)||(neighborperiod>MAX_PERIOD)||(neighborperiod % 2))
			{
			    printf("set neighborperiod=%d not in 2,4,6...20\n",neighborperiod);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
				}
				sem_nm_p();
				shm_nm_addr->neighbor_period.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, (unsigned char *)&neighborperiod);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id, (unsigned char *)&neighborperiod);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id16NeighborPeriod\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



int
handle_id17NeighborPeriod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int neighborperiod = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_17;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->neighbor_period.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
				{
					neighborperiod= shm_nm_addr->neighbor_period.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &neighborperiod, sizeof(neighborperiod));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			neighborperiod = *((unsigned int *)requests->requestvb->val.integer);
			if((neighborperiod<MIN_PERIOD)||(neighborperiod>MAX_PERIOD)||(neighborperiod % 2))
			{
			    printf("set neighborperiod=%d not in 2,4,6...20\n",neighborperiod);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
				}
				sem_nm_p();
				shm_nm_addr->neighbor_period.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, (unsigned char *)&neighborperiod);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id, (unsigned char *)&neighborperiod);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id17NeighborPeriod\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id18NeighborPeriod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int neighborperiod = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_18;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->neighbor_period.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
				{
					neighborperiod= shm_nm_addr->neighbor_period.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &neighborperiod, sizeof(neighborperiod));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			neighborperiod = *((unsigned int *)requests->requestvb->val.integer);
			if((neighborperiod<MIN_PERIOD)||(neighborperiod>MAX_PERIOD)||(neighborperiod % 2))
			{
			    printf("set neighborperiod=%d not in 2,4,6...20\n",neighborperiod);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
				}
				sem_nm_p();
				shm_nm_addr->neighbor_period.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, (unsigned char *)&neighborperiod);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id, (unsigned char *)&neighborperiod);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id18NeighborPeriod\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



int
handle_id19NeighborPeriod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int neighborperiod = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_19;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->neighbor_period.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
				{
					neighborperiod= shm_nm_addr->neighbor_period.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &neighborperiod, sizeof(neighborperiod));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			neighborperiod = *((unsigned int *)requests->requestvb->val.integer);
			if((neighborperiod<MIN_PERIOD)||(neighborperiod>MAX_PERIOD)||(neighborperiod % 2))
			{
			    printf("set neighborperiod=%d not in 2,4,6...20\n",neighborperiod);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
				}
				sem_nm_p();
				shm_nm_addr->neighbor_period.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, (unsigned char *)&neighborperiod);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id, (unsigned char *)&neighborperiod);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id19NeighborPeriod\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_id20NeighborPeriod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int neighborperiod = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_20;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->neighbor_period.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
				{
					neighborperiod= shm_nm_addr->neighbor_period.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &neighborperiod, sizeof(neighborperiod));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			neighborperiod = *((unsigned int *)requests->requestvb->val.integer);
			if((neighborperiod<MIN_PERIOD)||(neighborperiod>MAX_PERIOD)||(neighborperiod % 2))
			{
			    printf("set neighborperiod=%d not in 2,4,6...20\n",neighborperiod);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
				}
				sem_nm_p();
				shm_nm_addr->neighbor_period.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, (unsigned char *)&neighborperiod);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id, (unsigned char *)&neighborperiod);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id20NeighborPeriod\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}






int
handle_id21NeighborPeriod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int neighborperiod = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_21;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->neighbor_period.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
				{
					neighborperiod= shm_nm_addr->neighbor_period.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &neighborperiod, sizeof(neighborperiod));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			neighborperiod = *((unsigned int *)requests->requestvb->val.integer);
			if((neighborperiod<MIN_PERIOD)||(neighborperiod>MAX_PERIOD)||(neighborperiod % 2))
			{
			    printf("set neighborperiod=%d not in 2,4,6...20\n",neighborperiod);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
				}
				sem_nm_p();
				shm_nm_addr->neighbor_period.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, (unsigned char *)&neighborperiod);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id, (unsigned char *)&neighborperiod);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id21NeighborPeriod\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}






int
handle_id22NeighborPeriod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int neighborperiod = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_22;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->neighbor_period.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
				{
					neighborperiod= shm_nm_addr->neighbor_period.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &neighborperiod, sizeof(neighborperiod));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			neighborperiod = *((unsigned int *)requests->requestvb->val.integer);
			if((neighborperiod<MIN_PERIOD)||(neighborperiod>MAX_PERIOD)||(neighborperiod % 2))
			{
			    printf("set neighborperiod=%d not in 2,4,6...20\n",neighborperiod);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
				}
				sem_nm_p();
				shm_nm_addr->neighbor_period.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, (unsigned char *)&neighborperiod);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id, (unsigned char *)&neighborperiod);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id22NeighborPeriod\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}






int
handle_id23NeighborPeriod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int neighborperiod = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_23;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->neighbor_period.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
				{
					neighborperiod= shm_nm_addr->neighbor_period.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &neighborperiod, sizeof(neighborperiod));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			neighborperiod = *((unsigned int *)requests->requestvb->val.integer);
			if((neighborperiod<MIN_PERIOD)||(neighborperiod>MAX_PERIOD)||(neighborperiod % 2))
			{
			    printf("set neighborperiod=%d not in 2,4,6...20\n",neighborperiod);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
				}
				sem_nm_p();
				shm_nm_addr->neighbor_period.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, (unsigned char *)&neighborperiod);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id, (unsigned char *)&neighborperiod);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id23NeighborPeriod\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}






int
handle_id24NeighborPeriod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int neighborperiod = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_24;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->neighbor_period.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
				{
					neighborperiod= shm_nm_addr->neighbor_period.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &neighborperiod, sizeof(neighborperiod));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			neighborperiod = *((unsigned int *)requests->requestvb->val.integer);
			if((neighborperiod<MIN_PERIOD)||(neighborperiod>MAX_PERIOD)||(neighborperiod % 2))
			{
			    printf("set neighborperiod=%d not in 2,4,6...20\n",neighborperiod);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
				}
				sem_nm_p();
				shm_nm_addr->neighbor_period.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, (unsigned char *)&neighborperiod);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id, (unsigned char *)&neighborperiod);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id24NeighborPeriod\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}






int
handle_id25NeighborPeriod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int neighborperiod = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_25;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->neighbor_period.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
				{
					neighborperiod= shm_nm_addr->neighbor_period.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &neighborperiod, sizeof(neighborperiod));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			neighborperiod = *((unsigned int *)requests->requestvb->val.integer);
			if((neighborperiod<MIN_PERIOD)||(neighborperiod>MAX_PERIOD)||(neighborperiod % 2))
			{
			    printf("set neighborperiod=%d not in 2,4,6...20\n",neighborperiod);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
				}
				sem_nm_p();
				shm_nm_addr->neighbor_period.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, (unsigned char *)&neighborperiod);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id, (unsigned char *)&neighborperiod);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id25NeighborPeriod\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}






int
handle_id26NeighborPeriod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int neighborperiod = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_26;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->neighbor_period.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
				{
					neighborperiod= shm_nm_addr->neighbor_period.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &neighborperiod, sizeof(neighborperiod));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			neighborperiod = *((unsigned int *)requests->requestvb->val.integer);
			if((neighborperiod<MIN_PERIOD)||(neighborperiod>MAX_PERIOD)||(neighborperiod % 2))
			{
			    printf("set neighborperiod=%d not in 2,4,6...20\n",neighborperiod);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
				}
				sem_nm_p();
				shm_nm_addr->neighbor_period.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, (unsigned char *)&neighborperiod);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id, (unsigned char *)&neighborperiod);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id26NeighborPeriod\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}






int
handle_id27NeighborPeriod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int neighborperiod = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_27;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->neighbor_period.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
				{
					neighborperiod= shm_nm_addr->neighbor_period.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &neighborperiod, sizeof(neighborperiod));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			neighborperiod = *((unsigned int *)requests->requestvb->val.integer);
			if((neighborperiod<MIN_PERIOD)||(neighborperiod>MAX_PERIOD)||(neighborperiod % 2))
			{
			    printf("set neighborperiod=%d not in 2,4,6...20\n",neighborperiod);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
				}
				sem_nm_p();
				shm_nm_addr->neighbor_period.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, (unsigned char *)&neighborperiod);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id, (unsigned char *)&neighborperiod);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id27NeighborPeriod\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}






int
handle_id28NeighborPeriod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int neighborperiod = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_28;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->neighbor_period.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
				{
					neighborperiod= shm_nm_addr->neighbor_period.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &neighborperiod, sizeof(neighborperiod));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			neighborperiod = *((unsigned int *)requests->requestvb->val.integer);
			if((neighborperiod<MIN_PERIOD)||(neighborperiod>MAX_PERIOD)||(neighborperiod % 2))
			{
			    printf("set neighborperiod=%d not in 2,4,6...20\n",neighborperiod);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
				}
				sem_nm_p();
				shm_nm_addr->neighbor_period.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, (unsigned char *)&neighborperiod);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id, (unsigned char *)&neighborperiod);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id28NeighborPeriod\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}






int
handle_id29NeighborPeriod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int neighborperiod = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_29;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->neighbor_period.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
				{
					neighborperiod= shm_nm_addr->neighbor_period.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &neighborperiod, sizeof(neighborperiod));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			neighborperiod = *((unsigned int *)requests->requestvb->val.integer);
			if((neighborperiod<MIN_PERIOD)||(neighborperiod>MAX_PERIOD)||(neighborperiod % 2))
			{
			    printf("set neighborperiod=%d not in 2,4,6...20\n",neighborperiod);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
				}
				sem_nm_p();
				shm_nm_addr->neighbor_period.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, (unsigned char *)&neighborperiod);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id, (unsigned char *)&neighborperiod);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id29NeighborPeriod\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}






int
handle_id30NeighborPeriod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int neighborperiod = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_30;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->neighbor_period.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
				{
					neighborperiod= shm_nm_addr->neighbor_period.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &neighborperiod, sizeof(neighborperiod));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			neighborperiod = *((unsigned int *)requests->requestvb->val.integer);
			if((neighborperiod<MIN_PERIOD)||(neighborperiod>MAX_PERIOD)||(neighborperiod % 2))
			{
			    printf("set neighborperiod=%d not in 2,4,6...20\n",neighborperiod);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
				}
				sem_nm_p();
				shm_nm_addr->neighbor_period.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, (unsigned char *)&neighborperiod);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id, (unsigned char *)&neighborperiod);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id30NeighborPeriod\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}






int
handle_id31NeighborPeriod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int neighborperiod = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_31;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->neighbor_period.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
				{
					neighborperiod= shm_nm_addr->neighbor_period.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &neighborperiod, sizeof(neighborperiod));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			neighborperiod = *((unsigned int *)requests->requestvb->val.integer);
			if((neighborperiod<MIN_PERIOD)||(neighborperiod>MAX_PERIOD)||(neighborperiod % 2))
			{
			    printf("set neighborperiod=%d not in 2,4,6...20\n",neighborperiod);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
				}
				sem_nm_p();
				shm_nm_addr->neighbor_period.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, (unsigned char *)&neighborperiod);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id, (unsigned char *)&neighborperiod);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id31NeighborPeriod\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}






int
handle_id32NeighborPeriod(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int neighborperiod = 0;
	struct timeval delay; 
	unsigned int this_id = DEV_ID_32;
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->neighbor_period.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
			
			if (is_local_dev(this_id))
			{
				send_local_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD);
			}
			else
			{
				send_remote_nm_get_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id);
			}

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
				{
					neighborperiod= shm_nm_addr->neighbor_period.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &neighborperiod, sizeof(neighborperiod));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			neighborperiod = *((unsigned int *)requests->requestvb->val.integer);
			if((neighborperiod<MIN_PERIOD)||(neighborperiod>MAX_PERIOD)||(neighborperiod % 2))
			{
			    printf("set neighborperiod=%d not in 2,4,6...20\n",neighborperiod);
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_TOOBIG);
				
			}
			else
			{
				if (shm_ipc_addr->mgr_printf[1])
				{
					LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION neighborperiod : %u\n", __FILE__, __FUNCTION__, __LINE__, neighborperiod);
				}
				sem_nm_p();
				shm_nm_addr->neighbor_period.ack_flag = ACK_FLAG_CLR;
				sem_nm_v();
				
				if (is_local_dev(this_id))
				{
					send_local_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, (unsigned char *)&neighborperiod);
				}
				else
				{
					send_remote_nm_set_cmd(CMD_CODE_NEIGHBOR_PERIOD, this_id, (unsigned char *)&neighborperiod);
				}
				
				for (i = 0; i < timeout_cnt; i++)
				{
					delay.tv_sec = 0;
					delay.tv_usec = POLLING_INTERVA;
					select(0, NULL, NULL, NULL, &delay);
					if (ACK_FLAG_OK == shm_nm_addr->neighbor_period.ack_flag)
					{
						break;
					}
				}
				if (i == timeout_cnt)
				{
					netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
				}
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_id32NeighborPeriod\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_centerModule(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned char center_module[16];
	struct timeval delay; 
    int i;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->center_module.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
						
			send_cc_get_cmd(CMD_CODE_CENTER_MODULE);
		     for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
	
				if (ACK_FLAG_OK ==shm_nm_addr->center_module.ack_flag)
				{   
				    memcpy(center_module,shm_nm_addr->center_module.data,sizeof(center_module));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET CENTER_MODULE :\n", __FILE__, __FUNCTION__, __LINE__);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, center_module, sizeof(center_module));
					break;
				}

			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
			break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy(center_module, requests->requestvb->val.string, sizeof(center_module));
			sem_nm_p();
			shm_nm_addr->center_module.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			send_cc_set_cmd(CMD_CODE_CENTER_MODULE,center_module);

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->center_module.ack_flag)
				{
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_centerModule\n", reqinfo->mode );
		
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}







int
handle_gsmModule1(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned char gsm_module1[307];
	struct timeval delay; 
    int i;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->gsm_module1.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
						
			send_cc_get_cmd(CMD_CODE_GSM_MODULE1);
		     for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
	
				if (ACK_FLAG_OK ==shm_nm_addr->gsm_module1.ack_flag)
				{   
				    memcpy(gsm_module1,shm_nm_addr->gsm_module1.data,sizeof(gsm_module1));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET gsm_module1 :\n", __FILE__, __FUNCTION__, __LINE__);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, gsm_module1, sizeof(gsm_module1));
					break;
				}

			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
			break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy(gsm_module1, requests->requestvb->val.string, sizeof(gsm_module1));
			sem_nm_p();
			shm_nm_addr->gsm_module1.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			send_cc_set_cmd(CMD_CODE_GSM_MODULE1,gsm_module1);

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->gsm_module1.ack_flag)
				{
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_gsmmodule1\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}


int
handle_gsmModule2(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned char gsm_module2[302];
	struct timeval delay; 
    int i;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->gsm_module2.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
						
			send_cc_get_cmd(CMD_CODE_GSM_MODULE2);
		     for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
	
				if (ACK_FLAG_OK ==shm_nm_addr->gsm_module2.ack_flag)
				{   
				    memcpy(gsm_module2,shm_nm_addr->gsm_module2.data,sizeof(gsm_module2));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET gsm_module2 :\n", __FILE__, __FUNCTION__, __LINE__);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, gsm_module2, sizeof(gsm_module2));
					break;
				}

			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
			break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy(gsm_module2, requests->requestvb->val.string, sizeof(gsm_module2));
			sem_nm_p();
			shm_nm_addr->gsm_module2.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			send_cc_set_cmd(CMD_CODE_GSM_MODULE2,gsm_module2);

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->gsm_module2.ack_flag)
				{
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_gsmmodule2\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}



int
handle_radioModule(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned char radio_module[37];
	struct timeval delay; 
    int i;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->radio_module.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
						
			send_cc_get_cmd(CMD_CODE_RADIO_MODULE);
		     for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
	
				if (ACK_FLAG_OK ==shm_nm_addr->radio_module.ack_flag)
				{   
				    memcpy(radio_module,shm_nm_addr->radio_module.data,sizeof(radio_module));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET radio_module :\n", __FILE__, __FUNCTION__, __LINE__);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, radio_module, sizeof(radio_module));
					break;
				}

			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
			break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy(radio_module, requests->requestvb->val.string, sizeof(radio_module));
			sem_nm_p();
			shm_nm_addr->radio_module.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			send_cc_set_cmd(CMD_CODE_RADIO_MODULE,radio_module);

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->radio_module.ack_flag)
				{
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_radiomodule\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}








int
handle_dspModule(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned char dsp_module[6];
	struct timeval delay; 
    int i;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dsp_module.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
						
			send_cc_get_cmd(CMD_CODE_DSP_MODULE);
		     for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
	
				if (ACK_FLAG_OK ==shm_nm_addr->dsp_module.ack_flag)
				{   
				    memcpy(dsp_module,shm_nm_addr->dsp_module.data,sizeof(dsp_module));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET dsp_module :\n", __FILE__, __FUNCTION__, __LINE__);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, dsp_module, sizeof(dsp_module));
					break;
				}

			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
			break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy(dsp_module, requests->requestvb->val.string, sizeof(dsp_module));
			sem_nm_p();
			shm_nm_addr->dsp_module.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			send_cc_set_cmd(CMD_CODE_DSP_MODULE,dsp_module);

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dsp_module.ack_flag)
				{
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_dspmodule\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}


int
handle_microphoneModule1(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned char microphone_module1[304];
	struct timeval delay; 
    int i;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->microphone_module1.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
						
			send_cc_get_cmd(CMD_CODE_MICROPHONE_MODULE1);
		     for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
	
				if (ACK_FLAG_OK ==shm_nm_addr->microphone_module1.ack_flag)
				{   
				    memcpy(microphone_module1,shm_nm_addr->microphone_module1.data,sizeof(microphone_module1));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET microphone_module1 :\n", __FILE__, __FUNCTION__, __LINE__);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, microphone_module1, sizeof(microphone_module1));
					break;
				}

			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
			break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy(microphone_module1, requests->requestvb->val.string, sizeof(microphone_module1));
			sem_nm_p();
			shm_nm_addr->microphone_module1.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			send_cc_set_cmd(CMD_CODE_MICROPHONE_MODULE1,microphone_module1);

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->microphone_module1.ack_flag)
				{
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_microphone_module1\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}



int
handle_microphoneModule2(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned char microphone_module2[422];
	struct timeval delay; 
    int i;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->microphone_module2.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
						
			send_cc_get_cmd(CMD_CODE_MICROPHONE_MODULE2);
		     for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
	
				if (ACK_FLAG_OK ==shm_nm_addr->microphone_module2.ack_flag)
				{   
				    memcpy(microphone_module2,shm_nm_addr->microphone_module2.data,sizeof(microphone_module2));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET microphone_module2 :\n", __FILE__, __FUNCTION__, __LINE__);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, microphone_module2, sizeof(microphone_module2));
					break;
				}

			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
			break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy(microphone_module2, requests->requestvb->val.string, sizeof(microphone_module2));
            /////////////////填充4字节设备通话超时时间///////////////////////
			memcpy(microphone_module2+400,(unsigned char *)&(shm_cfg_addr->dev_call_timeout.val),sizeof(int));
			sem_nm_p();
			shm_nm_addr->microphone_module2.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			send_cc_set_cmd(CMD_CODE_MICROPHONE_MODULE2,microphone_module2);

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->microphone_module2.ack_flag)
				{
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_microphone_module2\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}





int
handle_controlModule(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned char control_module[60];
	struct timeval delay; 
    int i;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->control_module.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
						
			send_cc_get_cmd(CMD_CODE_CONTROL_MODULE);
		     for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
	
				if (ACK_FLAG_OK ==shm_nm_addr->control_module.ack_flag)
				{   
				    memcpy(control_module,shm_nm_addr->control_module.data,sizeof(control_module));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET control_module :\n", __FILE__, __FUNCTION__, __LINE__);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, control_module, sizeof(control_module));
					break;
				}

			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
			break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy(control_module, requests->requestvb->val.string, sizeof(control_module));
			sem_nm_p();
			shm_nm_addr->control_module.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
			send_cc_set_cmd(CMD_CODE_CONTROL_MODULE,control_module);

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->control_module.ack_flag)
				{
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_control_module\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int
handle_set981(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int addr = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			addr = *((unsigned int *)requests->requestvb->val.integer);
			
			if (shm_ipc_addr->mgr_printf[1])
			{
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION 981addr : %u\n", __FILE__, __FUNCTION__, __LINE__, addr);
			}
			sem_nm_p();
			shm_nm_addr->set_981.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
				
			send_local_nm_set_cmd(CMD_CODE_SET_981, (unsigned char *)&addr);
	
				
			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->set_981.ack_flag)
				{
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_set981\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}


int
handle_set998(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int addr = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			addr = *((unsigned int *)requests->requestvb->val.integer);
			
			if (shm_ipc_addr->mgr_printf[1])
			{
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION 998addr : %u\n", __FILE__, __FUNCTION__, __LINE__, addr);
			}
			sem_nm_p();
			shm_nm_addr->set_998.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();
				
			send_local_nm_set_cmd(CMD_CODE_SET_998, (unsigned char *)&addr);
	
				
			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->set_998.ack_flag)
				{
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_set998\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



int
handle_query981(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int value = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->query_981.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();

			send_local_nm_get_cmd(CMD_CODE_QUERY_981);
				
			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->query_981.ack_flag)
				{
					value = shm_nm_addr->query_981.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET 981 : %u\n", __FILE__, __FUNCTION__, __LINE__,value);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &value, sizeof(value));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
		    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
	
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_query981\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}




int
handle_query998(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int value = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->query_998.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();

			send_local_nm_get_cmd(CMD_CODE_QUERY_998);
				
			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->query_998.ack_flag)
				{
					value = shm_nm_addr->query_998.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET 998 : %u\n", __FILE__, __FUNCTION__, __LINE__,value);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &value, sizeof(value));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
		    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
	
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_query998\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}



int
handle_devCallTimeout(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	unsigned int time_out = 0;
	struct timeval delay; 
	
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->dev_call_timeout.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();

			send_local_nm_get_cmd(CMD_CODE_DEV_CALL_TIMEOUT);

			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_call_timeout.ack_flag)
				{
					time_out= shm_nm_addr->dev_call_timeout.data;
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET dev_call_timeout : %u\n", __FILE__, __FUNCTION__, __LINE__, time_out);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED, &time_out, sizeof(time_out));
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			time_out= *((unsigned int *)requests->requestvb->val.integer);
			
			if (shm_ipc_addr->mgr_printf[1])
			{
				LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_SET_ACTION dev_call_timeout : %u\n", __FILE__, __FUNCTION__, __LINE__, time_out);
			}
			sem_nm_p();
			shm_nm_addr->dev_call_timeout.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
				

		    send_local_nm_set_cmd(CMD_CODE_DEV_CALL_TIMEOUT, (unsigned char *)&time_out);
				
			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->dev_call_timeout.ack_flag)
				{
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_dev_call_timeout\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}








int
handle_scanMode(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned char scan_mode[2];
	struct timeval delay; 
    int i;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
			sem_nm_p();
			shm_nm_addr->scan_mode.ack_flag= ACK_FLAG_CLR;
			sem_nm_v();

			send_local_nm_get_cmd(CMD_CODE_SCAN_MODE);
		     for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
	
				if (ACK_FLAG_OK ==shm_nm_addr->scan_mode.ack_flag)
				{   
				    memcpy(scan_mode,shm_nm_addr->scan_mode.data,sizeof(scan_mode));
					if (shm_ipc_addr->mgr_printf[1])
					{
						LOG_DEBUG(s_i4LogMsgId, "|%s||%s||%d| MODE_GET scan mode :\n", __FILE__, __FUNCTION__, __LINE__);
					}
					snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE, scan_mode, sizeof(scan_mode));
					break;
				}

			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
			break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memcpy(scan_mode, requests->requestvb->val.string, sizeof(scan_mode));
			sem_nm_p();
			shm_nm_addr->scan_mode.ack_flag = ACK_FLAG_CLR;
			sem_nm_v();
			
            send_local_nm_set_cmd(CMD_CODE_SCAN_MODE,scan_mode);
			for (i = 0; i < timeout_cnt; i++)
			{
				delay.tv_sec = 0;
				delay.tv_usec = POLLING_INTERVA;
				select(0, NULL, NULL, NULL, &delay);
				if (ACK_FLAG_OK == shm_nm_addr->scan_mode.ack_flag)
				{
					break;
				}
			}
			if (i == timeout_cnt)
			{
				netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
			}
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_scanmode\n", reqinfo->mode );
		
            return SNMP_ERR_GENERR;
    }
    return SNMP_ERR_NOERROR;
}

int shm_cfg_attch(void)
{
	SEMUN sem_arg;
	key_t semkey;   
	key_t shmkey;  

	semkey = ftok(FTOK_F_NAME, FTOK_ID_SEM_CFG);   
	shmkey = ftok(FTOK_F_NAME, FTOK_ID_SHM_CFG);  

	shmid_cfg = shmget(shmkey, 0, 0); //获取共享内存 
	if (-1 == shmid_cfg)  
	{
		printf("attch shmid_cfg fail\n");
		return -1;
	}

	shm_cfg_addr = (SHM_CFG_STRU *)shmat(shmid_cfg, NULL, 0);
	if (-1 == (int)(shm_cfg_addr))
	{
		printf("shmat shm_cfg_addr fail\n");
		return -1;
	}

	semid_cfg = semget(semkey, 1, 0666 | IPC_CREAT);   
	if (-1 == semid_cfg) 
	{
		printf("semget semid_cfg fail\n");
		return -1;
	}

    sem_arg.val = 1;   
    if (-1 == semctl(semid_cfg, 0, SETVAL, sem_arg)) 
    {
		printf("semctl semid_cfg fail\n");
		return -1;
	}

	return 0;
}

int shm_ipc_attch(void)
{
	SEMUN sem_arg;
	key_t semkey;   
	key_t shmkey;  

	semkey = ftok(FTOK_F_NAME, FTOK_ID_SEM_IPC);   
	shmkey = ftok(FTOK_F_NAME, FTOK_ID_SHM_IPC);  

	shmid_ipc = shmget(shmkey, 0, 0); //获取共享内存 
	if (-1 == shmid_ipc)  
	{
		printf("attch shmid_ipc fail\n");
		return -1;
	}

	shm_ipc_addr = (SHM_IPC_STRU *)shmat(shmid_ipc, NULL, 0);
	if (-1 == (int)(shm_ipc_addr))
	{
		printf("shmat shm_ipc_addr fail\n");
		return -1;
	}

	semid_ipc = semget(semkey, 1, 0666 | IPC_CREAT);   
	if (-1 == semid_ipc) 
	{
		printf("semget semid_ipc fail\n");
		return -1;
	}

    sem_arg.val = 1;   
    if (-1 == semctl(semid_ipc, 0, SETVAL, sem_arg)) 
    {
		printf("semctl semid_ipc fail\n");
		return -1;
	}

	ptIPCShm = shm_ipc_addr;

	return 0;
}


int shm_nm_attch(void)
{
	SEMUN sem_arg;
	key_t semkey;   
	key_t shmkey;  

	semkey = ftok(FTOK_F_NAME, FTOK_ID_SEM_NM);   
	shmkey = ftok(FTOK_F_NAME, FTOK_ID_SHM_NM);  

	shmid_nm = shmget(shmkey, 0, 0); //获取共享内存 
	if (-1 == shmid_nm)  
	{
		printf("attch shmid_nm fail\n");
		return -1;
	}

	shm_nm_addr = (SHM_NM_STRU *)shmat(shmid_nm, NULL, 0);
	if (-1 == (int)(shm_nm_addr))
	{
		printf("shmat shm_nm_addr fail\n");
		return -1;
	}

	semid_nm = semget(semkey, 1, 0666 | IPC_CREAT);   
	if (-1 == semid_nm) 
	{
		printf("semget semid_nm fail\n");
		return -1;
	}

    sem_arg.val = 1;   
    if (-1 == semctl(semid_nm, 0, SETVAL, sem_arg)) 
    {
		printf("semctl semid_nm fail\n");
		return -1;
	}

	return 0;
}


void init_local_val(void)
{
	sem_cfg_p();
	local_dev_id = shm_cfg_addr->dev_id.val;
	local_cc = shm_cfg_addr->cc.val;
	sem_cfg_v();
}


int init_ipc_socket(void)
{
	memset(&sockaddr_mgra_adp, 0, sizeof(struct sockaddr_in));
	sockaddr_mgra_adp.sin_family = AF_INET;
	sockaddr_mgra_adp.sin_port = htons(SOCK_PORT_MGR_ADP);
	sockaddr_mgra_adp.sin_addr.s_addr = inet_addr("127.0.0.1");

	memset(&sockaddr_mgra_mgrh, 0, sizeof(struct sockaddr_in));
	sockaddr_mgra_mgrh.sin_family = AF_INET;
	sockaddr_mgra_mgrh.sin_port = htons(SOCK_PORT_MGRA_MGRH);
	sockaddr_mgra_mgrh.sin_addr.s_addr = inet_addr("127.0.0.1");
	/*手咪*/
	memset(&sockaddr_mgra_cc, 0, sizeof(struct sockaddr_in));
	sockaddr_mgra_cc.sin_family = AF_INET;
	sockaddr_mgra_cc.sin_port = htons(SOCK_PORT_MGRA_CC);
	sockaddr_mgra_cc.sin_addr.s_addr = inet_addr("127.0.0.1");

	sock_ipc = socket(AF_INET, SOCK_DGRAM, 0);
	if (-1 == sock_ipc) 
	{
		printf("sock_ipc socket error\n");
		return -1;
	}

	return 0;
}


/* 是否本地设备*/
int is_local_dev(unsigned int id)
{
	if (local_dev_id == id)
		return 1;
	else
		return 0;
}



/* 信号量的P(通过)操作 */
void sem_nm_p(void)
{
	struct sembuf s_p;
	s_p.sem_num = 0;
	s_p.sem_op = -1;
	s_p.sem_flg = SEM_UNDO;
	if (-1 == semop(semid_nm, &s_p, 1))
	{
		printf("Sem_nm_p operation fail\n");
	}
}

 
/* 信号量的V(释放)操作 */
void sem_nm_v(void)
{
	struct sembuf s_v;
	s_v.sem_num = 0;
	s_v.sem_op = 1;
	s_v.sem_flg = SEM_UNDO;
	if(-1 == semop(semid_nm, &s_v, 1))
	{
		printf("Sem_nm_v operation fail\n");
	}
}


void sem_ipc_p(void)
{
	struct sembuf s_p;
	s_p.sem_num = 0;
	s_p.sem_op = -1;
	s_p.sem_flg = SEM_UNDO;
	if (-1 == semop(semid_ipc, &s_p, 1))
	{
		printf("sem_ipc_p operation fail\n");
	}
}

 
void sem_ipc_v(void)
{
	struct sembuf s_v;
	s_v.sem_num = 0;
	s_v.sem_op = 1;
	s_v.sem_flg = SEM_UNDO;
	if(-1 == semop(semid_ipc, &s_v, 1))
	{
		printf("sem_ipc_v operation fail\n");
	}
}


void sem_cfg_p(void)
{
	struct sembuf s_p;
	s_p.sem_num = 0;
	s_p.sem_op = -1;
	s_p.sem_flg = SEM_UNDO;
	if (-1 == semop(semid_cfg, &s_p, 1))
	{
		printf("Sem_cfg_p operation fail\n");
	}
}

 
void sem_cfg_v(void)
{
	struct sembuf s_v;
	s_v.sem_num = 0;
	s_v.sem_op = 1;
	s_v.sem_flg = SEM_UNDO;
	if(-1 == semop(semid_cfg, &s_v, 1))
	{
		printf("Sem_cfg_v operation fail\n");
	}
}


unsigned char crc8(unsigned char *ptr, unsigned char len)
{
    unsigned char crc;
    unsigned char i;
    crc = 0;
    while(len--)
    {
       crc ^= *ptr++;
       for(i = 0;i < 8;i++)
       {
           if(crc & 0x80)
           {
               crc = (crc << 1) ^ 0x07;
           }
           else 
           {
			   crc <<= 1;
		   }
       }
    }
    return crc;
}


void send_remote_nm_get_cmd(unsigned short cmd_code, unsigned char dst_id)
{
	NAS_AI_PAYLOAD nas_ai_payload;
	NAS_INF_DL_T nm_ai_msg;

   /////////////////////////发送四次欲载波////////////////////////
	memset(&nas_ai_payload, 0, sizeof(NAS_AI_PAYLOAD));
	memset(&nm_ai_msg, 0, sizeof(NAS_INF_DL_T));

    nas_ai_payload.cmd_code = CMO_CODE_NAS_PRE;
	nas_ai_payload.nm_type = NM_TYPE_NM;
	nas_ai_payload.op_code = OP_CODE_GET;
	nas_ai_payload.src_id = local_dev_id;
	nas_ai_payload.dst_id = dst_id;
	nas_ai_payload.crc = crc8((unsigned char *)&nas_ai_payload, sizeof(NAS_AI_PAYLOAD) - 1);

	nm_ai_msg.TimeStamp = 0xFFFFFFFF;
	nm_ai_msg.SlotNum = 0x00;
	nm_ai_msg.TxFreq1 = 0x01;
	nm_ai_msg.TxFreq2 = 0x00;
	nm_ai_msg.ResFrqSlot = 0;
	nm_ai_msg.tDataLink[0].MsgType = DI_MSG_NM;
	nm_ai_msg.tDataLink[0].CC = local_cc;
	nm_ai_msg.tDataLink[0].DataType = DI_MSG_NM;
	nm_ai_msg.tDataLink[0].DataLen = sizeof(NAS_AI_PAYLOAD);
	memcpy(nm_ai_msg.tDataLink[0].PayLoad, &nas_ai_payload, sizeof(NAS_AI_PAYLOAD));

	sendto(sock_ipc, &nm_ai_msg, sizeof(NAS_INF_DL_T), 0, (struct sockaddr *)(&sockaddr_mgra_adp), sizeof(struct sockaddr_in));   ///发送四次与载波
    sendto(sock_ipc, &nm_ai_msg, sizeof(NAS_INF_DL_T), 0, (struct sockaddr *)(&sockaddr_mgra_adp), sizeof(struct sockaddr_in)); 
    sendto(sock_ipc, &nm_ai_msg, sizeof(NAS_INF_DL_T), 0, (struct sockaddr *)(&sockaddr_mgra_adp), sizeof(struct sockaddr_in)); 
    sendto(sock_ipc, &nm_ai_msg, sizeof(NAS_INF_DL_T), 0, (struct sockaddr *)(&sockaddr_mgra_adp), sizeof(struct sockaddr_in)); 

//////////////////////////发送链路机消息///////////////////////
    memset(&nas_ai_payload, 0, sizeof(NAS_AI_PAYLOAD));
	memset(&nm_ai_msg, 0, sizeof(NAS_INF_DL_T));
    
	nas_ai_payload.cmd_code = (unsigned char)cmd_code;
	nas_ai_payload.nm_type = NM_TYPE_NM;
	nas_ai_payload.op_code = OP_CODE_GET;
	nas_ai_payload.src_id = local_dev_id;
	nas_ai_payload.dst_id = dst_id;
	nas_ai_payload.crc = crc8((unsigned char *)&nas_ai_payload, sizeof(NAS_AI_PAYLOAD) - 1);

	nm_ai_msg.TimeStamp = 0xFFFFFFFF;
	nm_ai_msg.SlotNum = 0x00;
	nm_ai_msg.TxFreq1 = 0x01;
	nm_ai_msg.TxFreq2 = 0x00;
	nm_ai_msg.ResFrqSlot = 0;
	nm_ai_msg.tDataLink[0].MsgType = DI_MSG_NM;
	nm_ai_msg.tDataLink[0].CC = local_cc;
	nm_ai_msg.tDataLink[0].DataType = DI_MSG_NM;
	nm_ai_msg.tDataLink[0].DataLen = sizeof(NAS_AI_PAYLOAD);
	memcpy(nm_ai_msg.tDataLink[0].PayLoad, &nas_ai_payload, sizeof(NAS_AI_PAYLOAD));

    if (shm_ipc_addr->mgr_printf[1])
    {
		LOG_DEBUG(s_i4LogMsgId, \
			"\n |%s||%s||%d|\n"
			"\r cmd_code  : 0x%X\n"
			"\r nm_type   : 0x%x\n"
			"\r op_code   : 0x%X\n"
			"\r src_id	  : 0x%X\n"
			"\r dst_id	  : 0x%X\n"
			"\r crc 	  : 0x%X\n"
			"\r TimeStamp : 0x%X\n"
			"\r SlotNum   : 0x%X\n"
			"\r TxFreq1   : 0x%X\n"
			"\r TxFreq2   : 0x%X\n"
			"\r ResFrqSlot: 0x%X\n"
			"\r MsgType   : 0x%X\n"
			"\r CC        : 0x%X\n"
			"\r DataType  : 0x%X\n"
			"\r DataLen   : 0x%X\n",\
			__FILE__, __FUNCTION__, __LINE__,\
			nas_ai_payload.cmd_code, nas_ai_payload.nm_type, nas_ai_payload.op_code,\
			nas_ai_payload.src_id, nas_ai_payload.dst_id, nas_ai_payload.crc,\
			nm_ai_msg.TimeStamp, nm_ai_msg.SlotNum, nm_ai_msg.TxFreq1, nm_ai_msg.TxFreq2, nm_ai_msg.ResFrqSlot,\
			nm_ai_msg.tDataLink[0].MsgType, nm_ai_msg.tDataLink[0].CC, nm_ai_msg.tDataLink[0].DataType, nm_ai_msg.tDataLink[0].DataLen);
	}
	
	sendto(sock_ipc, &nm_ai_msg, sizeof(NAS_INF_DL_T), 0, (struct sockaddr *)(&sockaddr_mgra_adp), sizeof(struct sockaddr_in)); 
}


void send_remote_nm_set_cmd(unsigned short cmd_code, unsigned char dst_id, unsigned char * data)
{
	NAS_AI_PAYLOAD nas_ai_payload;
	NAS_INF_DL_T nm_ai_msg;


    ////////////////////////发送四次欲载波消息/////////////////////////
    memset(&nas_ai_payload, 0, sizeof(NAS_AI_PAYLOAD));
	memset(&nm_ai_msg, 0, sizeof(NAS_INF_DL_T));
	
	nas_ai_payload.cmd_code = CMO_CODE_NAS_PRE;
	nas_ai_payload.nm_type = NM_TYPE_NM;
	nas_ai_payload.op_code = OP_CODE_SET;
	nas_ai_payload.src_id = local_dev_id;
	nas_ai_payload.dst_id = dst_id;
	nas_ai_payload.crc = crc8((unsigned char *)&nas_ai_payload, sizeof(NAS_AI_PAYLOAD) - 1);
	
	nm_ai_msg.TimeStamp = 0xFFFFFFFF;
	nm_ai_msg.SlotNum = 0x00;
	nm_ai_msg.TxFreq1 = 0x01;
	nm_ai_msg.TxFreq2 = 0x00;
	nm_ai_msg.ResFrqSlot = 0;
	nm_ai_msg.tDataLink[0].MsgType = DI_MSG_NM;
	nm_ai_msg.tDataLink[0].CC = local_cc;
	nm_ai_msg.tDataLink[0].DataType = DI_MSG_NM;
	nm_ai_msg.tDataLink[0].DataLen = sizeof(NAS_AI_PAYLOAD);
	memcpy(nm_ai_msg.tDataLink[0].PayLoad, &nas_ai_payload, sizeof(NAS_AI_PAYLOAD));

    sendto(sock_ipc, &nm_ai_msg, sizeof(NAS_INF_DL_T), 0, (struct sockaddr *)(&sockaddr_mgra_adp), sizeof(struct sockaddr_in)); 
    sendto(sock_ipc, &nm_ai_msg, sizeof(NAS_INF_DL_T), 0, (struct sockaddr *)(&sockaddr_mgra_adp), sizeof(struct sockaddr_in)); 
    sendto(sock_ipc, &nm_ai_msg, sizeof(NAS_INF_DL_T), 0, (struct sockaddr *)(&sockaddr_mgra_adp), sizeof(struct sockaddr_in)); 
    sendto(sock_ipc, &nm_ai_msg, sizeof(NAS_INF_DL_T), 0, (struct sockaddr *)(&sockaddr_mgra_adp), sizeof(struct sockaddr_in)); 

    ////////////////////////发送链路机消息/////////////////////////
	memset(&nas_ai_payload, 0, sizeof(NAS_AI_PAYLOAD));
	memset(&nm_ai_msg, 0, sizeof(NAS_INF_DL_T));
	
	nas_ai_payload.cmd_code = (unsigned char)cmd_code;
	nas_ai_payload.nm_type = NM_TYPE_NM;
	nas_ai_payload.op_code = OP_CODE_SET;
	nas_ai_payload.src_id = local_dev_id;
	nas_ai_payload.dst_id = dst_id;
	memcpy(nas_ai_payload.data, data, sizeof(nas_ai_payload.data));
	nas_ai_payload.crc = crc8((unsigned char *)&nas_ai_payload, sizeof(NAS_AI_PAYLOAD) - 1);
	
	nm_ai_msg.TimeStamp = 0xFFFFFFFF;
	nm_ai_msg.SlotNum = 0x00;
	nm_ai_msg.TxFreq1 = 0x01;
	nm_ai_msg.TxFreq2 = 0x00;
	nm_ai_msg.ResFrqSlot = 0;
	nm_ai_msg.tDataLink[0].MsgType = DI_MSG_NM;
	nm_ai_msg.tDataLink[0].CC = local_cc;
	nm_ai_msg.tDataLink[0].DataType = DI_MSG_NM;
	nm_ai_msg.tDataLink[0].DataLen = sizeof(NAS_AI_PAYLOAD);
	memcpy(nm_ai_msg.tDataLink[0].PayLoad, &nas_ai_payload, sizeof(NAS_AI_PAYLOAD));
	
    if (shm_ipc_addr->mgr_printf[1])
    {
		LOG_DEBUG(s_i4LogMsgId, \
		    "\n |%s||%s||%d|\n"
			"\r cmd_code  : 0x%X\n"
			"\r nm_type   : 0x%x\n"
			"\r op_code   : 0x%X\n"
			"\r src_id	  : 0x%X\n"
			"\r dst_id	  : 0x%X\n"
			"\r crc 	  : 0x%X\n"
			"\r TimeStamp : 0x%X\n"
			"\r SlotNum   : 0x%X\n"
			"\r TxFreq1   : 0x%X\n"
			"\r TxFreq2   : 0x%X\n"
			"\r ResFrqSlot: 0x%X\n"
			"\r MsgType   : 0x%X\n"
			"\r CC        : 0x%X\n"
			"\r DataType  : 0x%X\n"
			"\r DataLen   : 0x%X\n",\
			__FILE__, __FUNCTION__, __LINE__,\
			nas_ai_payload.cmd_code, nas_ai_payload.nm_type, nas_ai_payload.op_code,\
			nas_ai_payload.src_id, nas_ai_payload.dst_id, nas_ai_payload.crc,\
			nm_ai_msg.TimeStamp, nm_ai_msg.SlotNum, nm_ai_msg.TxFreq1, nm_ai_msg.TxFreq2, nm_ai_msg.ResFrqSlot,\
			nm_ai_msg.tDataLink[0].MsgType, nm_ai_msg.tDataLink[0].CC, nm_ai_msg.tDataLink[0].DataType, nm_ai_msg.tDataLink[0].DataLen);
	}
    	
	
	sendto(sock_ipc, &nm_ai_msg, sizeof(NAS_INF_DL_T), 0, (struct sockaddr *)(&sockaddr_mgra_adp), sizeof(struct sockaddr_in)); 
}


void send_local_nm_get_cmd(unsigned short cmd_code)
{
	NM_IPC_MSG nm_ipc_msg;
	memset((unsigned char *)&nm_ipc_msg, 0 ,sizeof(NM_IPC_MSG));
	nm_ipc_msg.nm_type = NM_TYPE_NM;
	nm_ipc_msg.src_id = local_dev_id;
	nm_ipc_msg.dst_id = local_dev_id;
	nm_ipc_msg.cmd_code = cmd_code;
	nm_ipc_msg.op_code = OP_CODE_GET;
	
    if (shm_ipc_addr->mgr_printf[1])
    {
		LOG_DEBUG(s_i4LogMsgId, \
		        "\n |%s||%s||%d|\n"
			    "\r nm_type  : 0x%X\n"
			    "\r src_id   : 0x%X\n"
			    "\r dst_id   : 0x%X\n"
			    "\r cmd_code : 0x%X\n"
			    "\r op_code  : 0x%X\n",\
			    __FILE__, __FUNCTION__, __LINE__,\
			    nm_ipc_msg.nm_type, nm_ipc_msg.src_id, nm_ipc_msg.dst_id, nm_ipc_msg.cmd_code, nm_ipc_msg.op_code);
	}
	
	sendto(sock_ipc, &nm_ipc_msg, sizeof(NM_IPC_MSG), 0, (struct sockaddr *)(&sockaddr_mgra_mgrh), sizeof(struct sockaddr_in)); 
}


void send_local_nm_set_cmd(unsigned short cmd_code, unsigned char * payload)
{
	NM_IPC_MSG nm_ipc_msg;
	memset((unsigned char *)&nm_ipc_msg, 0 ,sizeof(NM_IPC_MSG));
	nm_ipc_msg.nm_type = NM_TYPE_NM;
	nm_ipc_msg.src_id = local_dev_id;
	nm_ipc_msg.dst_id = local_dev_id;
	nm_ipc_msg.cmd_code = cmd_code;
	nm_ipc_msg.op_code = OP_CODE_SET;
	memcpy(nm_ipc_msg.payload, payload, sizeof(nm_ipc_msg.payload));
	
    if (shm_ipc_addr->mgr_printf[1])
    {
		LOG_DEBUG(s_i4LogMsgId, \
		        "\n |%s||%s||%d|\n"
			    "\r nm_type  : 0x%X\n"
			    "\r src_id   : 0x%X\n"
			    "\r dst_id   : 0x%X\n"
			    "\r cmd_code : 0x%X\n"
			    "\r op_code  : 0x%X\n",\
			    __FILE__, __FUNCTION__, __LINE__,\
			    nm_ipc_msg.nm_type, nm_ipc_msg.src_id, nm_ipc_msg.dst_id, nm_ipc_msg.cmd_code, nm_ipc_msg.op_code);
	}
	
	sendto(sock_ipc, &nm_ipc_msg, sizeof(NM_IPC_MSG), 0, (struct sockaddr *)(&sockaddr_mgra_mgrh), sizeof(struct sockaddr_in)); 
}

void send_cc_set_cmd(unsigned short cmd_code, unsigned char * payload)
{
	NM_IPC_MSG nm_ipc_msg;
	memset((unsigned char *)&nm_ipc_msg, 0 ,sizeof(NM_IPC_MSG));
	nm_ipc_msg.nm_type = NM_TYPE_CENTER;
	nm_ipc_msg.src_id = local_dev_id;
	nm_ipc_msg.dst_id = local_dev_id;
	nm_ipc_msg.cmd_code = cmd_code;
	nm_ipc_msg.op_code = OP_CODE_SET;
	memcpy(nm_ipc_msg.payload, payload, sizeof(nm_ipc_msg.payload));
	
    if (shm_ipc_addr->mgr_printf[1])
    {
		LOG_DEBUG(s_i4LogMsgId, \
		        "\n |%s||%s||%d|\n"
			    "\r nm_type  : 0x%X\n"
			    "\r src_id   : 0x%X\n"
			    "\r dst_id   : 0x%X\n"
			    "\r cmd_code : 0x%X\n"
			    "\r op_code  : 0x%X\n",\
			    __FILE__, __FUNCTION__, __LINE__,\
			    nm_ipc_msg.nm_type, nm_ipc_msg.src_id, nm_ipc_msg.dst_id, nm_ipc_msg.cmd_code, nm_ipc_msg.op_code);
	}
	
	sendto(sock_ipc, &nm_ipc_msg, sizeof(NM_IPC_MSG), 0, (struct sockaddr *)(&sockaddr_mgra_cc), sizeof(struct sockaddr_in)); 
}

void send_cc_get_cmd(unsigned short cmd_code)
{
	NM_IPC_MSG nm_ipc_msg;
	memset((unsigned char *)&nm_ipc_msg, 0 ,sizeof(NM_IPC_MSG));
	nm_ipc_msg.nm_type = NM_TYPE_CENTER;
	nm_ipc_msg.src_id = local_dev_id;
	nm_ipc_msg.dst_id = local_dev_id;
	nm_ipc_msg.cmd_code = cmd_code;
	nm_ipc_msg.op_code = OP_CODE_GET;
    if (shm_ipc_addr->mgr_printf[1])
    {
		LOG_DEBUG(s_i4LogMsgId, \
		        "\n |%s||%s||%d|\n"
			    "\r nm_type  : 0x%X\n"
			    "\r src_id   : 0x%X\n"
			    "\r dst_id   : 0x%X\n"
			    "\r cmd_code : 0x%X\n"
			    "\r op_code  : 0x%X\n",\
			    __FILE__, __FUNCTION__, __LINE__,\
			    nm_ipc_msg.nm_type, nm_ipc_msg.src_id, nm_ipc_msg.dst_id, nm_ipc_msg.cmd_code, nm_ipc_msg.op_code);
	}
	
	sendto(sock_ipc, &nm_ipc_msg, sizeof(NM_IPC_MSG), 0, (struct sockaddr *)(&sockaddr_mgra_cc), sizeof(struct sockaddr_in)); 
	}



int bin_to_bz2(char * bin_name, char * bz2_name)
{
	FILE * bin_file;
	FILE * bz2_file;
	unsigned int bin_name_len = 0;
	unsigned int bin_file_len;
    unsigned int suffixation_len = strlen(".bin");
	unsigned int i_loop = 0;
	unsigned int loop_cnt;
	int remainder;
	char buf[BUFFERSIZE];

	bin_name_len = strlen(bin_name);
	if (50 < bin_name_len)
	{
		printf("name too long!\n");
		return -1;
	}

	if (0 != strcmp(".bin", bin_name + bin_name_len - suffixation_len))
	{
		printf("err file!\n");
		return -1;
	}
	else
	{
		strncpy(bz2_name, bin_name, bin_name_len - suffixation_len);
		strcat(bz2_name, ".tar.bz2");
		//printf("%s\n", bz2_name);
	    bz2_file = fopen(bz2_name, "wb+");
		if (NULL == bz2_file)
		{
			printf("bz2_file fopen err\n");
			return -1;
		}
		bin_file = fopen(bin_name, "rb");
		if (NULL == bin_file)
		{
			printf("bin_file fopen err\n");
			return -1;
		}

		if (MD5_LEN != (int)fread(md5_sum_in_bin, sizeof(char), MD5_LEN, bin_file))
		{
			printf("fread md5 err\n");
			fclose(bz2_file);
			fclose(bin_file);
			return -1;
		}

		fseek(bin_file, 0, SEEK_END);
		bin_file_len = ftell(bin_file);
		fseek(bin_file, FILE_INFO_LEN, SEEK_SET);
        loop_cnt = (bin_file_len - FILE_INFO_LEN) / BUFFERSIZE;
		remainder = (bin_file_len - FILE_INFO_LEN) % BUFFERSIZE;
		
		for (i_loop = 0; i_loop < loop_cnt; i_loop++)
		{
			if (BUFFERSIZE != fread(buf, sizeof(char), BUFFERSIZE, bin_file))
			{
				printf("fread err\n");
				fclose(bz2_file);
				fclose(bin_file);
				return -1;
			}
			else 
			{
				if (BUFFERSIZE != fwrite(buf, sizeof(char), BUFFERSIZE, bz2_file))
				{
					printf("fwrite err\n");
					fclose(bz2_file);
					fclose(bin_file);
					return -1;
				}
			}
		}

		if (remainder != (int)fread(buf, sizeof(char), remainder, bin_file))
		{
			printf("fread remainder err\n");
			fclose(bz2_file);
			fclose(bin_file);
			return -1;
		}
		else 
		{
			if (remainder != (int)fwrite(buf, sizeof(char), remainder, bz2_file))
			{
				printf("fwrite remainder err\n");
				fclose(bz2_file);
				fclose(bin_file);
				return -1;
			}
		}

		fclose(bz2_file);
		fclose(bin_file);
		
		if(!CalcFileMD5(bz2_name, md5_sum))
		{
			printf("call CalcFileMD5 err\n");
			return -1;
		}

		if (0 != strncmp(md5_sum, md5_sum_in_bin, MD5_LEN))
		{
			printf("invalid update file\n");
			return -1;
		}
    }

	return 0;
}



void md5()
{
	a=A,b=B,c=C,d=D;

	/**//* Round 1 */
	FF (a, b, c, d, x[ 0], 7, 0xd76aa478); /**//* 1 */
	FF (d, a, b, c, x[ 1], 12, 0xe8c7b756); /**//* 2 */
	FF (c, d, a, b, x[ 2], 17, 0x242070db); /**//* 3 */
	FF (b, c, d, a, x[ 3], 22, 0xc1bdceee); /**//* 4 */
	FF (a, b, c, d, x[ 4], 7, 0xf57c0faf); /**//* 5 */
	FF (d, a, b, c, x[ 5], 12, 0x4787c62a); /**//* 6 */
	FF (c, d, a, b, x[ 6], 17, 0xa8304613); /**//* 7 */
	FF (b, c, d, a, x[ 7], 22, 0xfd469501); /**//* 8 */
	FF (a, b, c, d, x[ 8], 7, 0x698098d8); /**//* 9 */
	FF (d, a, b, c, x[ 9], 12, 0x8b44f7af); /**//* 10 */
	FF (c, d, a, b, x[10], 17, 0xffff5bb1); /**//* 11 */
	FF (b, c, d, a, x[11], 22, 0x895cd7be); /**//* 12 */
	FF (a, b, c, d, x[12], 7, 0x6b901122); /**//* 13 */
	FF (d, a, b, c, x[13], 12, 0xfd987193); /**//* 14 */
	FF (c, d, a, b, x[14], 17, 0xa679438e); /**//* 15 */
	FF (b, c, d, a, x[15], 22, 0x49b40821); /**//* 16 */

	/**//* Round 2 */
	GG (a, b, c, d, x[ 1], 5, 0xf61e2562); /**//* 17 */
	GG (d, a, b, c, x[ 6], 9, 0xc040b340); /**//* 18 */
	GG (c, d, a, b, x[11], 14, 0x265e5a51); /**//* 19 */
	GG (b, c, d, a, x[ 0], 20, 0xe9b6c7aa); /**//* 20 */
	GG (a, b, c, d, x[ 5], 5, 0xd62f105d); /**//* 21 */
	GG (d, a, b, c, x[10], 9, 0x02441453); /**//* 22 */
	GG (c, d, a, b, x[15], 14, 0xd8a1e681); /**//* 23 */
	GG (b, c, d, a, x[ 4], 20, 0xe7d3fbc8); /**//* 24 */
	GG (a, b, c, d, x[ 9], 5, 0x21e1cde6); /**//* 25 */
	GG (d, a, b, c, x[14], 9, 0xc33707d6); /**//* 26 */
	GG (c, d, a, b, x[ 3], 14, 0xf4d50d87); /**//* 27 */
	GG (b, c, d, a, x[ 8], 20, 0x455a14ed); /**//* 28 */
	GG (a, b, c, d, x[13], 5, 0xa9e3e905); /**//* 29 */
	GG (d, a, b, c, x[ 2], 9, 0xfcefa3f8); /**//* 30 */
	GG (c, d, a, b, x[ 7], 14, 0x676f02d9); /**//* 31 */
	GG (b, c, d, a, x[12], 20, 0x8d2a4c8a); /**//* 32 */

	/**//* Round 3 */
	HH (a, b, c, d, x[ 5], 4, 0xfffa3942); /**//* 33 */
	HH (d, a, b, c, x[ 8], 11, 0x8771f681); /**//* 34 */
	HH (c, d, a, b, x[11], 16, 0x6d9d6122); /**//* 35 */
	HH (b, c, d, a, x[14], 23, 0xfde5380c); /**//* 36 */
	HH (a, b, c, d, x[ 1], 4, 0xa4beea44); /**//* 37 */
	HH (d, a, b, c, x[ 4], 11, 0x4bdecfa9); /**//* 38 */
	HH (c, d, a, b, x[ 7], 16, 0xf6bb4b60); /**//* 39 */
	HH (b, c, d, a, x[10], 23, 0xbebfbc70); /**//* 40 */
	HH (a, b, c, d, x[13], 4, 0x289b7ec6); /**//* 41 */
	HH (d, a, b, c, x[ 0], 11, 0xeaa127fa); /**//* 42 */
	HH (c, d, a, b, x[ 3], 16, 0xd4ef3085); /**//* 43 */
	HH (b, c, d, a, x[ 6], 23, 0x04881d05); /**//* 44 */
	HH (a, b, c, d, x[ 9], 4, 0xd9d4d039); /**//* 45 */
	HH (d, a, b, c, x[12], 11, 0xe6db99e5); /**//* 46 */
	HH (c, d, a, b, x[15], 16, 0x1fa27cf8); /**//* 47 */
	HH (b, c, d, a, x[ 2], 23, 0xc4ac5665); /**//* 48 */

	/**//* Round 4 */
	II (a, b, c, d, x[ 0], 6, 0xf4292244); /**//* 49 */
	II (d, a, b, c, x[ 7], 10, 0x432aff97); /**//* 50 */
	II (c, d, a, b, x[14], 15, 0xab9423a7); /**//* 51 */
	II (b, c, d, a, x[ 5], 21, 0xfc93a039); /**//* 52 */
	II (a, b, c, d, x[12], 6, 0x655b59c3); /**//* 53 */
	II (d, a, b, c, x[ 3], 10, 0x8f0ccc92); /**//* 54 */
	II (c, d, a, b, x[10], 15, 0xffeff47d); /**//* 55 */
	II (b, c, d, a, x[ 1], 21, 0x85845dd1); /**//* 56 */
	II (a, b, c, d, x[ 8], 6, 0x6fa87e4f); /**//* 57 */
	II (d, a, b, c, x[15], 10, 0xfe2ce6e0); /**//* 58 */
	II (c, d, a, b, x[ 6], 15, 0xa3014314); /**//* 59 */
	II (b, c, d, a, x[13], 21, 0x4e0811a1); /**//* 60 */
	II (a, b, c, d, x[ 4], 6, 0xf7537e82); /**//* 61 */
	II (d, a, b, c, x[11], 10, 0xbd3af235); /**//* 62 */
	II (c, d, a, b, x[ 2], 15, 0x2ad7d2bb); /**//* 63 */
	II (b, c, d, a, x[ 9], 21, 0xeb86d391); /**//* 64 */

	A += a;
	B += b;
	C += c;
	D += d;
}


int CalcFileMD5(char *filename, char *md5_sum)
{
	if (filename[0]==34) 
	{
		filename[strlen(filename)-1]=0;
		strcpy(filename,filename+1);
	}
	
	if (!strcmp(filename,"exit")) 
	{
		exit(0);
	}
	
	if (!(fp=fopen(filename,"rb"))) //
	{
		printf("Can not open this file!\n");
		return 0;
	}

	fseek(fp, 0, SEEK_END);

	if((len=ftell(fp))==-1)
	{
		printf("Sorry! Can not calculate files which larger than 2 GB!\n");
		fclose(fp);
		return 0;
	}

	rewind(fp);

	A=0x67452301,B=0xefcdab89,C=0x98badcfe,D=0x10325476;

	flen[1]=len/0x20000000;

	flen[0]=(len%0x20000000)*8;

	memset(x,0,64);

	fread(&x,4,16,fp);

	for(i=0; i<len/64; i++)
	{
		md5();
		memset(x,0,64);
		fread(&x,4,16,fp);
	}

	((char*)x)[len%64]=128;

	if(len%64>55) 
	{
		md5();
		memset(x,0,64);
	}

	memcpy(x+14,flen,8);

	md5();

	fclose(fp);

	sprintf(md5_sum,"%08x%08x%08x%08x",PP(A),PP(B),PP(C),PP(D));

	return 1;
}



int  confirm_mount_point()
{
    unsigned int size;
    pid_t status;

    FILE *fd;

    fd = popen("/loadapp/mount.sh", "r");

    if(fd==NULL)
    {
        printf("open /loadapp/mount.sh file error!\n");
        return -1;
    }

    memset(buffer,0x00,sizeof(buffer));

    if(fgets((char*)buffer, sizeof(buffer), fd)==NULL)
    {
        printf("get mount point error!\n");
        return -1 ;
    }

    printf("current mount point %s on /loadapp\n",buffer);

    pclose(fd);

    if(strcmp((char*)buffer,"/dev/mtdblock6\n")==0)
    {
        status = system("mount -t jffs2 /dev/mtdblock7 /mnt");
        printf("mount /dev/mtdblock7 on /mnt\n");
    }
    else
    {
        status = system("mount -t jffs2 /dev/mtdblock6 /mnt");
        printf("mount /dev/mtdblock6 on /mnt\n");
    }

    if (-1 == status)
    {
        printf("mount /dev/mtdblockx on /mnt failed!\n");
        return -1 ;
    }
    else
    {
        if (WIFEXITED(status))
        {
            if (0 == WEXITSTATUS(status))
            {
                	chdir("/mnt");
	                return 0;
            }
            else
            {
                printf("mount /dev/mtdblockx on /mnt WEXITSTATUS(status) failed!\n");
                return -1 ;
            }
        }
        else
        {
            printf("mount /dev/mtdblockx on /mnt WIFEXITED(status) failed!\n");
            return -1 ;
        }
    }

}



int test_code(int status)
{
    if (-1 == status) 
    { 
        printf("system return failed!\n");
		return -1;
			
	}
	else
    {
        if (WIFEXITED(status))
		{
		    if(0 == WEXITSTATUS(status))
			{
		        return 0;
			}
			else
			{
			    printf(" WEXITSTATUS(status) failed!\n");	   
		   		return -1;
			}
		}
		else  
		{  
		    printf("WIFEXITED(status) failed!\n");
			return -1;
		   	
		}
	}
}

#if 0








int

handle_updateData(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
	unsigned int i = 0;
	struct timeval delay; 
	int status=0;
	char buffer_active[]="active\n";
	char buffer_back[]="back\n";
	char buffer_error[]="error\n";
	unsigned int len=strlen(".bin");
	unsigned file_type[50]={0};
	unsigned char ip[50]={0};
	unsigned char file_name[50]={0};
	unsigned char data_packet[200]={0};
	char bz2_file_name[50] = {0};
	FILE * fd;
	unsigned int size;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
			memset(data_packet,0,sizeof(data_packet));
			memcpy(data_packet, requests->requestvb->val.string, sizeof(data_packet));
			memset(ip,0,sizeof(ip));
			memcpy(ip,data_packet+2,data_packet[0]);
			memset(file_name,0,sizeof(file_name));
			memcpy(file_name,data_packet+2+data_packet[0],data_packet[1]);
		    memset(data_packet,0,sizeof(data_packet));
			sprintf(data_packet, "tftp -gr %s %s", file_name, ip);


		    if(confirm_mount_point())
			{
			    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);	   
			}
			status=system((const char *)data_packet);

			if (-1 == status) 
			{  
		        printf("system return failed!\n");
			    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);							 
			} 
			else 
			{ 
		        if (WIFEXITED(status)) 
			    {  
				    if (0 == WEXITSTATUS(status))  
					{   

					    memset(file_type,0,sizeof(file_type));
			            memcpy(file_type,data_packet+2+data_packet[0],data_packet[1]-len);
						printf("%s\n",file_type);
						if(strcmp((char *)file_type,"loadapp")==0)
						{
						    printf("2");
    					    memset(bz2_file_name,0,sizeof(bz2_file_name));
    					    if (0 != bin_to_bz2(file_name, bz2_file_name))
    					    {
    				            printf(" WEXITSTATUS(status) failed!\n");
								chdir("/");
    			                system("umount /mnt");
    						    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);	
    						}
    						else
    						{
    						    memset(data_packet, 0, sizeof(data_packet));
    						    sprintf(data_packet, "tar -jxvf %s", bz2_file_name);
    							status = system((const char *)data_packet);
    						    if (-1 == status) 
    						    {  
    							    printf("system tar return failed!\n");
									chdir("/");
    			                    system("umount /mnt");
    			                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);									
    							} 
    							else 
    							{ 
    							    if (WIFEXITED(status)) 
    								{  
    							        if (0 == WEXITSTATUS(status))  
    									{  
    
                                            fd=fopen("/mnt/loadflag","wb");
    
                                            if(fd == NULL)
                                            {
                                                printf("open /mnt/loadflag file error!\n");
												chdir("/");
    			                                system("umount /mnt");
    	                                        netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
     
                                            }
                                            size=strlen(buffer_active);
                                            fwrite(buffer_active,size,1,fd);
                                            fclose(fd);
    										if(strcmp((char *)buffer,"/dev/mtdblock5\n")!=0)
    	                                    {
            
    	                                        fd=fopen("/loadapp/loadflag","wb");
    
                                                if(fd == NULL)
                                                {
                                                    printf("open /loadapp/loadflag file failed!\n");
													chdir("/");
    			                                    system("umount /mnt");
                                                    netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);
                                                }
    
                                                size=strlen(buffer_back);
                                                fwrite(buffer_back,size,1,fd);
                                                fclose(fd); 
    	                                    }
											system("cp -rf /loadapp/nas_config.ini /mnt");
											chdir("/");
    	                                    system("umount /mnt");
    									}  
    									else  
    									{  
    									    printf(" tar WEXITSTATUS(status) failed!\n");	   
    						                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);												
    									}  
    								} 
    								else 
    								{  
    								    printf( "tar WIFEXITED(status) failed!\n");	   
                                        netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);										
    								}  
    							} 
    						  }
							}
						else
						{
						    chdir("/");
    	                    system("umount /mnt");  
						}
					 }  
					 else  
					 {  
				         printf(" WEXITSTATUS(status) failed!\n");	   
						 netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);	
					 }  
				   } 
				   else 
				   {  
				       printf( "WIFEXITED(status) failed!\n");	   
                       netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_BADVALUE);

				   }  
			    } 
		 break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_localCombinedData\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}

int
handle_nodeINTrw(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     /* XXX: a pointer to the scalar's data */,
                                     /* XXX: the length of the data in bytes */);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            if (/* XXX: error? */) {
                netsnmp_set_request_error(reqinfo, requests, /* some error */);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_nodeINTrw\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_nodeUINTrw(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED,
                                     /* XXX: a pointer to the scalar's data */,
                                     /* XXX: the length of the data in bytes */);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            if (/* XXX: error? */) {
                netsnmp_set_request_error(reqinfo, requests, /* some error */);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_nodeUINTrw\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_nodeSTRrw(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     /* XXX: a pointer to the scalar's data */,
                                     /* XXX: the length of the data in bytes */);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OCTET_STR);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            if (/* XXX: error? */) {
                netsnmp_set_request_error(reqinfo, requests, /* some error */);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_nodeSTRrw\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_nodeIPrw(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,
                                     /* XXX: a pointer to the scalar's data */,
                                     /* XXX: the length of the data in bytes */);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_IPADDRESS);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            if (/* XXX: error? */) {
                netsnmp_set_request_error(reqinfo, requests, /* some error */);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_nodeIPrw\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_nodeINTr(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
                                     /* XXX: a pointer to the scalar's data */,
                                     /* XXX: the length of the data in bytes */);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_nodeINTr\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_nodeUINTr(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED,
                                     /* XXX: a pointer to the scalar's data */,
                                     /* XXX: the length of the data in bytes */);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_nodeUINTr\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_nodeSTRr(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_OCTET_STR,
                                     /* XXX: a pointer to the scalar's data */,
                                     /* XXX: the length of the data in bytes */);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_nodeSTRr\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_nodeIPr(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_IPADDRESS,
                                     /* XXX: a pointer to the scalar's data */,
                                     /* XXX: the length of the data in bytes */);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_nodeIPr\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_nodeOPAQUErw(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    int ret;
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE,
                                     /* XXX: a pointer to the scalar's data */,
                                     /* XXX: the length of the data in bytes */);
            break;

        /*
         * SET REQUEST
         *
         * multiple states in the transaction.  See:
         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
         */
        case MODE_SET_RESERVE1:
                /* or you could use netsnmp_check_vb_type_and_size instead */
            ret = netsnmp_check_vb_type(requests->requestvb, ASN_OPAQUE);
            if ( ret != SNMP_ERR_NOERROR ) {
                netsnmp_set_request_error(reqinfo, requests, ret );
            }
            break;

        case MODE_SET_RESERVE2:
            /* XXX malloc "undo" storage buffer */
            if (/* XXX if malloc, or whatever, failed: */) {
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
            }
            break;

        case MODE_SET_FREE:
            /* XXX: free resources allocated in RESERVE1 and/or
               RESERVE2.  Something failed somewhere, and the states
               below won't be called. */
            break;

        case MODE_SET_ACTION:
            /* XXX: perform the value change here */
            if (/* XXX: error? */) {
                netsnmp_set_request_error(reqinfo, requests, /* some error */);
            }
            break;

        case MODE_SET_COMMIT:
            /* XXX: delete temporary storage */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
            }
            break;

        case MODE_SET_UNDO:
            /* XXX: UNDO and return to previous value for the object */
            if (/* XXX: error? */) {
                /* try _really_really_ hard to never get to this point */
                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
            }
            break;

        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_nodeOPAQUErw\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
int
handle_nodeOPAQUEr(netsnmp_mib_handler *handler,
                          netsnmp_handler_registration *reginfo,
                          netsnmp_agent_request_info   *reqinfo,
                          netsnmp_request_info         *requests)
{
    /* We are never called for a GETNEXT if it's registered as a
       "instance", as it's "magically" handled for us.  */

    /* a instance handler also only hands us one request at a time, so
       we don't need to loop over a list of requests; we'll only get one. */
    
    switch(reqinfo->mode) {

        case MODE_GET:
            snmp_set_var_typed_value(requests->requestvb, ASN_OPAQUE,
                                     /* XXX: a pointer to the scalar's data */,
                                     /* XXX: the length of the data in bytes */);
            break;


        default:
            /* we should never get here, so this is a really bad error */
            snmp_log(LOG_ERR, "unknown mode (%d) in handle_nodeOPAQUEr\n", reqinfo->mode );
            return SNMP_ERR_GENERR;
    }

    return SNMP_ERR_NOERROR;
}
#endif
